<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从经典问题入手，吃透动态规划核心（DP五部曲实战） | 数据结构与算法学习笔记</title>
    <meta name="description" content="前端工程师的算法系统化学习指南">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/ds-algo/assets/style.B66l8Vrp.css" as="style">
    <link rel="preload stylesheet" href="/ds-algo/vp-icons.css" as="style">
    
    <script type="module" src="/ds-algo/assets/app.B10ddQOp.js"></script>
    <link rel="preload" href="/ds-algo/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/theme.fCM-gQVs.js">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/framework.CRdajAWK.js">
    <link rel="modulepreload" href="/ds-algo/assets/notes_03-04-dp1.md.CpNakAf-.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-6d407042><!--[--><!--]--><!--[--><span tabindex="-1" data-v-ba3da56b></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-ba3da56b>Skip to content</a><!--]--><!----><header class="VPNav" data-v-6d407042 data-v-d7238be4><div class="VPNavBar" data-v-d7238be4 data-v-8c571379><div class="wrapper" data-v-8c571379><div class="container" data-v-8c571379><div class="title" data-v-8c571379><div class="VPNavBarTitle has-sidebar" data-v-8c571379 data-v-980706ad><a class="title" href="/ds-algo/" data-v-980706ad><!--[--><!--]--><!----><span data-v-980706ad>数据结构与算法学习笔记</span><!--[--><!--]--></a></div></div><div class="content" data-v-8c571379><div class="content-body" data-v-8c571379><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8c571379><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8c571379 data-v-a2551964><span id="main-nav-aria-label" class="visually-hidden" data-v-a2551964> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/01-prepare.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>学习笔记</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/leetcode.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>刷题指南</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8c571379 data-v-b2d09d06><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-b2d09d06 data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8c571379 data-v-71ee68fe data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8c571379 data-v-3b81dbff data-v-db67345a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-db67345a><span class="vpi-more-horizontal icon" data-v-db67345a></span></button><div class="menu" data-v-db67345a><div class="VPMenu" data-v-db67345a data-v-2d04c868><!----><!--[--><!--[--><!----><div class="group" data-v-3b81dbff><div class="item appearance" data-v-3b81dbff><p class="label" data-v-3b81dbff>Appearance</p><div class="appearance-action" data-v-3b81dbff><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3b81dbff data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div></div></div><div class="group" data-v-3b81dbff><div class="item social-links" data-v-3b81dbff><div class="VPSocialLinks social-links-list" data-v-3b81dbff data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8c571379 data-v-c7311208><span class="container" data-v-c7311208><span class="top" data-v-c7311208></span><span class="middle" data-v-c7311208></span><span class="bottom" data-v-c7311208></span></span></button></div></div></div></div><div class="divider" data-v-8c571379><div class="divider-line" data-v-8c571379></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-6d407042 data-v-81ec55a2><div class="container" data-v-81ec55a2><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-81ec55a2><span class="vpi-align-left menu-icon" data-v-81ec55a2></span><span class="menu-text" data-v-81ec55a2>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-81ec55a2 data-v-dfa7dd31><button data-v-dfa7dd31>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-6d407042 data-v-f5bdc5c7><div class="curtain" data-v-f5bdc5c7></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-f5bdc5c7><span class="visually-hidden" id="sidebar-aria-label" data-v-f5bdc5c7> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/01-prepare.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前置准备</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>基础数据结构</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%95%B0%E7%BB%84--%E9%93%BE%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>数组 & 链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-01-linked-list-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>单向链表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%88--%E9%98%9F%E5%88%97" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-03-stack-queue-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E5%93%88%E5%B8%8C%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-02-hash-table-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%91--%E5%A0%86" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>树 & 堆</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-optimized.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树优化版实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-05-heap-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>堆实现详解</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link has-active" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>核心算法思想</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>算法思想总览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-01-two-pointers.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>双指针详解</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible has-active" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" role="button" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><h3 class="text" data-v-fe5fc7a5>动态规划</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-fe5fc7a5><span class="vpi-chevron-right caret-icon" data-v-fe5fc7a5></span></div></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp1.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP基础：五部曲框架</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp2.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP进阶：背包问题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp3.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP高级：完全背包变形</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/dp-frontend-blog.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端必备DP：10道经典题目</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/04-frontend.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端专项算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/leetcode.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>LeetCode 刷题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-6d407042 data-v-7ba754bd><div class="VPDoc has-sidebar has-aside" data-v-7ba754bd data-v-87c78cff><!--[--><!--]--><div class="container" data-v-87c78cff><div class="aside" data-v-87c78cff><div class="aside-curtain" data-v-87c78cff></div><div class="aside-container" data-v-87c78cff><div class="aside-content" data-v-87c78cff><div class="VPDocAside" data-v-87c78cff data-v-a4047630><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-a4047630 data-v-fc01bd9a><div class="content" data-v-fc01bd9a><div class="outline-marker" data-v-fc01bd9a></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-fc01bd9a>On this page</div><ul class="VPDocOutlineItem root" data-v-fc01bd9a data-v-d7fbdf5f><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-a4047630></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-87c78cff><div class="content-container" data-v-87c78cff><!--[--><!--]--><main class="main" data-v-87c78cff><div style="position:relative;" class="vp-doc _ds-algo_notes_03-04-dp1" data-v-87c78cff><div><h1 id="从经典问题入手-吃透动态规划核心-dp五部曲实战" tabindex="-1">从经典问题入手，吃透动态规划核心（DP五部曲实战） <a class="header-anchor" href="#从经典问题入手-吃透动态规划核心-dp五部曲实战" aria-label="Permalink to &quot;从经典问题入手，吃透动态规划核心（DP五部曲实战）&quot;">​</a></h1><p>动态规划（Dynamic Programming，简称DP）是算法面试中的高频考点，其核心思想是「将复杂问题拆解为重叠子问题，通过存储子问题的解避免重复计算」。想要掌握DP，最有效的方式是从经典问题出发，用「DP五部曲」的框架拆解问题——这是一套标准化的分析方法，能帮我们快速理清思路、写出正确代码。</p><p>本文将结合<strong>斐波那契数、爬楼梯、最小花费爬楼梯、机器人路径（含障碍物）、整数拆分、不同的BST、01背包</strong>等8个经典问题，手把手教你用「DP五部曲」分析和实现动态规划解法。</p><h2 id="一、动态规划五部曲-核心框架" tabindex="-1">一、动态规划五部曲（核心框架） <a class="header-anchor" href="#一、动态规划五部曲-核心框架" aria-label="Permalink to &quot;一、动态规划五部曲（核心框架）&quot;">​</a></h2><p>无论什么DP问题，都可以按以下5个步骤拆解，这是解决DP问题的「万能钥匙」：</p><ol><li><p><strong>确定dp数组及下标的含义</strong>：明确<code>dp[i]</code>（或二维<code>dp[i][j]</code>）代表什么物理意义（比如&quot;第i阶台阶的爬法数&quot;）；</p></li><li><p><strong>确定递推公式</strong>：找到<code>dp[i]</code>与子问题<code>dp[i-1]</code>/<code>dp[i-2]</code>等的依赖关系（核心）；</p></li><li><p><strong>dp数组如何初始化</strong>：根据问题边界条件，初始化无法通过递推得到的基础值；</p></li><li><p><strong>确定遍历顺序</strong>：保证计算<code>dp[i]</code>时，其依赖的子问题已经被计算完成；</p></li><li><p><strong>打印dp数组（验证）</strong>：通过打印中间结果，验证递推逻辑是否正确（调试必备）。</p></li></ol><p>下面结合具体问题，逐一实战这套框架。</p><h2 id="二、经典问题实战-从基础到进阶" tabindex="-1">二、经典问题实战：从基础到进阶 <a class="header-anchor" href="#二、经典问题实战-从基础到进阶" aria-label="Permalink to &quot;二、经典问题实战：从基础到进阶&quot;">​</a></h2><h3 id="问题1-斐波那契数-入门" tabindex="-1">问题1：斐波那契数（入门） <a class="header-anchor" href="#问题1-斐波那契数-入门" aria-label="Permalink to &quot;问题1：斐波那契数（入门）&quot;">​</a></h3><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noreferrer">509. 斐波那契数</a></p><h4 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>斐波那契数通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>F(0) = 0，F(1) = 1</span></span>
<span class="line"><span>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>给定 <code>n</code>，请计算 <code>F(n)</code>。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 2</span></span>
<span class="line"><span>输出：1</span></span>
<span class="line"><span>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 3</span></span>
<span class="line"><span>输出：2</span></span>
<span class="line"><span>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 4</span></span>
<span class="line"><span>输出：3</span></span>
<span class="line"><span>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><h4 id="dp五部曲分析" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i]</code> 表示第i个斐波那契数，下标i对应斐波那契数的序号；</p></li><li><p><strong>递推公式</strong>：<code>dp[i] = dp[i-1] + dp[i-2]</code>；</p></li><li><p><strong>初始化</strong>：<code>dp[0] = 0</code>，<code>dp[1] = 1</code>；</p></li><li><p><strong>遍历顺序</strong>：从左到右（i从2到n），保证计算<code>dp[i]</code>时，<code>dp[i-1]</code>和<code>dp[i-2]</code>已计算；</p></li><li><p><strong>打印验证</strong>：遍历过程中打印dp数组，验证每一步的和是否正确。</p></li></ol><h4 id="具体分析" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>斐波那契数列的定义本身就是递归的：<code>F(n) = F(n-1) + F(n-2)</code>。如果用递归直接计算，会有大量重复计算（如计算 F(5) 时会重复计算 F(3)、F(2) 等）。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>识别重叠子问题</strong>：计算 F(n) 需要 F(n-1) 和 F(n-2)，而计算 F(n-1) 又需要 F(n-2) 和 F(n-3)，存在重叠。</p></li><li><p><strong>状态定义</strong>：<code>dp[i]</code> 表示第 i 个斐波那契数，这是最直观的定义。</p></li><li><p><strong>状态转移</strong>：题目已经给出了递推关系：<code>F(n) = F(n-1) + F(n-2)</code>，直接套用即可。</p></li><li><p><strong>边界条件</strong>：题目明确给出 F(0) = 0，F(1) = 1，这就是初始化。</p></li></ol><p><strong>执行过程示例（n=5）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[0] = 0  (初始化)</span></span>
<span class="line"><span>dp[1] = 1  (初始化)</span></span>
<span class="line"><span>dp[2] = dp[1] + dp[0] = 1 + 0 = 1</span></span>
<span class="line"><span>dp[3] = dp[2] + dp[1] = 1 + 1 = 2</span></span>
<span class="line"><span>dp[4] = dp[3] + dp[2] = 2 + 1 = 3</span></span>
<span class="line"><span>dp[5] = dp[4] + dp[3] = 3 + 2 = 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="实现代码-两种版本" tabindex="-1">实现代码（两种版本） <a class="header-anchor" href="#实现代码-两种版本" aria-label="Permalink to &quot;实现代码（两种版本）&quot;">​</a></h4><h5 id="版本1-数组版-直观-空间o-n" tabindex="-1">版本1：数组版（直观，空间O(n)） <a class="header-anchor" href="#版本1-数组版-直观-空间o-n" aria-label="Permalink to &quot;版本1：数组版（直观，空间O(n)）&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`dp数组更新：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>空间优化思路</strong>：</p><p>观察数组版代码，我们发现一个关键点：计算 <code>dp[i]</code> 时，<strong>只需要用到 <code>dp[i-1]</code> 和 <code>dp[i-2]</code> 两个值</strong>，而 <code>dp[0]</code> 到 <code>dp[i-3]</code> 的值在计算完 <code>dp[i-1]</code> 后就不再需要了。</p><p><strong>优化过程</strong>：</p><ol><li><p><strong>发现问题</strong>：数组版需要存储整个 <code>dp</code> 数组（长度为 n+1），空间复杂度 O(n)，但实际上我们只需要保存最近的两个值。</p></li><li><p><strong>分析依赖关系</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[i] = dp[i-1] + dp[i-2]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>每次计算只需要前两个值，可以用三个变量滚动更新。</p></li><li><p><strong>优化方案</strong>：</p><ul><li>用 <code>prevPrev</code> 保存 <code>dp[i-2]</code>（前前一个值）</li><li>用 <code>prev</code> 保存 <code>dp[i-1]</code>（前一个值）</li><li>用 <code>current</code> 保存 <code>dp[i]</code>（当前值）</li><li>每次循环后，更新这三个变量，实现&quot;滚动窗口&quot;</li></ul></li><li><p><strong>变量更新逻辑</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 计算当前值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前前一个值 ← 前一个值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前一个值 ← 当前值</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样在下次循环时，<code>prevPrev</code> 和 <code>prev</code> 就是新的 <code>dp[i-2]</code> 和 <code>dp[i-1]</code>。</p></li></ol><p><strong>优化效果</strong>：</p><ul><li><strong>空间复杂度</strong>：从 O(n) 降低到 O(1)</li><li><strong>时间复杂度</strong>：保持 O(n) 不变</li><li><strong>代码可读性</strong>：稍微降低，但空间效率大幅提升</li></ul><h5 id="版本2-空间优化版-空间o-1" tabindex="-1">版本2：空间优化版（空间O(1)） <a class="header-anchor" href="#版本2-空间优化版-空间o-1" aria-label="Permalink to &quot;版本2：空间优化版（空间O(1)）&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对应dp[i-2]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对应dp[i-1]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}个斐波那契数：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="问题2-爬楼梯-基础" tabindex="-1">问题2：爬楼梯（基础） <a class="header-anchor" href="#问题2-爬楼梯-基础" aria-label="Permalink to &quot;问题2：爬楼梯（基础）&quot;">​</a></h3><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noreferrer">70. 爬楼梯</a></p><h4 id="问题描述-1" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-1" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 2</span></span>
<span class="line"><span>输出：2</span></span>
<span class="line"><span>解释：有两种方法可以爬到楼顶。</span></span>
<span class="line"><span>1. 1 阶 + 1 阶</span></span>
<span class="line"><span>2. 2 阶</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 3</span></span>
<span class="line"><span>输出：3</span></span>
<span class="line"><span>解释：有三种方法可以爬到楼顶。</span></span>
<span class="line"><span>1. 1 阶 + 1 阶 + 1 阶</span></span>
<span class="line"><span>2. 1 阶 + 2 阶</span></span>
<span class="line"><span>3. 2 阶 + 1 阶</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 4</span></span>
<span class="line"><span>输出：5</span></span>
<span class="line"><span>解释：有五种方法可以爬到楼顶。</span></span>
<span class="line"><span>1. 1 阶 + 1 阶 + 1 阶 + 1 阶</span></span>
<span class="line"><span>2. 1 阶 + 1 阶 + 2 阶</span></span>
<span class="line"><span>3. 1 阶 + 2 阶 + 1 阶</span></span>
<span class="line"><span>4. 2 阶 + 1 阶 + 1 阶</span></span>
<span class="line"><span>5. 2 阶 + 2 阶</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h4 id="dp五部曲分析-1" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-1" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i]</code> 表示爬到第i阶台阶的不同方法数；</p></li><li><p><strong>递推公式</strong>：<code>dp[i] = dp[i-1] + dp[i-2]</code>（到第i阶的方法=到i-1阶爬1步 + 到i-2阶爬2步）；</p></li><li><p><strong>初始化</strong>：<code>dp[1] = 1</code>（1阶只有1种方法），<code>dp[2] = 2</code>（2阶有2种方法）；</p></li><li><p><strong>遍历顺序</strong>：从左到右（i从3到n）；</p></li><li><p><strong>打印验证</strong>：遍历过程中打印<code>dp[i]</code>，验证方法数是否符合预期。</p></li></ol><h4 id="具体分析-1" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-1" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>要到达第 n 阶，最后一步可能是从第 n-1 阶爬 1 步，或者从第 n-2 阶爬 2 步。这两种情况是<strong>互斥且完备</strong>的（覆盖所有可能），所以到达第 n 阶的方法数 = 到达第 n-1 阶的方法数 + 到达第 n-2 阶的方法数。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>最后一步分析</strong>：</p><ul><li>如果最后一步是爬 1 阶，那么之前必须到达第 n-1 阶</li><li>如果最后一步是爬 2 阶，那么之前必须到达第 n-2 阶</li><li>这两种情况互不重叠，且覆盖所有可能</li></ul></li><li><p><strong>状态定义</strong>：<code>dp[i]</code> 表示到达第 i 阶的方法数。</p></li><li><p><strong>状态转移</strong>：<code>dp[i] = dp[i-1] + dp[i-2]</code></p><ul><li><code>dp[i-1]</code>：从第 i-1 阶爬 1 步到达第 i 阶的方法数</li><li><code>dp[i-2]</code>：从第 i-2 阶爬 2 步到达第 i 阶的方法数</li></ul></li><li><p><strong>边界条件</strong>：</p><ul><li><code>dp[1] = 1</code>：只有 1 种方法（直接爬 1 阶）</li><li><code>dp[2] = 2</code>：有 2 种方法（1+1 或 2）</li></ul></li></ol><p><strong>执行过程示例（n=5）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[1] = 1  (初始化：1阶只有1种方法)</span></span>
<span class="line"><span>dp[2] = 2  (初始化：2阶有2种方法：1+1 或 2)</span></span>
<span class="line"><span>dp[3] = dp[2] + dp[1] = 2 + 1 = 3  (从2阶爬1步 + 从1阶爬2步)</span></span>
<span class="line"><span>dp[4] = dp[3] + dp[2] = 3 + 2 = 5  (从3阶爬1步 + 从2阶爬2步)</span></span>
<span class="line"><span>dp[5] = dp[4] + dp[3] = 5 + 3 = 8  (从4阶爬1步 + 从3阶爬2步)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>注意</strong>：这个问题本质上就是斐波那契数列！<code>dp[1]=1, dp[2]=2, dp[3]=3, dp[4]=5, dp[5]=8...</code></p><h4 id="实现代码-空间优化版" tabindex="-1">实现代码（空间优化版） <a class="header-anchor" href="#实现代码-空间优化版" aria-label="Permalink to &quot;实现代码（空间优化版）&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> climbStairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dp[i-2]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dp[i-1]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`爬到第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}阶的方法数：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cur</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="问题3-最小花费爬楼梯-进阶" tabindex="-1">问题3：最小花费爬楼梯（进阶） <a class="header-anchor" href="#问题3-最小花费爬楼梯-进阶" aria-label="Permalink to &quot;问题3：最小花费爬楼梯（进阶）&quot;">​</a></h3><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noreferrer">746. 使用最小花费爬楼梯</a></p><h4 id="问题描述-2" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-2" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>给你一个整数数组 <code>cost</code>，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：cost = [10,15,20]</span></span>
<span class="line"><span>输出：15</span></span>
<span class="line"><span>解释：你将从下标为 1 的台阶开始。</span></span>
<span class="line"><span>- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span></span>
<span class="line"><span>总花费为 15 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：cost = [1,100,1,1,1,100,1,1,100,1]</span></span>
<span class="line"><span>输出：6</span></span>
<span class="line"><span>解释：你将从下标为 0 的台阶开始。</span></span>
<span class="line"><span>- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span></span>
<span class="line"><span>- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span></span>
<span class="line"><span>- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span></span>
<span class="line"><span>- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span></span>
<span class="line"><span>- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span></span>
<span class="line"><span>- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span></span>
<span class="line"><span>总花费为 6 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><h4 id="dp五部曲分析-2" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-2" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i]</code> 表示到达第i阶顶部的最低花费（i为顶部下标，对应超出最后一个台阶的位置）；</p></li><li><p><strong>递推公式</strong>：<code>dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])</code>（从i-2阶爬2步 或 从i-1阶爬1步，取最小值）；</p></li><li><p><strong>初始化</strong>：<code>dp[0] = 0</code>（初始位置，无花费），<code>dp[1] = 0</code>（站在1阶台阶免费）；</p></li><li><p><strong>遍历顺序</strong>：从左到右（i从2到n，n为<code>cost</code>长度）；</p></li><li><p><strong>打印验证</strong>：遍历过程中打印<code>dp[i]</code>，验证最低花费是否正确。</p></li></ol><h4 id="具体分析-2" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-2" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>要到达第 i 阶顶部，最后一步可能是从第 i-2 阶爬 2 步（花费 cost[i-2]），或者从第 i-1 阶爬 1 步（花费 cost[i-1]）。我们需要选择<strong>花费更少</strong>的那条路径。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>最后一步分析</strong>：</p><ul><li>如果最后一步是从第 i-2 阶爬 2 步，总花费 = 到达第 i-2 阶的花费 + cost[i-2]</li><li>如果最后一步是从第 i-1 阶爬 1 步，总花费 = 到达第 i-1 阶的花费 + cost[i-1]</li><li>取两者的最小值</li></ul></li><li><p><strong>状态定义</strong>：<code>dp[i]</code> 表示到达第 i 阶顶部的最低花费。</p><ul><li><strong>注意</strong>：i 是&quot;顶部&quot;的下标，如果 cost 数组长度为 n，那么顶部是第 n 阶（下标 n）</li></ul></li><li><p><strong>状态转移</strong>：<code>dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])</code></p><ul><li><code>dp[i-2] + cost[i-2]</code>：从第 i-2 阶爬 2 步到顶部</li><li><code>dp[i-1] + cost[i-1]</code>：从第 i-1 阶爬 1 步到顶部</li></ul></li><li><p><strong>边界条件</strong>：</p><ul><li><code>dp[0] = 0</code>：站在第 0 阶（起始位置），免费</li><li><code>dp[1] = 0</code>：站在第 1 阶，免费（题目说可以从下标 0 或 1 开始）</li></ul></li></ol><p><strong>执行过程示例（cost = [10, 15, 20]）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cost = [10, 15, 20]，长度为 3，顶部是第 3 阶</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[0] = 0  (初始化：站在0阶免费)</span></span>
<span class="line"><span>dp[1] = 0  (初始化：站在1阶免费)</span></span>
<span class="line"><span>dp[2] = min(dp[0] + cost[0], dp[1] + cost[1])</span></span>
<span class="line"><span>      = min(0 + 10, 0 + 15) = min(10, 15) = 10</span></span>
<span class="line"><span>      (从0阶爬2步花费10，从1阶爬1步花费15，选10)</span></span>
<span class="line"><span>dp[3] = min(dp[1] + cost[1], dp[2] + cost[2])</span></span>
<span class="line"><span>      = min(0 + 15, 10 + 20) = min(15, 30) = 15</span></span>
<span class="line"><span>      (从1阶爬2步花费15，从2阶爬1步花费30，选15)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="实现代码" tabindex="-1">实现代码 <a class="header-anchor" href="#实现代码" aria-label="Permalink to &quot;实现代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> minCost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 边界：只有1阶台阶，必须支付cost[0]才能到顶部</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2阶台阶：取从0阶或1阶爬的最小花费</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], cost[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 到达i-2阶的花费</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 到达i-1阶的花费</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prevPrev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`到达第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}阶顶部的最低花费：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cur</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="问题4-机器人走网格-基础→进阶-含障碍物" tabindex="-1">问题4：机器人走网格（基础→进阶：含障碍物） <a class="header-anchor" href="#问题4-机器人走网格-基础→进阶-含障碍物" aria-label="Permalink to &quot;问题4：机器人走网格（基础→进阶：含障碍物）&quot;">​</a></h3><h4 id="子问题4-1-无障碍物的不同路径" tabindex="-1">子问题4.1：无障碍物的不同路径 <a class="header-anchor" href="#子问题4-1-无障碍物的不同路径" aria-label="Permalink to &quot;子问题4.1：无障碍物的不同路径&quot;">​</a></h4><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noreferrer">62. 不同路径</a></p><h5 id="问题描述-3" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-3" aria-label="Permalink to &quot;问题描述&quot;">​</a></h5><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 &quot;Start&quot;）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &quot;Finish&quot;）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：m = 3, n = 7</span></span>
<span class="line"><span>输出：28</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：m = 3, n = 2</span></span>
<span class="line"><span>输出：3</span></span>
<span class="line"><span>解释：</span></span>
<span class="line"><span>从左上角开始，总共有 3 条路径可以到达右下角。</span></span>
<span class="line"><span>1. 向右 -&gt; 向下 -&gt; 向下</span></span>
<span class="line"><span>2. 向下 -&gt; 向下 -&gt; 向右</span></span>
<span class="line"><span>3. 向下 -&gt; 向右 -&gt; 向下</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：m = 7, n = 3</span></span>
<span class="line"><span>输出：28</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>示例 4：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：m = 3, n = 3</span></span>
<span class="line"><span>输出：6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 10^9</code></li></ul><h5 id="dp五部曲分析-3" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-3" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h5><ol><li><p><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示从左上角到(i,j)的不同路径数（二维）；优化后一维<code>dp[x]</code>表示当前行第x列的路径数；</p></li><li><p><strong>递推公式</strong>：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>（一维优化：<code>dp[x] = dp[x] + dp[x-1]</code>）；</p></li><li><p><strong>初始化</strong>：第一行/第一列路径数为1（只能沿一个方向走）；</p></li><li><p><strong>遍历顺序</strong>：从上到下、从左到右；</p></li><li><p><strong>打印验证</strong>：打印每行dp数组，验证路径数是否正确。</p></li></ol><h5 id="具体分析-3" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-3" aria-label="Permalink to &quot;具体分析&quot;">​</a></h5><p><strong>为什么用动态规划？</strong></p><p>要到达位置 (i, j)，最后一步可能是从上方 (i-1, j) 向下移动，或者从左方 (i, j-1) 向右移动。这两种情况互斥且完备，所以到达 (i, j) 的路径数 = 到达 (i-1, j) 的路径数 + 到达 (i, j-1) 的路径数。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>最后一步分析</strong>：</p><ul><li>如果最后一步是向下，那么之前必须在 (i-1, j)</li><li>如果最后一步是向右，那么之前必须在 (i, j-1)</li><li>这两种情况互不重叠，且覆盖所有可能</li></ul></li><li><p><strong>状态定义</strong>：<code>dp[i][j]</code> 表示从 (0, 0) 到达 (i, j) 的不同路径数。</p></li><li><p><strong>状态转移</strong>：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><ul><li><code>dp[i-1][j]</code>：从上方到达的路径数</li><li><code>dp[i][j-1]</code>：从左方到达的路径数</li></ul></li><li><p><strong>边界条件</strong>：</p><ul><li>第一行 <code>dp[0][j] = 1</code>：只能一直向右走</li><li>第一列 <code>dp[i][0] = 1</code>：只能一直向下走</li></ul></li></ol><p><strong>执行过程示例（m=3, n=3，二维DP）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始化二维dp数组（3行3列）：</span></span>
<span class="line"><span>| i\j | 0 | 1 | 2 |</span></span>
<span class="line"><span>| --- |---|---|---|</span></span>
<span class="line"><span>| 0   | 1 | 1 | 1 |  (第一行：只能向右)</span></span>
<span class="line"><span>| 1   | 1 | ? | ? |</span></span>
<span class="line"><span>| 2   | 1 | ? | ? |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>计算第1行（i=1）：</span></span>
<span class="line"><span>dp[1][0] = 1  (第一列：只能向下)</span></span>
<span class="line"><span>dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2  (从上方1 + 从左方1)</span></span>
<span class="line"><span>dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3  (从上方1 + 从左方2)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>计算第2行（i=2）：</span></span>
<span class="line"><span>dp[2][0] = 1  (第一列：只能向下)</span></span>
<span class="line"><span>dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3  (从上方2 + 从左方1)</span></span>
<span class="line"><span>dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6  (从上方3 + 从左方3)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终答案：dp[2][2] = 6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="版本1-二维数组版-直观-空间o-m×n" tabindex="-1">版本1：二维数组版（直观，空间O(m×n)） <a class="header-anchor" href="#版本1-二维数组版-直观-空间o-m×n" aria-label="Permalink to &quot;版本1：二维数组版（直观，空间O(m×n)）&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uniquePaths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[i][j]：从 (0, 0) 到达 (i, j) 的不同路径数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 初始化第一行：只能向右走，路径数都是1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 初始化第一列：只能向下走，路径数都是1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[i][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 填充剩余位置</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 从上方到达 + 从左方到达</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp[i][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i][j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`dp[${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}][${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}] = ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">][</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>空间优化思路</strong>：</p><p>观察二维DP代码，我们发现一个关键点：计算 <code>dp[i][j]</code> 时，<strong>只需要用到 <code>dp[i-1][j]</code>（上一行同列）和 <code>dp[i][j-1]</code>（当前行前一列）</strong>。</p><p><strong>优化过程</strong>：</p><ol><li><p><strong>发现问题</strong>：二维数组需要存储 m×n 个值，空间复杂度 O(m×n)，但实际上我们只需要保存当前行的数据。</p></li><li><p><strong>分析依赖关系</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><code>dp[i-1][j]</code>：来自上一行的同列（需要保存上一行）</li><li><code>dp[i][j-1]</code>：来自当前行的前一列（正在计算中）</li></ul></li><li><p><strong>优化方案</strong>：</p><ul><li>用一维数组 <code>dp[j]</code> 表示当前行第 j 列的路径数</li><li>在计算当前行时，<code>dp[j]</code> 本身就保存了上一行的值（<code>dp[i-1][j]</code>）</li><li>更新 <code>dp[j]</code> 时：<code>dp[j] = dp[j] + dp[j-1]</code><ul><li><code>dp[j]</code>（更新前）= 上一行同列的值（<code>dp[i-1][j]</code>）</li><li><code>dp[j-1]</code> = 当前行前一列的值（<code>dp[i][j-1]</code>，已计算）</li><li><code>dp[j]</code>（更新后）= 当前行当前列的值（<code>dp[i][j]</code>）</li></ul></li></ul></li><li><p><strong>关键理解</strong>：</p><ul><li><strong>正序遍历列</strong>：从左到右计算，保证 <code>dp[j-1]</code> 是当前行已计算的值</li><li><strong>复用数组</strong>：<code>dp[j]</code> 在更新前保存上一行的值，更新后保存当前行的值</li><li><strong>初始化</strong>：第一行初始化为全1（只能向右走）</li></ul></li></ol><p><strong>优化效果</strong>：</p><ul><li><strong>空间复杂度</strong>：从 O(m×n) 降低到 O(n)</li><li><strong>时间复杂度</strong>：保持 O(m×n) 不变</li><li><strong>代码简洁性</strong>：减少一维，代码更简洁</li></ul><h5 id="版本2-一维数组优化版-空间o-n" tabindex="-1">版本2：一维数组优化版（空间O(n)） <a class="header-anchor" href="#版本2-一维数组优化版-空间o-n" aria-label="Permalink to &quot;版本2：一维数组优化版（空间O(n)）&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uniquePaths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[j]：当前行第 j 列的路径数（初始为第一行）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始化第一行：只能向右，路径数都是1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 从第2行开始计算（i=1，因为第一行已初始化）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 从第2列开始计算（j=1，因为第一列始终为1）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // dp[j]（更新前）= 上一行同列的值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // dp[j-1] = 当前行前一列的值（已计算）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // dp[j]（更新后）= 当前行当前列的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}行第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}列路径数：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>一维优化版执行过程（m=3, n=3）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始状态（第一行）：</span></span>
<span class="line"><span>dp = [1, 1, 1]  (第一行只能向右，路径数都是1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第2行（i=1）：</span></span>
<span class="line"><span>j=1: dp[1] = dp[1] + dp[0] = 1 + 1 = 2  (上一行同列1 + 当前行前一列1)</span></span>
<span class="line"><span>j=2: dp[2] = dp[2] + dp[1] = 1 + 2 = 3  (上一行同列1 + 当前行前一列2)</span></span>
<span class="line"><span>dp = [1, 2, 3]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第3行（i=2）：</span></span>
<span class="line"><span>j=1: dp[1] = dp[1] + dp[0] = 2 + 1 = 3  (上一行同列2 + 当前行前一列1)</span></span>
<span class="line"><span>j=2: dp[2] = dp[2] + dp[1] = 3 + 3 = 6  (上一行同列3 + 当前行前一列3)</span></span>
<span class="line"><span>dp = [1, 3, 6]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终答案：dp[2] = 6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ways</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">countX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">countY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(countX).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始化第一行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> countY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> countX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行同列 + 当前行前一列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}行第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}列路径数：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[countX </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="子问题4-2-有障碍物的不同路径" tabindex="-1">子问题4.2：有障碍物的不同路径 <a class="header-anchor" href="#子问题4-2-有障碍物的不同路径" aria-label="Permalink to &quot;子问题4.2：有障碍物的不同路径&quot;">​</a></h4><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noreferrer">63. 不同路径 II</a></p><h5 id="问题描述-4" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-4" aria-label="Permalink to &quot;问题描述&quot;">​</a></h5><p>一个机器人位于一个 <code>m x n</code> 网格的左上角（起始点在下图中标记为 &quot;Start&quot;）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &quot;Finish&quot;）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span></span>
<span class="line"><span>输出：2</span></span>
<span class="line"><span>解释：3x3 网格的正中间有一个障碍物。</span></span>
<span class="line"><span>从左上角到右下角一共有 2 条不同的路径：</span></span>
<span class="line"><span>1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span></span>
<span class="line"><span>2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：obstacleGrid = [[0,1],[0,0]]</span></span>
<span class="line"><span>输出：1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h5 id="dp五部曲分析-核心差异" tabindex="-1">DP五部曲分析（核心差异） <a class="header-anchor" href="#dp五部曲分析-核心差异" aria-label="Permalink to &quot;DP五部曲分析（核心差异）&quot;">​</a></h5><ol><li><p><strong>dp数组含义</strong>：同无障碍物版本，但障碍物位置<code>dp[x] = 0</code>；</p></li><li><p><strong>递推公式</strong>：无障碍物时同原公式，有障碍物则置0；</p></li><li><p><strong>初始化</strong>：第一行遇到障碍物后，后续位置全部置0（无法绕开）；</p></li><li><p><strong>遍历顺序</strong>：同上，但需先处理每一行的第一列（障碍物置0）；</p></li><li><p><strong>打印验证</strong>：打印每行dp数组，验证障碍物位置路径数是否为0。</p></li></ol><h5 id="具体分析-4" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-4" aria-label="Permalink to &quot;具体分析&quot;">​</a></h5><p><strong>为什么用动态规划？</strong></p><p>思路与无障碍物版本相同，但需要特殊处理障碍物：障碍物位置无法到达，路径数为 0。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>障碍物的影响</strong>：</p><ul><li>如果 (i, j) 是障碍物，则 <code>dp[i][j] = 0</code>（无法到达）</li><li>如果 (i, j) 不是障碍物，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></li></ul></li><li><p><strong>初始化特殊处理</strong>：</p><ul><li>第一行：遇到障碍物后，后续所有位置路径数都是 0（无法绕开）</li><li>第一列：每行都要检查第一列是否有障碍物</li></ul></li><li><p><strong>状态转移</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (gridArr[y][x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 障碍物，无法到达</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正常路径计算</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol><p><strong>执行过程示例（gridArr = [[0,0,0],[0,1,0],[0,0,0]]）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始状态（第一行）：</span></span>
<span class="line"><span>dp = [1, 1, 1]  (无障碍物，正常初始化)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第2行（y=1）：</span></span>
<span class="line"><span>- gridArr[1][0] = 0，无障碍物，dp[0] = 1（保持）</span></span>
<span class="line"><span>- gridArr[1][1] = 1，有障碍物！dp[1] = 0</span></span>
<span class="line"><span>- gridArr[1][2] = 0，无障碍物，dp[2] = dp[2] + dp[1] = 1 + 0 = 1</span></span>
<span class="line"><span>dp = [1, 0, 1]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第3行（y=2）：</span></span>
<span class="line"><span>- gridArr[2][0] = 0，无障碍物，dp[0] = 1（保持）</span></span>
<span class="line"><span>- gridArr[2][1] = 0，无障碍物，dp[1] = dp[1] + dp[0] = 0 + 1 = 1</span></span>
<span class="line"><span>- gridArr[2][2] = 0，无障碍物，dp[2] = dp[2] + dp[1] = 1 + 1 = 2</span></span>
<span class="line"><span>dp = [1, 1, 2]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终答案：dp[2] = 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>关键点</strong>：障碍物会&quot;阻断&quot;路径，导致后续位置无法通过该位置到达。</p><h5 id="实现代码-1" tabindex="-1">实现代码 <a class="header-anchor" href="#实现代码-1" aria-label="Permalink to &quot;实现代码&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getWays</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">gridArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gridArr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 行数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gridArr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 列数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 初始化第一行：遇到障碍物则后续全为0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (gridArr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 遍历剩余行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m; y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理当前行第一列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (gridArr[y][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理剩余列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (gridArr[y][x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`第${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}行dp数组：${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="问题5-整数拆分-进阶" tabindex="-1">问题5：整数拆分（进阶） <a class="header-anchor" href="#问题5-整数拆分-进阶" aria-label="Permalink to &quot;问题5：整数拆分（进阶）&quot;">​</a></h3><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noreferrer">343. 整数拆分</a></p><h4 id="问题描述-5" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-5" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>给定一个正整数 <code>n</code>，将其拆分为<strong>至少两个正整数的和</strong>，并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入: n = 2</span></span>
<span class="line"><span>输出: 1</span></span>
<span class="line"><span>解释: 2 = 1 + 1, 1 × 1 = 1。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入: n = 10</span></span>
<span class="line"><span>输出: 36</span></span>
<span class="line"><span>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入: n = 8</span></span>
<span class="line"><span>输出: 18</span></span>
<span class="line"><span>解释: 8 = 2 + 3 + 3, 2 × 3 × 3 = 18。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 4：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入: n = 7</span></span>
<span class="line"><span>输出: 12</span></span>
<span class="line"><span>解释: 7 = 3 + 4, 3 × 4 = 12。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><h4 id="dp五部曲分析-4" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-4" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i]</code> 表示将正整数i拆分为至少两个数的和，能得到的最大乘积；</p></li><li><p><strong>递推公式</strong>：<code>dp[i] = max(当前最大值, j*(i-j), j*dp[i-j])</code>（j从1到i-1，拆分为j和i-j，i-j可拆或不拆）；</p></li><li><p><strong>初始化</strong>：<code>dp[2] = 1</code>（2只能拆1+1，乘积1）；</p></li><li><p><strong>遍历顺序</strong>：从左到右（i从3到n）；</p></li><li><p><strong>打印验证</strong>：打印每个<code>dp[i]</code>，验证是否符合预期（如dp[10]=36）。</p></li></ol><h4 id="具体分析-5" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-5" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>要拆分 n，可以先将 n 拆成 j 和 (n-j)，然后 (n-j) 可以继续拆分，也可以不拆分。我们需要找到所有拆分方式中乘积最大的。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>拆分策略</strong>：</p><ul><li>将 n 拆成 j 和 (n-j) 两部分（j 从 1 到 n-1）</li><li>对于 (n-j)，有两种选择： <ul><li><strong>不继续拆分</strong>：乘积 = j × (n-j)</li><li><strong>继续拆分</strong>：乘积 = j × dp[n-j]（dp[n-j] 是 n-j 拆分后的最大乘积）</li></ul></li></ul></li><li><p><strong>状态定义</strong>：<code>dp[i]</code> 表示将 i 拆分为至少两个正整数的和，能得到的最大乘积。</p></li><li><p><strong>状态转移</strong>：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  curMax </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curMax, j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j), j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><code>j * (i - j)</code>：只拆成两部分，不继续拆分</li><li><code>j * dp[i - j]</code>：j 不拆分，i-j 继续拆分</li></ul></li><li><p><strong>为什么 j 不拆分？</strong></p><ul><li>实际上，j 也可以拆分，但如果我们遍历所有 j，j 的拆分情况会在计算 <code>dp[j]</code> 时已经考虑过了</li><li>例如：计算 dp[5] 时，j=2 的情况会在计算 dp[3] 时考虑（3=2+1，2 可以拆分）</li></ul></li><li><p><strong>边界条件</strong>：<code>dp[2] = 1</code>（2 只能拆成 1+1）</p></li></ol><p><strong>执行过程示例（n=10）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[2] = 1  (初始化：2 = 1+1，乘积1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[3]：</span></span>
<span class="line"><span>  j=1: max(1*2, 1*dp[2]) = max(2, 1) = 2</span></span>
<span class="line"><span>  dp[3] = 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[4]：</span></span>
<span class="line"><span>  j=1: max(1*3, 1*dp[3]) = max(3, 2) = 3</span></span>
<span class="line"><span>  j=2: max(2*2, 2*dp[2]) = max(4, 2) = 4</span></span>
<span class="line"><span>  dp[4] = 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[5]：</span></span>
<span class="line"><span>  j=1: max(1*4, 1*dp[4]) = max(4, 4) = 4</span></span>
<span class="line"><span>  j=2: max(2*3, 2*dp[3]) = max(6, 4) = 6</span></span>
<span class="line"><span>  j=3: max(3*2, 3*dp[2]) = max(6, 3) = 6</span></span>
<span class="line"><span>  j=4: max(4*1, 4*dp[1]) = 4  (dp[1]无意义，不考虑)</span></span>
<span class="line"><span>  dp[5] = 6</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...继续计算到 dp[10] = 36</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>关键洞察</strong>：对于每个拆分 j 和 (i-j)，我们只需要考虑 (i-j) 是否继续拆分，因为 j 的所有拆分情况在之前计算 <code>dp[j]</code> 时已经考虑过了。</p><h4 id="实现代码-2" tabindex="-1">实现代码 <a class="header-anchor" href="#实现代码-2" aria-label="Permalink to &quot;实现代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> integerBreak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始化边界</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; curN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; curN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curMax </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curN; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      curMax </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curMax, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[j]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[curN] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curMax;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`dp[${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">curN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}] = ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">curN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="问题6-不同的二叉搜索树-进阶" tabindex="-1">问题6：不同的二叉搜索树（进阶） <a class="header-anchor" href="#问题6-不同的二叉搜索树-进阶" aria-label="Permalink to &quot;问题6：不同的二叉搜索树（进阶）&quot;">​</a></h3><p><strong>LeetCode 链接</strong>：<a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noreferrer">96. 不同的二叉搜索树</a></p><h4 id="问题描述-6" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-6" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>给你一个整数 <code>n</code>，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的<strong>二叉搜索树</strong>有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>二叉搜索树（BST）的核心规则：</strong></p><p>对任意节点，满足：</p><ul><li>左子树的所有节点值 &lt; 该节点值；</li><li>右子树的所有节点值 &gt; 该节点值；</li><li>左右子树也必须是BST。</li></ul><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 3</span></span>
<span class="line"><span>输出：5</span></span>
<span class="line"><span>解释：给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   1         3     3      2      1</span></span>
<span class="line"><span>    \       /     /      / \      \</span></span>
<span class="line"><span>     3     2     1      1   3      2</span></span>
<span class="line"><span>    /     /       \                 \</span></span>
<span class="line"><span>   2     1         2                 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：n = 1</span></span>
<span class="line"><span>输出：1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h4 id="dp五部曲分析-5" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-5" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i]</code> 表示由 i 个节点组成的二叉搜索树的不同形态数量；</p></li><li><p><strong>递推公式</strong>：<code>dp[i] = Σ(dp[j-1] × dp[i-j])</code>（j 从 1 到 i，j 作为根节点，左子树 j-1 个节点，右子树 i-j 个节点）；</p></li><li><p><strong>初始化</strong>：<code>dp[0] = 1</code>（空树算1种形态），<code>dp[1] = 1</code>（1个节点只有1种形态）；</p></li><li><p><strong>遍历顺序</strong>：从左到右（i 从 2 到 n），内层循环枚举根节点位置 j（从 1 到 i）；</p></li><li><p><strong>打印验证</strong>：打印每个 <code>dp[i]</code>，验证是否符合卡特兰数规律（如 dp[3]=5，dp[4]=14）。</p></li></ol><h4 id="具体分析-6" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-6" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>要构造 n 个节点的 BST，我们需要选择一个节点作为根，然后将剩余的节点分配到左子树和右子树。由于 BST 的性质，一旦根节点确定，左右子树的节点集合也就确定了（比根小的在左，比根大的在右）。这是一个典型的<strong>重叠子问题</strong>：不同根节点选择下，左右子树的构造问题会重复出现。</p><p><strong>思路推导：</strong></p><ol><li><p><strong>根节点选择策略</strong>：</p><ul><li>对于 n 个节点（值为 1 到 n），我们可以选择任意一个节点 i（1 ≤ i ≤ n）作为根</li><li>选择 i 作为根后： <ul><li>左子树必须包含所有小于 i 的节点（1 到 i-1），共 i-1 个节点</li><li>右子树必须包含所有大于 i 的节点（i+1 到 n），共 n-i 个节点</li></ul></li></ul></li><li><p><strong>状态定义</strong>：<code>dp[i]</code> 表示由 i 个节点组成的 BST 的不同形态数量。</p></li><li><p><strong>状态转移</strong>：</p><ul><li>对于 n 个节点，枚举根节点 j（1 ≤ j ≤ n）</li><li>以 j 为根的 BST 数量 = 左子树形态数 × 右子树形态数 = <code>dp[j-1] × dp[n-j]</code></li><li>总数量 = 所有根节点对应的方案数之和：<code>dp[n] = Σ(dp[j-1] × dp[n-j])</code>（j 从 1 到 n）</li></ul></li><li><p><strong>为什么 dp[0] = 1？</strong></p><ul><li>空树也是一种合法的 BST 形态</li><li>当根节点的左子树或右子树为空时，需要用到 <code>dp[0]</code></li><li>例如：n=1 时，选 1 当根，左右子树都是空树，方案数 = <code>dp[0] × dp[0] = 1 × 1 = 1</code></li></ul></li><li><p><strong>卡特兰数关系</strong>：</p><ul><li>这个问题的结果恰好是第 n 个卡特兰数</li><li>卡特兰数的递推公式：<code>C(n) = Σ(C(i-1) × C(n-i))</code>（i 从 1 到 n）</li><li>这与我们的 DP 递推公式完全一致</li></ul></li></ol><p><strong>执行过程示例（n=4）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dp[0] = 1  (初始化：空树算1种)</span></span>
<span class="line"><span>dp[1] = 1  (初始化：1个节点只有1种形态)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[2]：</span></span>
<span class="line"><span>  j=1: dp[0] × dp[1] = 1 × 1 = 1  (1为根，左空右1个节点)</span></span>
<span class="line"><span>  j=2: dp[1] × dp[0] = 1 × 1 = 1  (2为根，左1个节点右空)</span></span>
<span class="line"><span>  dp[2] = 1 + 1 = 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[3]：</span></span>
<span class="line"><span>  j=1: dp[0] × dp[2] = 1 × 2 = 2  (1为根，左空右2个节点)</span></span>
<span class="line"><span>  j=2: dp[1] × dp[1] = 1 × 1 = 1  (2为根，左1个节点右1个节点)</span></span>
<span class="line"><span>  j=3: dp[2] × dp[0] = 2 × 1 = 2  (3为根，左2个节点右空)</span></span>
<span class="line"><span>  dp[3] = 2 + 1 + 2 = 5</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dp[4]：</span></span>
<span class="line"><span>  j=1: dp[0] × dp[3] = 1 × 5 = 5</span></span>
<span class="line"><span>  j=2: dp[1] × dp[2] = 1 × 2 = 2</span></span>
<span class="line"><span>  j=3: dp[2] × dp[1] = 2 × 1 = 2</span></span>
<span class="line"><span>  j=4: dp[3] × dp[0] = 5 × 1 = 5</span></span>
<span class="line"><span>  dp[4] = 5 + 2 + 2 + 5 = 14</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>关键洞察</strong>：</p><ul><li>BST 的性质决定了&quot;根节点选择&quot;后，左右子树的节点集合是<strong>唯一确定</strong>的</li><li>不同根节点对应的左右子树大小不同，但构造方式相同（都是 BST 构造问题）</li><li>这形成了重叠子问题，适合用动态规划解决</li></ul><h4 id="实现代码-3" tabindex="-1">实现代码 <a class="header-anchor" href="#实现代码-3" aria-label="Permalink to &quot;实现代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> numTrees</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[i]：由 i 个节点组成的二叉搜索树的不同形态数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 初始化：空树算1种，1个节点算1种</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dp[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 遍历计算 2~n 个节点的 BST 数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 枚举所有可能的根节点位置 j</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> leftCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 左子树节点数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rightCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 右子树节点数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[leftCount] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[rightCount];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dp[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`dp[${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}] = ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印验证</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>复杂度分析</strong>：</p><ul><li><strong>时间复杂度</strong>：O(n²)，外层循环 n 次，内层循环最多 n 次</li><li><strong>空间复杂度</strong>：O(n)，dp 数组存储 n+1 个值</li></ul><h3 id="问题7-01背包问题-经典" tabindex="-1">问题7：01背包问题（经典） <a class="header-anchor" href="#问题7-01背包问题-经典" aria-label="Permalink to &quot;问题7：01背包问题（经典）&quot;">​</a></h3><p><strong>LeetCode 相关题目</strong>：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noreferrer">416. 分割等和子集</a>（01背包变种）</p><h4 id="问题描述-7" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述-7" aria-label="Permalink to &quot;问题描述&quot;">​</a></h4><p>有 <code>n</code> 件物品和一个最多能背重量为 <code>w</code> 的背包。第 <code>i</code> 件物品的重量是 <code>weight[i]</code>，得到的价值是 <code>value[i]</code>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>01背包的核心特点</strong>：</p><ul><li><strong>0</strong>：不选当前物品</li><li><strong>1</strong>：选当前物品（只能用一次）</li><li>每个物品只有&quot;选&quot;或&quot;不选&quot;两种状态</li></ul><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：</span></span>
<span class="line"><span>n = 2（物品数量）</span></span>
<span class="line"><span>w = 5（背包容量）</span></span>
<span class="line"><span>weight = [2, 3]（物品重量）</span></span>
<span class="line"><span>value = [3, 4]（物品价值）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输出：7</span></span>
<span class="line"><span>解释：选择物品1（重量2，价值3）和物品2（重量3，价值4），总重量5，总价值7。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：</span></span>
<span class="line"><span>n = 3</span></span>
<span class="line"><span>w = 4</span></span>
<span class="line"><span>weight = [1, 3, 4]</span></span>
<span class="line"><span>value = [15, 20, 30]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输出：35</span></span>
<span class="line"><span>解释：选择物品1（重量1，价值15）和物品2（重量3，价值20），总重量4，总价值35。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= w &lt;= 1000</code></li><li><code>1 &lt;= weight[i] &lt;= w</code></li><li><code>0 &lt;= value[i] &lt;= 1000</code></li></ul><h4 id="dp五部曲分析-6" tabindex="-1">DP五部曲分析 <a class="header-anchor" href="#dp五部曲分析-6" aria-label="Permalink to &quot;DP五部曲分析&quot;">​</a></h4><ol><li><p><strong>dp数组含义</strong>：<code>dp[i][j]</code> 表示从前 <code>i</code> 件物品中选择，在容量为 <code>j</code> 的背包中能获得的最大价值；</p></li><li><p><strong>递推公式</strong>：</p><ul><li>不选第 i 件物品：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行的结果）</li><li>选第 i 件物品：<code>dp[i][j] = dp[i-1][j-weight[i-1]] + value[i-1]</code>（需要容量足够）</li><li>取最大值：<code>dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1])</code></li></ul></li><li><p><strong>初始化</strong>：</p><ul><li><code>dp[0][j] = 0</code>（0件物品，任何容量的价值都是0）</li><li><code>dp[i][0] = 0</code>（容量为0，任何物品都无法装入）</li></ul></li><li><p><strong>遍历顺序</strong>：外层遍历物品（i 从 1 到 n），内层遍历容量（j 从 1 到 w）；</p></li><li><p><strong>打印验证</strong>：打印 dp 数组，验证每一步的计算是否正确（特别是边界情况和最大值的选择）。</p></li></ol><h4 id="具体分析-7" tabindex="-1">具体分析 <a class="header-anchor" href="#具体分析-7" aria-label="Permalink to &quot;具体分析&quot;">​</a></h4><p><strong>为什么用动态规划？</strong></p><p>01背包问题具有<strong>重叠子问题</strong>和<strong>最优子结构</strong>的特征：</p><ul><li><strong>重叠子问题</strong>：计算 <code>dp[i][j]</code> 时，需要用到 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-weight[i-1]]</code>，这些子问题会被重复计算</li><li><strong>最优子结构</strong>：前 i 件物品在容量 j 下的最优解，包含了前 i-1 件物品在更小容量下的最优解</li></ul><p><strong>思路推导：</strong></p><ol><li><p><strong>状态定义</strong>：</p><ul><li><code>dp[i][j]</code> 表示从前 i 件物品中选择，在容量为 j 的背包中能获得的最大价值</li><li>这是一个<strong>二维DP</strong>问题，因为需要考虑两个维度：物品数量和背包容量</li></ul></li><li><p><strong>状态转移的核心思想</strong>：</p><ul><li>对于第 i 件物品，我们有两种选择： <ul><li><strong>不选</strong>：<code>dp[i][j] = dp[i-1][j]</code>（容量不变，价值不变）</li><li><strong>选</strong>：<code>dp[i][j] = dp[i-1][j-weight[i-1]] + value[i-1]</code>（需要先腾出 weight[i-1] 的容量，然后加上当前物品的价值）</li></ul></li><li>取两者的最大值</li></ul></li><li><p><strong>为什么是 <code>dp[i-1][j-weight[i-1]]</code>？</strong></p><ul><li>因为每个物品只能用一次，所以选择第 i 件物品时，必须基于&quot;前 i-1 件物品&quot;的状态</li><li><code>j-weight[i-1]</code> 表示选择当前物品后，剩余的容量</li><li><code>dp[i-1][j-weight[i-1]]</code> 表示在剩余容量下，前 i-1 件物品能获得的最大价值</li></ul></li><li><p><strong>边界条件处理</strong>：</p><ul><li>当 <code>j &lt; weight[i-1]</code> 时，当前物品装不下，只能不选：<code>dp[i][j] = dp[i-1][j]</code></li></ul></li></ol><p><strong>执行过程示例（n=2, w=5, weight=[2,3], value=[3,4]）：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始化 dp 数组（3行6列，全0）：</span></span>
<span class="line"><span>| i\j | 0 | 1 | 2 | 3 | 4 | 5 |</span></span>
<span class="line"><span>| --- |---|---|---|---|---|---|</span></span>
<span class="line"><span>| 0   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span>| 1   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span>| 2   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>计算 i=1（考虑物品1，重量2，价值3）：</span></span>
<span class="line"><span>j=1: 容量1 &lt; 重量2，装不下 → dp[1][1] = dp[0][1] = 0</span></span>
<span class="line"><span>j=2: 容量2 ≥ 重量2，可以装</span></span>
<span class="line"><span>     - 不选：dp[0][2] = 0</span></span>
<span class="line"><span>     - 选：dp[0][2-2] + 3 = dp[0][0] + 3 = 0 + 3 = 3</span></span>
<span class="line"><span>     - 取max：dp[1][2] = 3</span></span>
<span class="line"><span>j=3: 容量3 ≥ 重量2，可以装</span></span>
<span class="line"><span>     - 不选：dp[0][3] = 0</span></span>
<span class="line"><span>     - 选：dp[0][3-2] + 3 = dp[0][1] + 3 = 0 + 3 = 3</span></span>
<span class="line"><span>     - 取max：dp[1][3] = 3</span></span>
<span class="line"><span>j=4: 同理，dp[1][4] = 3</span></span>
<span class="line"><span>j=5: 同理，dp[1][5] = 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>此时 dp 数组：</span></span>
<span class="line"><span>| i\j | 0 | 1 | 2 | 3 | 4 | 5 |</span></span>
<span class="line"><span>| --- |---|---|---|---|---|---|</span></span>
<span class="line"><span>| 0   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span>| 1   | 0 | 0 | 3 | 3 | 3 | 3 |</span></span>
<span class="line"><span>| 2   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>计算 i=2（考虑物品2，重量3，价值4）：</span></span>
<span class="line"><span>j=1: 容量1 &lt; 重量3，装不下 → dp[2][1] = dp[1][1] = 0</span></span>
<span class="line"><span>j=2: 容量2 &lt; 重量3，装不下 → dp[2][2] = dp[1][2] = 3</span></span>
<span class="line"><span>j=3: 容量3 ≥ 重量3，可以装</span></span>
<span class="line"><span>     - 不选：dp[1][3] = 3</span></span>
<span class="line"><span>     - 选：dp[1][3-3] + 4 = dp[1][0] + 4 = 0 + 4 = 4</span></span>
<span class="line"><span>     - 取max：dp[2][3] = 4</span></span>
<span class="line"><span>j=4: 容量4 ≥ 重量3，可以装</span></span>
<span class="line"><span>     - 不选：dp[1][4] = 3</span></span>
<span class="line"><span>     - 选：dp[1][4-3] + 4 = dp[1][1] + 4 = 0 + 4 = 4</span></span>
<span class="line"><span>     - 取max：dp[2][4] = 4</span></span>
<span class="line"><span>j=5: 容量5 ≥ 重量3，可以装</span></span>
<span class="line"><span>     - 不选：dp[1][5] = 3</span></span>
<span class="line"><span>     - 选：dp[1][5-3] + 4 = dp[1][2] + 4 = 3 + 4 = 7</span></span>
<span class="line"><span>     - 取max：dp[2][5] = 7</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终 dp 数组：</span></span>
<span class="line"><span>| i\j | 0 | 1 | 2 | 3 | 4 | 5 |</span></span>
<span class="line"><span>| --- |---|---|---|---|---|---|</span></span>
<span class="line"><span>| 0   | 0 | 0 | 0 | 0 | 0 | 0 |</span></span>
<span class="line"><span>| 1   | 0 | 0 | 3 | 3 | 3 | 3 |</span></span>
<span class="line"><span>| 2   | 0 | 0 | 3 | 4 | 4 | 7 |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终答案：dp[2][5] = 7（选择物品1和物品2，总价值3+4=7）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p><strong>关键洞察</strong>：</p><ul><li>01背包的核心是&quot;选或不选&quot;的决策，每个物品只有一次机会</li><li>状态转移时，必须基于&quot;前 i-1 件物品&quot;的状态，体现&quot;只能用一次&quot;的约束</li><li>二维DP可以清晰地表达&quot;物品数量&quot;和&quot;容量&quot;两个维度的关系</li></ul><h4 id="实现代码-4" tabindex="-1">实现代码 <a class="header-anchor" href="#实现代码-4" aria-label="Permalink to &quot;实现代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 01背包最大价值计算（二维DP版本）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 物品总数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 背包最大容量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weightArr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 物品重量数组（0-based）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> valueArr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 物品价值数组（0-based）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@returns</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> - 最大价值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">w</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">weightArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">valueArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[i][k]：从前 i 件物品中选择，容量为 k 时的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 外层循环：遍历物品（1~n）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 内层循环：遍历容量（1~w）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curWeight</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weightArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前物品重量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> valueArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前物品价值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 不选当前物品：继承上一行的结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> valueNotChoose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][k];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curWeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 当前物品超重，只能不选</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dp[i][k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> valueNotChoose;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 选当前物品：当前价值 + 剩余容量的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> valueChoose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curWeight];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 取选/不选的最大值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dp[i][k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(valueNotChoose, valueChoose);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 打印dp数组，方便验证（可选）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;dp数组：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dp);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 最终结果：前 n 件物品，容量 w 时的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[n][w];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测试用例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> weightArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> valueArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;最大价值：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">maxValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n, w, weightArr, valueArr)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p><strong>复杂度分析</strong>：</p><ul><li><strong>时间复杂度</strong>：O(n × w)，需要填充 n×w 的二维数组</li><li><strong>空间复杂度</strong>：O(n × w)，二维DP数组的空间</li></ul><p><strong>空间优化：二维DP → 一维DP</strong></p><p>二维 DP 中，计算 <code>dp[i][k]</code>（前 i 件、容量 k）只依赖「上一行」的两个值：</p><ul><li><code>dp[i-1][k]</code>（不选当前物品，上一行同列）</li><li><code>dp[i-1][k-weight]</code>（选当前物品，上一行左侧列）</li></ul><p>也就是说，当前行的值只和上一行有关，不需要保存所有行的历史数据 —— 只用一个一维数组 <code>dp[k]</code> 记录「上一行」的结果，就能推导出当前行。</p><p><strong>关键：为什么必须倒序遍历容量？</strong></p><p>一维数组 <code>dp[k]</code> 的本质是<strong>复用同一个数组</strong>，既存「上一行（前 i-1 件物品）」的结果，又存「当前行（前 i 件物品）」的结果。</p><ul><li><strong>倒序遍历（k 从 w 到 1）</strong>：计算 <code>dp[k]</code> 时，<code>dp[k-weight]</code> 还是上一行的旧值，保证每个物品只选一次 ✅</li><li><strong>正序遍历（k 从 1 到 w）</strong>：计算 <code>dp[k]</code> 时，<code>dp[k-weight]</code> 可能已经被当前轮修改过，导致物品被重复选择 ❌</li></ul><p><strong>示例说明</strong>（正序遍历的错误）：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>假设物品1：重量1，价值10；背包容量2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>正序遍历（错误）：</span></span>
<span class="line"><span>k=1: dp[1] = max(dp[1], dp[0] + 10) = max(0, 10) = 10  ✅</span></span>
<span class="line"><span>k=2: dp[2] = max(dp[2], dp[1] + 10) = max(0, 10+10) = 20  ❌</span></span>
<span class="line"><span>     这里 dp[1] 已经被当前轮修改为10，导致物品1被选了2次！</span></span>
<span class="line"><span></span></span>
<span class="line"><span>倒序遍历（正确）：</span></span>
<span class="line"><span>k=2: dp[2] = max(dp[2], dp[1] + 10) = max(0, 0+10) = 10  ✅</span></span>
<span class="line"><span>k=1: dp[1] = max(dp[1], dp[0] + 10) = max(0, 10) = 10  ✅</span></span>
<span class="line"><span>     这里 dp[1] 还是上一行的旧值0，物品1只选一次！</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>版本1：基础一维DP（倒序遍历）</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">w</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">weightArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">valueArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[k]：容量为 k 时的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 外层循环：遍历物品（1~n）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curWeight</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weightArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> valueArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 内层循环：倒序遍历容量（w~1）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 倒序保证 dp[k-weight] 是上一行的旧值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w; k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curWeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 选当前物品：当前价值 + 剩余容量的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> valueChoose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curWeight];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 不选当前物品：dp[k]（上一行的旧值）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 取两者最大值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dp[k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dp[k], valueChoose);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 如果 curWeight &gt; k，dp[k] 保持不变（已经是上一行的值）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[w];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>版本2：进一步优化（跳过无效容量）</strong></p><p>内层循环的下限可以从 1 改成 <code>curWeight</code>（当前物品的重量）—— 因为如果 <code>k &lt; curWeight</code>，物品肯定装不下，没必要遍历这些容量，直接跳过能减少循环次数。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">w</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">weightArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">valueArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // dp[k]：容量为 k 时的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 外层循环：遍历物品（1~n）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curWeight</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weightArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> valueArr[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 跳过超重物品（重量超过背包最大容量，不可能被选）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curWeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 内层循环：倒序遍历容量（从 w 到 curWeight）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 优化：只遍历 k &gt;= curWeight 的容量，跳过装不下的情况</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w; k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curWeight; k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 选当前物品：当前价值 + 剩余容量的最大价值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> valueChoose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curWeight];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 不选当前物品：dp[k]（上一行的旧值）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 取两者最大值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      dp[k] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dp[k], valueChoose);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dp[w];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>两个版本的对比</strong>：</p><table tabindex="0"><thead><tr><th>特性</th><th>版本1（基础）</th><th>版本2（优化）</th></tr></thead><tbody><tr><td>内层循环范围</td><td><code>k = w; k &gt;= 1</code></td><td><code>k = w; k &gt;= curWeight</code></td></tr><tr><td>超重判断</td><td>在循环内判断 <code>if (curWeight &lt;= k)</code></td><td>循环前判断 <code>if (curWeight &gt; w) continue</code></td></tr><tr><td>循环次数</td><td>每次遍历所有容量</td><td>跳过 <code>k &lt; curWeight</code> 的容量</td></tr><tr><td>性能</td><td>基础版本</td><td>更优（减少无效循环）</td></tr><tr><td>推荐使用</td><td>理解原理</td><td>实际应用 ✅</td></tr></tbody></table><h2 id="三、动态规划核心总结" tabindex="-1">三、动态规划核心总结 <a class="header-anchor" href="#三、动态规划核心总结" aria-label="Permalink to &quot;三、动态规划核心总结&quot;">​</a></h2><h3 id="_3-1-核心思想" tabindex="-1">3.1 核心思想 <a class="header-anchor" href="#_3-1-核心思想" aria-label="Permalink to &quot;3.1 核心思想&quot;">​</a></h3><p>动态规划的本质是<strong>用空间换时间</strong>，通过存储子问题的解避免重复计算，将时间复杂度从指数级降低到多项式级。</p><p><strong>两个核心特征</strong>：</p><ul><li><strong>重叠子问题</strong>：递归过程中会重复计算相同的子问题</li><li><strong>最优子结构</strong>：问题的最优解包含子问题的最优解</li></ul><h3 id="_3-2-dp五部曲框架-万能钥匙" tabindex="-1">3.2 DP五部曲框架（万能钥匙） <a class="header-anchor" href="#_3-2-dp五部曲框架-万能钥匙" aria-label="Permalink to &quot;3.2 DP五部曲框架（万能钥匙）&quot;">​</a></h3><p>无论什么DP问题，都可以按以下5个步骤拆解：</p><ol><li><strong>确定dp数组及下标的含义</strong>：明确 <code>dp[i]</code>（或二维 <code>dp[i][j]</code>）代表什么物理意义</li><li><strong>确定递推公式</strong>：找到 <code>dp[i]</code> 与子问题 <code>dp[i-1]</code>/<code>dp[i-2]</code> 等的依赖关系（核心）</li><li><strong>dp数组如何初始化</strong>：根据问题边界条件，初始化无法通过递推得到的基础值</li><li><strong>确定遍历顺序</strong>：保证计算 <code>dp[i]</code> 时，其依赖的子问题已经被计算完成</li><li><strong>打印dp数组（验证）</strong>：通过打印中间结果，验证递推逻辑是否正确（调试必备）</li></ol><h3 id="_3-3-已掌握的经典问题" tabindex="-1">3.3 已掌握的经典问题 <a class="header-anchor" href="#_3-3-已掌握的经典问题" aria-label="Permalink to &quot;3.3 已掌握的经典问题&quot;">​</a></h3><p>本文通过DP五部曲框架，详细讲解了以下7个经典DP问题：</p><table tabindex="0"><thead><tr><th>问题</th><th>类型</th><th>核心特点</th><th>LeetCode</th></tr></thead><tbody><tr><td>1. 斐波那契数</td><td>一维DP</td><td>基础递推，空间可优化</td><td><a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noreferrer">509</a></td></tr><tr><td>2. 爬楼梯</td><td>一维DP</td><td>与斐波那契数本质相同</td><td><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noreferrer">70</a></td></tr><tr><td>3. 最小花费爬楼梯</td><td>一维DP</td><td>带权重的爬楼梯问题</td><td><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noreferrer">746</a></td></tr><tr><td>4. 机器人路径（无障碍）</td><td>二维DP</td><td>二维状态转移，可空间优化</td><td><a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noreferrer">62</a></td></tr><tr><td>5. 机器人路径（有障碍）</td><td>二维DP</td><td>障碍物处理，边界条件复杂</td><td><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noreferrer">63</a></td></tr><tr><td>6. 整数拆分</td><td>一维DP</td><td>双重循环，枚举拆分点</td><td><a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noreferrer">343</a></td></tr><tr><td>7. 不同的BST</td><td>一维DP</td><td>卡特兰数，乘法原理</td><td><a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noreferrer">96</a></td></tr><tr><td>8. 01背包问题</td><td>二维DP</td><td>选或不选，可空间优化（倒序）</td><td>经典问题</td></tr></tbody></table><h3 id="_3-4-常见优化技巧" tabindex="-1">3.4 常见优化技巧 <a class="header-anchor" href="#_3-4-常见优化技巧" aria-label="Permalink to &quot;3.4 常见优化技巧&quot;">​</a></h3><ol><li><p><strong>空间优化</strong>：</p><ul><li><strong>一维DP优化</strong>：斐波那契数、爬楼梯等，只需保存前两个状态</li><li><strong>二维DP → 一维DP</strong>：机器人路径、01背包等，用滚动数组优化</li><li><strong>关键点</strong>：注意遍历顺序（01背包必须倒序）</li></ul></li><li><p><strong>循环优化</strong>：</p><ul><li><strong>减少无效遍历</strong>：整数拆分中 j 只需遍历到 i/2</li><li><strong>提前终止</strong>：01背包中跳过超重物品，内层循环从 <code>curWeight</code> 开始</li></ul></li><li><p><strong>边界条件处理</strong>：</p><ul><li><strong>初始化技巧</strong>：<code>dp[0] = 1</code>（空树、空集等特殊情况）</li><li><strong>数组越界</strong>：注意下标转换（0-based vs 1-based）</li></ul></li></ol><h3 id="_3-5-调试技巧" tabindex="-1">3.5 调试技巧 <a class="header-anchor" href="#_3-5-调试技巧" aria-label="Permalink to &quot;3.5 调试技巧&quot;">​</a></h3><ol><li><strong>打印dp数组</strong>：在关键位置打印中间结果，验证递推逻辑</li><li><strong>小数据验证</strong>：先用小规模数据手动计算，验证代码正确性</li><li><strong>边界测试</strong>：测试 n=0、n=1、空数组等边界情况</li><li><strong>对比二维和一维</strong>：空间优化时，先用二维DP验证，再优化为一维</li></ol><h3 id="_3-6-解题思路总结" tabindex="-1">3.6 解题思路总结 <a class="header-anchor" href="#_3-6-解题思路总结" aria-label="Permalink to &quot;3.6 解题思路总结&quot;">​</a></h3><p><strong>如何快速识别DP问题？</strong></p><ul><li>求最值、计数、可行性问题</li><li>问题可以拆解为重叠子问题</li><li>有明确的&quot;状态&quot;和&quot;选择&quot;</li></ul><p><strong>如何快速确定dp数组含义？</strong></p><ul><li>看问题问什么，dp就存什么（最大价值、方案数等）</li><li>看状态有几个维度（一维：位置/数量；二维：位置+容量/位置+位置）</li></ul><p><strong>如何推导递推公式？</strong></p><ul><li><strong>最后一步分析</strong>：考虑最后一步的选择（选/不选、走哪条路等）</li><li><strong>状态转移</strong>：当前状态 = 子状态 + 当前选择的影响</li><li><strong>取最值/求和</strong>：根据问题类型选择 max、min、sum 等操作</li></ul><h2 id="四、后续待补充" tabindex="-1">四、后续待补充 <a class="header-anchor" href="#四、后续待补充" aria-label="Permalink to &quot;四、后续待补充&quot;">​</a></h2><p>（可继续补充以下内容，完善DP知识体系）</p><ol><li><p><strong>更多经典DP问题</strong>：</p><ul><li>最长递增子序列（LIS）</li><li>完全背包、多重背包</li><li>股票买卖系列问题</li><li>编辑距离</li><li>最长公共子序列（LCS）</li></ul></li><li><p><strong>DP变种和技巧</strong>：</p><ul><li>区间DP</li><li>树形DP</li><li>状态压缩DP</li><li>数位DP</li></ul></li><li><p><strong>DP与其他算法的对比</strong>：</p><ul><li>动态规划 vs 贪心算法（何时用DP，何时用贪心）</li><li>动态规划 vs 分治算法</li><li>记忆化搜索（递归+备忘录）</li></ul></li><li><p><strong>常见陷阱和易错点</strong>：</p><ul><li>初始化错误（如 <code>dp[0]</code> 的取值）</li><li>遍历顺序错误（如01背包必须倒序）</li><li>数组越界（下标转换问题）</li><li>状态转移遗漏情况</li></ul></li></ol><p><strong>学习建议</strong>：</p><p>动态规划的掌握没有捷径，唯有「理解框架 + 多练经典问题」。把上述7个问题的DP五部曲吃透，再逐步攻克更复杂的DP问题，就能形成自己的解题思路！</p><p><strong>推荐学习路径</strong>：</p><ol><li>✅ 掌握DP五部曲框架（本文已详细讲解）</li><li>✅ 刷完本文7个经典问题（理解思路，不看答案独立完成）</li><li>🔄 扩展到更多DP变种（背包系列、股票系列等）</li><li>🔄 学习高级DP技巧（状态压缩、树形DP等）</li></ol></div></div></main><footer class="VPDocFooter" data-v-87c78cff data-v-156be078><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-156be078><span class="visually-hidden" id="doc-footer-aria-label" data-v-156be078>Pager</span><div class="pager" data-v-156be078><a class="VPLink link pager-link prev" href="/ds-algo/notes/03-01-two-pointers.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Previous page</span><span class="title" data-v-156be078>双指针详解</span><!--]--></a></div><div class="pager" data-v-156be078><a class="VPLink link pager-link next" href="/ds-algo/notes/03-04-dp2.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Next page</span><span class="title" data-v-156be078>DP进阶：背包问题</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"BEzItQig\",\"index.md\":\"B4ycJzSv\",\"markdown-examples.md\":\"C6Br5WQ0\",\"notes_01-prepare.md\":\"CWdzl9k_\",\"notes_01-structure.md\":\"BEFMGNhx\",\"notes_02-01-linked-list-implementation.md\":\"DaJw558a\",\"notes_02-02-hash-table-implementation.md\":\"C91ApNil\",\"notes_02-03-stack-queue-implementation.md\":\"CdBHuB1g\",\"notes_02-04-binary-tree-implementation.md\":\"BKjoZpvX\",\"notes_02-04-binary-tree-optimized.md\":\"yNCeGoY4\",\"notes_02-05-heap-implementation.md\":\"BTA0i6Jn\",\"notes_02-data-structures.md\":\"BM87vHyD\",\"notes_03-01-basic-exercise.md\":\"C2Q82BwY\",\"notes_03-01-strarr-exercise.md\":\"xTH0sqH_\",\"notes_03-01-two-pointers.md\":\"B3W6fSVu\",\"notes_03-02-sliding-window.md\":\"CRVtcW0S\",\"notes_03-04-dp1.md\":\"CpNakAf-\",\"notes_03-04-dp2.md\":\"BW3PdaI5\",\"notes_03-04-dp3.md\":\"DW2E5wU8\",\"notes_03-04-dp4.md\":\"23g9qSUp\",\"notes_03-04-dp44.md\":\"C2H22XJT\",\"notes_03-algorithms.md\":\"D4bWd1I_\",\"notes_04-binary-search.md\":\"CvJKxSaH\",\"notes_04-frontend.md\":\"D0SU1fUs\",\"notes_05-backtrack.md\":\"qllJAqDv\",\"notes_catalan.md\":\"TR2oXnOe\",\"notes_dp-frontend-blog.md\":\"9lL0Xhgy\",\"notes_leetcode.md\":\"NLtkdwYT\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"数据结构与算法学习笔记\",\"description\":\"前端工程师的算法系统化学习指南\",\"base\":\"/ds-algo/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"学习笔记\",\"link\":\"/notes/01-prepare\"},{\"text\":\"刷题指南\",\"link\":\"/notes/leetcode\"}],\"sidebar\":{\"/notes/\":[{\"text\":\"前置准备\",\"link\":\"/notes/01-prepare\"},{\"text\":\"基础数据结构\",\"link\":\"/notes/02-data-structures\",\"items\":[{\"text\":\"数组 & 链表\",\"link\":\"/notes/02-data-structures#数组--链表\"},{\"text\":\"单向链表实现详解\",\"link\":\"/notes/02-01-linked-list-implementation\"},{\"text\":\"栈 & 队列\",\"link\":\"/notes/02-data-structures#栈--队列\"},{\"text\":\"栈 & 队列实现详解\",\"link\":\"/notes/02-03-stack-queue-implementation\"},{\"text\":\"哈希表\",\"link\":\"/notes/02-data-structures#哈希表\"},{\"text\":\"哈希表实现详解\",\"link\":\"/notes/02-02-hash-table-implementation\"},{\"text\":\"树 & 堆\",\"link\":\"/notes/02-data-structures#树--堆\"},{\"text\":\"二叉树实现详解\",\"link\":\"/notes/02-04-binary-tree-implementation\"},{\"text\":\"二叉树优化版实现\",\"link\":\"/notes/02-04-binary-tree-optimized\"},{\"text\":\"堆实现详解\",\"link\":\"/notes/02-05-heap-implementation\"}]},{\"text\":\"核心算法思想\",\"link\":\"/notes/03-algorithms\",\"items\":[{\"text\":\"算法思想总览\",\"link\":\"/notes/03-algorithms\"},{\"text\":\"双指针详解\",\"link\":\"/notes/03-01-two-pointers\"},{\"text\":\"动态规划\",\"collapsed\":false,\"items\":[{\"text\":\"DP基础：五部曲框架\",\"link\":\"/notes/03-04-dp1\"},{\"text\":\"DP进阶：背包问题\",\"link\":\"/notes/03-04-dp2\"},{\"text\":\"DP高级：完全背包变形\",\"link\":\"/notes/03-04-dp3\"},{\"text\":\"前端必备DP：10道经典题目\",\"link\":\"/notes/dp-frontend-blog\"}]}]},{\"text\":\"前端专项算法\",\"link\":\"/notes/04-frontend\"},{\"text\":\"LeetCode 刷题\",\"link\":\"/notes/leetcode\"}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/frontzhm/ds-algo\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>