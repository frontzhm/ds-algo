<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>核心算法思想 | 数据结构与算法学习笔记</title>
    <meta name="description" content="前端工程师的算法系统化学习指南">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/ds-algo/assets/style.B66l8Vrp.css" as="style">
    <link rel="preload stylesheet" href="/ds-algo/vp-icons.css" as="style">
    
    <script type="module" src="/ds-algo/assets/app.B10ddQOp.js"></script>
    <link rel="preload" href="/ds-algo/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/theme.fCM-gQVs.js">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/framework.CRdajAWK.js">
    <link rel="modulepreload" href="/ds-algo/assets/notes_03-algorithms.md.D4bWd1I_.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-6d407042><!--[--><!--]--><!--[--><span tabindex="-1" data-v-ba3da56b></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-ba3da56b>Skip to content</a><!--]--><!----><header class="VPNav" data-v-6d407042 data-v-d7238be4><div class="VPNavBar" data-v-d7238be4 data-v-8c571379><div class="wrapper" data-v-8c571379><div class="container" data-v-8c571379><div class="title" data-v-8c571379><div class="VPNavBarTitle has-sidebar" data-v-8c571379 data-v-980706ad><a class="title" href="/ds-algo/" data-v-980706ad><!--[--><!--]--><!----><span data-v-980706ad>数据结构与算法学习笔记</span><!--[--><!--]--></a></div></div><div class="content" data-v-8c571379><div class="content-body" data-v-8c571379><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8c571379><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8c571379 data-v-a2551964><span id="main-nav-aria-label" class="visually-hidden" data-v-a2551964> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/01-prepare.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>学习笔记</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/leetcode.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>刷题指南</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8c571379 data-v-b2d09d06><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-b2d09d06 data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8c571379 data-v-71ee68fe data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8c571379 data-v-3b81dbff data-v-db67345a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-db67345a><span class="vpi-more-horizontal icon" data-v-db67345a></span></button><div class="menu" data-v-db67345a><div class="VPMenu" data-v-db67345a data-v-2d04c868><!----><!--[--><!--[--><!----><div class="group" data-v-3b81dbff><div class="item appearance" data-v-3b81dbff><p class="label" data-v-3b81dbff>Appearance</p><div class="appearance-action" data-v-3b81dbff><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3b81dbff data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div></div></div><div class="group" data-v-3b81dbff><div class="item social-links" data-v-3b81dbff><div class="VPSocialLinks social-links-list" data-v-3b81dbff data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8c571379 data-v-c7311208><span class="container" data-v-c7311208><span class="top" data-v-c7311208></span><span class="middle" data-v-c7311208></span><span class="bottom" data-v-c7311208></span></span></button></div></div></div></div><div class="divider" data-v-8c571379><div class="divider-line" data-v-8c571379></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-6d407042 data-v-81ec55a2><div class="container" data-v-81ec55a2><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-81ec55a2><span class="vpi-align-left menu-icon" data-v-81ec55a2></span><span class="menu-text" data-v-81ec55a2>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-81ec55a2 data-v-dfa7dd31><button data-v-dfa7dd31>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-6d407042 data-v-f5bdc5c7><div class="curtain" data-v-f5bdc5c7></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-f5bdc5c7><span class="visually-hidden" id="sidebar-aria-label" data-v-f5bdc5c7> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/01-prepare.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前置准备</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>基础数据结构</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%95%B0%E7%BB%84--%E9%93%BE%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>数组 & 链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-01-linked-list-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>单向链表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%88--%E9%98%9F%E5%88%97" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-03-stack-queue-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E5%93%88%E5%B8%8C%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-02-hash-table-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%91--%E5%A0%86" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>树 & 堆</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-optimized.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树优化版实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-05-heap-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>堆实现详解</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link has-active" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>核心算法思想</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>算法思想总览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-01-two-pointers.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>双指针详解</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" role="button" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><h3 class="text" data-v-fe5fc7a5>动态规划</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-fe5fc7a5><span class="vpi-chevron-right caret-icon" data-v-fe5fc7a5></span></div></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp1.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP基础：五部曲框架</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp2.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP进阶：背包问题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp3.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP高级：完全背包变形</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/dp-frontend-blog.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端必备DP：10道经典题目</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/04-frontend.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端专项算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/leetcode.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>LeetCode 刷题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-6d407042 data-v-7ba754bd><div class="VPDoc has-sidebar has-aside" data-v-7ba754bd data-v-87c78cff><!--[--><!--]--><div class="container" data-v-87c78cff><div class="aside" data-v-87c78cff><div class="aside-curtain" data-v-87c78cff></div><div class="aside-container" data-v-87c78cff><div class="aside-content" data-v-87c78cff><div class="VPDocAside" data-v-87c78cff data-v-a4047630><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-a4047630 data-v-fc01bd9a><div class="content" data-v-fc01bd9a><div class="outline-marker" data-v-fc01bd9a></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-fc01bd9a>On this page</div><ul class="VPDocOutlineItem root" data-v-fc01bd9a data-v-d7fbdf5f><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-a4047630></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-87c78cff><div class="content-container" data-v-87c78cff><!--[--><!--]--><main class="main" data-v-87c78cff><div style="position:relative;" class="vp-doc _ds-algo_notes_03-algorithms" data-v-87c78cff><div><h1 id="核心算法思想" tabindex="-1">核心算法思想 <a class="header-anchor" href="#核心算法思想" aria-label="Permalink to &quot;核心算法思想&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>本文档是<strong>算法题的常用解题技巧/思想分类清单</strong>，是面试和刷题中高频用到的核心方法汇总。每一项都是解决特定类型问题的&quot;通用思路&quot;，掌握这些技巧能帮你快速识别问题类型并选择正确的解题方法。</p><h2 id="学习路径规划" tabindex="-1">学习路径规划 <a class="header-anchor" href="#学习路径规划" aria-label="Permalink to &quot;学习路径规划&quot;">​</a></h2><h3 id="阶段一-基础工具-技巧-必学-每日练" tabindex="-1">阶段一：基础工具+技巧（必学，每日练） <a class="header-anchor" href="#阶段一-基础工具-技巧-必学-每日练" aria-label="Permalink to &quot;阶段一：基础工具+技巧（必学，每日练）&quot;">​</a></h3><ol start="0"><li><strong>排序/搜索</strong> - 算法的“基础设施” <ul><li>排序：快排、归并（搭配数组）</li><li>搜索：二分、DFS/BFS（搭配数组、二叉树）</li></ul></li><li><strong>双指针</strong> - 数组/链表的核心技巧（⭐⭐⭐⭐⭐）</li><li><strong>滑动窗口</strong> - 连续子数组/子串问题（⭐⭐⭐⭐）</li><li><strong>递归</strong> - 分而治之的基础（搭配二叉树）（⭐⭐⭐⭐）</li></ol><h3 id="阶段二-核心算法-重点-周练" tabindex="-1">阶段二：核心算法（重点，周练） <a class="header-anchor" href="#阶段二-核心算法-重点-周练" aria-label="Permalink to &quot;阶段二：核心算法（重点，周练）&quot;">​</a></h3><ol start="4"><li><strong>动态规划（DP）</strong> - 重叠子问题+最优子结构（⭐⭐⭐⭐⭐）</li><li><strong>回溯算法</strong> - 穷举所有可能（⭐⭐⭐⭐）</li><li><strong>贪心算法</strong> - 局部最优到全局最优（⭐⭐⭐）</li></ol><h3 id="阶段三-高级应用-进阶-综合练" tabindex="-1">阶段三：高级应用（进阶，综合练） <a class="header-anchor" href="#阶段三-高级应用-进阶-综合练" aria-label="Permalink to &quot;阶段三：高级应用（进阶，综合练）&quot;">​</a></h3><ol start="7"><li><strong>分治算法</strong> - 大问题拆解（搭配归并、合并K个链表）</li><li><strong>复杂场景综合</strong> - 多技巧结合（比如“双指针+DP”、“滑动窗口+哈希表”）</li></ol><h2 id="避坑指南-关键" tabindex="-1">避坑指南（关键） <a class="header-anchor" href="#避坑指南-关键" aria-label="Permalink to &quot;避坑指南（关键）&quot;">​</a></h2><ul><li>双指针：避免指针越界，明确“指针移动条件”</li><li>动态规划：先写“状态定义”，再写“转移方程”</li><li>回溯：必须剪枝，否则会超时</li><li>贪心：先证明“贪心选择性质”，否则容易错</li></ul><hr><h2 id="一、排序算法-sorting-阶段一-基础工具" tabindex="-1">一、排序算法（Sorting）- 阶段一：基础工具 <a class="header-anchor" href="#一、排序算法-sorting-阶段一-基础工具" aria-label="Permalink to &quot;一、排序算法（Sorting）- 阶段一：基础工具&quot;">​</a></h2><p>排序是算法的基础，掌握常见排序算法有助于理解其他算法。</p><h3 id="_1-1-快速排序-quick-sort" tabindex="-1">1.1 快速排序（Quick Sort） <a class="header-anchor" href="#_1-1-快速排序-quick-sort" aria-label="Permalink to &quot;1.1 快速排序（Quick Sort）&quot;">​</a></h3><p><strong>时间复杂度：</strong> 平均 O(nlogn)，最坏 O(n²)<br><strong>空间复杂度：</strong> O(logn)<br><strong>稳定性：</strong> 不稳定</p><p><strong>核心思想：</strong></p><ul><li>选择一个基准元素（pivot）</li><li>将数组分为两部分：小于基准和大于基准</li><li>递归排序两部分</li></ul><p><strong>适用场景：</strong></p><ul><li>一般情况下的高效排序</li><li>数据量大且随机分布</li></ul><h3 id="_1-2-归并排序-merge-sort" tabindex="-1">1.2 归并排序（Merge Sort） <a class="header-anchor" href="#_1-2-归并排序-merge-sort" aria-label="Permalink to &quot;1.2 归并排序（Merge Sort）&quot;">​</a></h3><p><strong>时间复杂度：</strong> O(nlogn)<br><strong>空间复杂度：</strong> O(n)<br><strong>稳定性：</strong> 稳定</p><p><strong>核心思想：</strong></p><ul><li>将数组不断二分，直到单个元素</li><li>合并两个有序数组</li><li>分治思想的典型应用</li></ul><p><strong>适用场景：</strong></p><ul><li>需要稳定排序</li><li>链表排序</li><li>外部排序</li></ul><h3 id="_1-3-堆排序-heap-sort" tabindex="-1">1.3 堆排序（Heap Sort） <a class="header-anchor" href="#_1-3-堆排序-heap-sort" aria-label="Permalink to &quot;1.3 堆排序（Heap Sort）&quot;">​</a></h3><p><strong>时间复杂度：</strong> O(nlogn)<br><strong>空间复杂度：</strong> O(1)<br><strong>稳定性：</strong> 不稳定</p><p><strong>核心思想：</strong></p><ul><li>构建最大堆/最小堆</li><li>不断取出堆顶元素</li><li>利用堆的性质排序</li></ul><p><strong>适用场景：</strong></p><ul><li>需要原地排序</li><li>TopK 问题</li></ul><hr><h2 id="二、搜索算法-searching-阶段一-基础工具" tabindex="-1">二、搜索算法（Searching）- 阶段一：基础工具 <a class="header-anchor" href="#二、搜索算法-searching-阶段一-基础工具" aria-label="Permalink to &quot;二、搜索算法（Searching）- 阶段一：基础工具&quot;">​</a></h2><h3 id="_2-1-二分查找-binary-search" tabindex="-1">2.1 二分查找（Binary Search） <a class="header-anchor" href="#_2-1-二分查找-binary-search" aria-label="Permalink to &quot;2.1 二分查找（Binary Search）&quot;">​</a></h3><p><strong>时间复杂度：</strong> O(logn)<br><strong>前提条件：</strong> 有序数组</p><p><strong>核心思想：</strong></p><ul><li>每次排除一半的搜索空间</li><li>通过比较中间元素缩小范围</li></ul><p><strong>适用场景：</strong></p><ul><li>有序数组查找</li><li>查找边界问题</li><li>旋转数组查找</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noreferrer">704. 二分查找</a></li><li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noreferrer">34. 在排序数组中查找元素的第一个和最后一个位置</a></li><li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank" rel="noreferrer">33. 搜索旋转排序数组</a></li></ul><h3 id="_2-2-dfs-深度优先搜索" tabindex="-1">2.2 DFS（深度优先搜索） <a class="header-anchor" href="#_2-2-dfs-深度优先搜索" aria-label="Permalink to &quot;2.2 DFS（深度优先搜索）&quot;">​</a></h3><p><strong>适用场景：</strong></p><ul><li>图的遍历</li><li>树的遍历</li><li>路径问题</li><li>连通性问题</li></ul><p><strong>核心思想：</strong></p><ul><li>一条路走到黑，再回溯</li><li>利用递归或栈实现</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noreferrer">200. 岛屿数量</a></li><li><a href="https://leetcode.cn/problems/max-area-of-island/" target="_blank" rel="noreferrer">695. 岛屿的最大面积</a></li><li><a href="https://leetcode.cn/problems/word-search/" target="_blank" rel="noreferrer">79. 单词搜索</a></li></ul><h3 id="_2-3-bfs-广度优先搜索" tabindex="-1">2.3 BFS（广度优先搜索） <a class="header-anchor" href="#_2-3-bfs-广度优先搜索" aria-label="Permalink to &quot;2.3 BFS（广度优先搜索）&quot;">​</a></h3><p><strong>适用场景：</strong></p><ul><li>最短路径问题（无权图）</li><li>层序遍历</li><li>扩散问题</li></ul><p><strong>核心思想：</strong></p><ul><li>一层一层遍历</li><li>利用队列实现</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noreferrer">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noreferrer">200. 岛屿数量</a></li><li><a href="https://leetcode.cn/problems/word-ladder/" target="_blank" rel="noreferrer">127. 单词接龙</a></li></ul><hr><h2 id="三、双指针-two-pointers-阶段一-核心技巧-⭐⭐⭐⭐⭐" tabindex="-1">三、双指针（Two Pointers）- 阶段一：核心技巧 ⭐⭐⭐⭐⭐ <a class="header-anchor" href="#三、双指针-two-pointers-阶段一-核心技巧-⭐⭐⭐⭐⭐" aria-label="Permalink to &quot;三、双指针（Two Pointers）- 阶段一：核心技巧 ⭐⭐⭐⭐⭐&quot;">​</a></h2><p>双指针是数组/链表问题的核心技巧，通过维护两个指针来高效解决问题。</p><p><strong>核心定义</strong>：用<strong>两个指针（索引）</strong> 遍历数据结构（数组/链表），通过指针的&quot;移动规则&quot;减少遍历次数，将时间复杂度从 O(n²) 优化到 O(n)。</p><p><strong>主要分类</strong>：</p><ul><li><strong>快慢指针</strong>：解决链表环形问题、找中间节点、删除倒数第k个节点</li><li><strong>左右指针</strong>：解决有序数组两数之和、回文判断、盛水容器</li><li><strong>固定窗口指针</strong>：解决固定长度子数组问题</li><li><strong>Vue3 diff 四个指针</strong>：虚拟 DOM 对比算法</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noreferrer">141. 环形链表</a></li><li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noreferrer">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noreferrer">11. 盛最多水的容器</a></li></ul><p>📖 <strong>详细内容请参考：</strong> <a href="https://juejin.cn/post/7593692797765976106" target="_blank" rel="noreferrer">双指针详解</a></p><hr><h2 id="四、滑动窗口-sliding-window-阶段一-核心技巧-⭐⭐⭐⭐" tabindex="-1">四、滑动窗口（Sliding Window）- 阶段一：核心技巧 ⭐⭐⭐⭐ <a class="header-anchor" href="#四、滑动窗口-sliding-window-阶段一-核心技巧-⭐⭐⭐⭐" aria-label="Permalink to &quot;四、滑动窗口（Sliding Window）- 阶段一：核心技巧 ⭐⭐⭐⭐&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>连续子数组/子串问题</li><li>最长无重复字符子串</li><li>最小覆盖子串</li><li>滑动窗口最大值</li><li>长度最小的子数组</li></ul><p><strong>核心思想：</strong></p><ul><li>用双指针维护一个&quot;动态区间&quot;（窗口）</li><li>通过移动窗口边界，减少重复计算</li><li>窗口大小可以是固定的或动态的</li></ul><p><strong>算法模板：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slidingWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 窗口数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 扩大窗口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s[right];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, (window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 缩小窗口（根据条件）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (window需要缩小) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s[left];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d, window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 更新结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noreferrer">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noreferrer">76. 最小覆盖子串</a></li><li><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noreferrer">239. 滑动窗口最大值</a></li><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noreferrer">209. 长度最小的子数组</a></li></ul><hr><h2 id="五、递归-recursion-阶段一-核心技巧-⭐⭐⭐⭐" tabindex="-1">五、递归（Recursion）- 阶段一：核心技巧 ⭐⭐⭐⭐ <a class="header-anchor" href="#五、递归-recursion-阶段一-核心技巧-⭐⭐⭐⭐" aria-label="Permalink to &quot;五、递归（Recursion）- 阶段一：核心技巧 ⭐⭐⭐⭐&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>二叉树遍历（前序、中序、后序）</li><li>归并排序</li><li>斐波那契数列</li><li>汉诺塔问题</li><li>分而治之的问题</li></ul><p><strong>核心思想：</strong></p><ul><li>通过&quot;调用自身&quot;拆解问题</li><li>必须有终止条件，避免无限递归</li><li>利用函数调用栈保存状态</li></ul><p><strong>递归三要素：</strong></p><ol><li><strong>终止条件</strong>：递归何时结束</li><li><strong>递归关系</strong>：如何拆解问题</li><li><strong>返回值</strong>：如何合并子问题的解</li></ol><p><strong>注意事项：</strong></p><ul><li>避免栈溢出（深递归时考虑迭代实现）</li><li>注意重复计算（可用记忆化优化）</li><li>理解递归调用栈的执行顺序</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noreferrer">104. 二叉树的最大深度</a></li><li><a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noreferrer">509. 斐波那契数</a></li><li><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noreferrer">206. 反转链表</a></li></ul><hr><h2 id="六、动态规划-dynamic-programming-阶段二-核心算法-⭐⭐⭐⭐⭐" tabindex="-1">六、动态规划（Dynamic Programming）- 阶段二：核心算法 ⭐⭐⭐⭐⭐ <a class="header-anchor" href="#六、动态规划-dynamic-programming-阶段二-核心算法-⭐⭐⭐⭐⭐" aria-label="Permalink to &quot;六、动态规划（Dynamic Programming）- 阶段二：核心算法 ⭐⭐⭐⭐⭐&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>重叠子问题 + 最优子结构</li><li>最长递增子序列</li><li>背包问题（0-1背包、完全背包）</li><li>零钱兑换</li><li>编辑距离</li><li>股票买卖问题</li></ul><p><strong>核心思想：</strong></p><ul><li>用&quot;状态转移方程&quot;记录子问题的解</li><li>避免重复计算，提升效率</li><li>自底向上或自顶向下求解</li></ul><p><strong>DP 三要素：</strong></p><ol><li><strong>状态定义</strong>：<code>dp[i]</code> 表示什么</li><li><strong>状态转移方程</strong>：<code>dp[i] = f(dp[i-1], ...)</code></li><li><strong>边界条件</strong>：初始状态</li></ol><p><strong>解题步骤：</strong></p><ol><li>确定状态（一维/二维）</li><li>写出状态转移方程</li><li>初始化边界条件</li><li>确定遍历顺序</li><li>举例验证</li></ol><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noreferrer">70. 爬楼梯</a></li><li><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noreferrer">53. 最大子数组和</a></li><li><a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noreferrer">322. 零钱兑换</a></li><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noreferrer">300. 最长递增子序列</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noreferrer">121. 买卖股票的最佳时机</a></li></ul><hr><h2 id="七、回溯算法-backtracking-阶段二-核心算法-⭐⭐⭐⭐" tabindex="-1">七、回溯算法（Backtracking）- 阶段二：核心算法 ⭐⭐⭐⭐ <a class="header-anchor" href="#七、回溯算法-backtracking-阶段二-核心算法-⭐⭐⭐⭐" aria-label="Permalink to &quot;七、回溯算法（Backtracking）- 阶段二：核心算法 ⭐⭐⭐⭐&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>穷举所有可能的问题</li><li>全排列</li><li>组合总和</li><li>N 皇后问题</li><li>子集问题</li><li>数独求解</li></ul><p><strong>核心思想：</strong></p><ul><li>&quot;尝试-回退&quot;机制</li><li>通过剪枝优化效率</li><li>利用递归实现状态回溯</li></ul><p><strong>回溯模板：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backtrack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">路径</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">选择列表</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 终止条件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足条件) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    结果.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(路径);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 遍历选择</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (选择 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 选择列表) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 做选择</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    路径.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(选择);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 递归</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    backtrack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(路径, 选择列表);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 撤销选择（回溯）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    路径.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>优化技巧：</strong></p><ul><li>剪枝：提前排除不可能的分支</li><li>去重：避免重复计算</li><li>记忆化：缓存已计算的结果</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noreferrer">46. 全排列</a></li><li><a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noreferrer">78. 子集</a></li><li><a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noreferrer">39. 组合总和</a></li><li><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noreferrer">51. N 皇后</a></li></ul><hr><h2 id="八、贪心算法-greedy-阶段二-核心算法-⭐⭐⭐" tabindex="-1">八、贪心算法（Greedy）- 阶段二：核心算法 ⭐⭐⭐ <a class="header-anchor" href="#八、贪心算法-greedy-阶段二-核心算法-⭐⭐⭐" aria-label="Permalink to &quot;八、贪心算法（Greedy）- 阶段二：核心算法 ⭐⭐⭐&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>每一步选局部最优，最终得到全局最优</li><li>买卖股票的最佳时机（部分问题）</li><li>区间调度问题</li><li>霍夫曼编码</li><li>最小生成树（部分算法）</li></ul><p><strong>核心思想：</strong></p><ul><li>每一步都做出当前最优的选择</li><li>不回溯，不重新考虑已做的选择</li><li>需要证明问题满足&quot;贪心选择性质&quot;</li></ul><p><strong>适用条件：</strong></p><ol><li><strong>贪心选择性质</strong>：局部最优能导致全局最优</li><li><strong>最优子结构</strong>：问题的最优解包含子问题的最优解</li></ol><p><strong>注意事项：</strong></p><ul><li>不是所有问题都适合贪心</li><li>需要严格证明贪心策略的正确性</li><li>与动态规划的区别：贪心不保存子问题的解</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noreferrer">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noreferrer">55. 跳跃游戏</a></li><li><a href="https://leetcode.cn/problems/non-overlapping-intervals/" target="_blank" rel="noreferrer">435. 无重叠区间</a></li><li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noreferrer">452. 用最少数量的箭引爆气球</a></li></ul><hr><h2 id="九、分治算法-divide-and-conquer-阶段三-高级应用" tabindex="-1">九、分治算法（Divide and Conquer）- 阶段三：高级应用 <a class="header-anchor" href="#九、分治算法-divide-and-conquer-阶段三-高级应用" aria-label="Permalink to &quot;九、分治算法（Divide and Conquer）- 阶段三：高级应用&quot;">​</a></h2><p><strong>适用场景：</strong></p><ul><li>大问题拆成小问题，小问题解合并成大问题解</li><li>归并排序</li><li>快速排序</li><li>大数乘法</li><li>最近点对问题</li></ul><p><strong>核心思想：</strong></p><ul><li><strong>分（Divide）</strong>：将问题分解为子问题</li><li><strong>治（Conquer）</strong>：递归求解子问题</li><li><strong>合（Combine）</strong>：合并子问题的解</li></ul><p><strong>与递归的关系：</strong></p><ul><li>分治是递归的常见应用场景</li><li>分治通常有明确的&quot;分&quot;和&quot;合&quot;步骤</li></ul><p><strong>经典题目：</strong></p><ul><li><a href="../packages/core/src/algorithms/sort/index.ts">归并排序实现</a></li><li><a href="../packages/core/src/algorithms/sort/index.ts">快速排序实现</a></li><li><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noreferrer">23. 合并 K 个升序链表</a></li><li><a href="https://leetcode.cn/problems/majority-element/" target="_blank" rel="noreferrer">169. 多数元素</a></li></ul><hr><h2 id="十、复杂场景综合-阶段三-高级应用" tabindex="-1">十、复杂场景综合 - 阶段三：高级应用 <a class="header-anchor" href="#十、复杂场景综合-阶段三-高级应用" aria-label="Permalink to &quot;十、复杂场景综合 - 阶段三：高级应用&quot;">​</a></h2><p>在实际算法题中，很多问题需要<strong>多种技巧结合</strong>使用，这是算法能力的综合体现。</p><h3 id="_10-1-双指针-动态规划" tabindex="-1">10.1 双指针 + 动态规划 <a class="header-anchor" href="#_10-1-双指针-动态规划" aria-label="Permalink to &quot;10.1 双指针 + 动态规划&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>最长回文子串</li><li>编辑距离的优化</li></ul><p><strong>示例：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最长回文子串：双指针扩展 + DP 优化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> longestPalindrome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 结合双指针和动态规划的思路</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_10-2-滑动窗口-哈希表" tabindex="-1">10.2 滑动窗口 + 哈希表 <a class="header-anchor" href="#_10-2-滑动窗口-哈希表" aria-label="Permalink to &quot;10.2 滑动窗口 + 哈希表&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>最小覆盖子串</li><li>找到字符串中所有字母异位词</li></ul><p><strong>示例：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 滑动窗口 + 哈希表记录字符频率</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> minWindow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> need</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 哈希表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 滑动窗口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_10-3-回溯-剪枝优化" tabindex="-1">10.3 回溯 + 剪枝优化 <a class="header-anchor" href="#_10-3-回溯-剪枝优化" aria-label="Permalink to &quot;10.3 回溯 + 剪枝优化&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>N 皇后问题</li><li>数独求解</li></ul><p><strong>关键点：</strong></p><ul><li>回溯是基础框架</li><li>剪枝是性能优化的关键</li></ul><h3 id="_10-4-分治-递归" tabindex="-1">10.4 分治 + 递归 <a class="header-anchor" href="#_10-4-分治-递归" aria-label="Permalink to &quot;10.4 分治 + 递归&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>归并排序</li><li>快速排序</li><li>合并 K 个有序链表</li></ul><p><strong>关键点：</strong></p><ul><li>分治是思路</li><li>递归是实现方式</li></ul><h3 id="_10-5-动态规划-状态压缩" tabindex="-1">10.5 动态规划 + 状态压缩 <a class="header-anchor" href="#_10-5-动态规划-状态压缩" aria-label="Permalink to &quot;10.5 动态规划 + 状态压缩&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>状态空间较大的 DP 问题</li><li>位运算优化状态表示</li></ul><p><strong>关键点：</strong></p><ul><li>用位运算压缩状态</li><li>减少空间复杂度</li></ul><h3 id="_10-6-贪心-排序" tabindex="-1">10.6 贪心 + 排序 <a class="header-anchor" href="#_10-6-贪心-排序" aria-label="Permalink to &quot;10.6 贪心 + 排序&quot;">​</a></h3><p><strong>典型场景：</strong></p><ul><li>区间调度问题</li><li>活动选择问题</li></ul><p><strong>关键点：</strong></p><ul><li>先排序预处理</li><li>再用贪心策略选择</li></ul><h3 id="综合练习建议" tabindex="-1">综合练习建议 <a class="header-anchor" href="#综合练习建议" aria-label="Permalink to &quot;综合练习建议&quot;">​</a></h3><ol><li><strong>从单一技巧开始</strong>：先掌握每种技巧的独立应用</li><li><strong>逐步组合</strong>：理解每种技巧的特点，再思考如何组合</li><li><strong>多做综合题</strong>：LeetCode 中等和困难题往往需要多技巧结合</li><li><strong>总结模式</strong>：识别常见的组合模式，形成解题模板</li></ol><p><strong>经典综合题目：</strong></p><ul><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/" target="_blank" rel="noreferrer">5. 最长回文子串</a> - 双指针 + DP</li><li><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noreferrer">76. 最小覆盖子串</a> - 滑动窗口 + 哈希表</li><li><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noreferrer">51. N 皇后</a> - 回溯 + 剪枝</li><li><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noreferrer">23. 合并 K 个升序链表</a> - 分治 + 递归</li></ul><hr><h2 id="十一、算法技巧选择指南" tabindex="-1">十一、算法技巧选择指南 <a class="header-anchor" href="#十一、算法技巧选择指南" aria-label="Permalink to &quot;十一、算法技巧选择指南&quot;">​</a></h2><p>遇到问题时，按以下思路选择算法：</p><ol><li><strong>数组/链表问题</strong> → 双指针</li><li><strong>连续子数组/子串</strong> → 滑动窗口</li><li><strong>树/图遍历</strong> → DFS/BFS</li><li><strong>最优解问题</strong> → 动态规划或贪心</li><li><strong>穷举所有可能</strong> → 回溯</li><li><strong>大问题拆解</strong> → 分治</li><li><strong>有序数组查找</strong> → 二分查找</li></ol><hr><h2 id="十二、学习建议" tabindex="-1">十二、学习建议 <a class="header-anchor" href="#十二、学习建议" aria-label="Permalink to &quot;十二、学习建议&quot;">​</a></h2><ol><li><strong>先理解思想，再刷题</strong>：掌握每种算法的核心思想和适用场景</li><li><strong>从简单题开始</strong>：每种算法先做 2-3 道简单题，理解模板</li><li><strong>总结模板</strong>：整理每种算法的通用模板，形成肌肉记忆</li><li><strong>举一反三</strong>：做完一道题，思考能否用其他方法解决</li><li><strong>定期复习</strong>：算法需要反复练习，定期回顾经典题目</li></ol><hr><h2 id="十三、参考资源" tabindex="-1">十三、参考资源 <a class="header-anchor" href="#十三、参考资源" aria-label="Permalink to &quot;十三、参考资源&quot;">​</a></h2><ul><li><a href="https://leetcode.cn/" target="_blank" rel="noreferrer">LeetCode 算法题单</a></li><li><a href="https://programmercarl.com/" target="_blank" rel="noreferrer">代码随想录</a></li><li><a href="https://labuladong.github.io/algo/" target="_blank" rel="noreferrer">labuladong 的算法小抄</a></li></ul><hr><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这些算法技巧是解决算法题的&quot;核心工具&quot;，刷题时遇到问题，先判断属于哪类场景，再用对应的技巧解决即可。记住：<strong>理解思想 &gt; 记忆代码</strong>，掌握核心思路后，代码实现就是水到渠成的事情。</p></div></div></main><footer class="VPDocFooter" data-v-87c78cff data-v-156be078><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-156be078><span class="visually-hidden" id="doc-footer-aria-label" data-v-156be078>Pager</span><div class="pager" data-v-156be078><a class="VPLink link pager-link prev" href="/ds-algo/notes/02-05-heap-implementation.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Previous page</span><span class="title" data-v-156be078>堆实现详解</span><!--]--></a></div><div class="pager" data-v-156be078><a class="VPLink link pager-link next" href="/ds-algo/notes/03-01-two-pointers.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Next page</span><span class="title" data-v-156be078>双指针详解</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"BEzItQig\",\"index.md\":\"B4ycJzSv\",\"markdown-examples.md\":\"C6Br5WQ0\",\"notes_01-prepare.md\":\"CWdzl9k_\",\"notes_01-structure.md\":\"BiG0xj3J\",\"notes_02-01-linked-list-implementation.md\":\"DaJw558a\",\"notes_02-02-hash-table-implementation.md\":\"C91ApNil\",\"notes_02-03-stack-queue-implementation.md\":\"CdBHuB1g\",\"notes_02-04-binary-tree-implementation.md\":\"BKjoZpvX\",\"notes_02-04-binary-tree-optimized.md\":\"yNCeGoY4\",\"notes_02-05-heap-implementation.md\":\"BTA0i6Jn\",\"notes_02-data-structures.md\":\"BM87vHyD\",\"notes_03-01-basic-exercise.md\":\"C2Q82BwY\",\"notes_03-01-strarr-exercise.md\":\"xTH0sqH_\",\"notes_03-01-two-pointers.md\":\"B3W6fSVu\",\"notes_03-02-sliding-window.md\":\"CRVtcW0S\",\"notes_03-04-dp1.md\":\"CpNakAf-\",\"notes_03-04-dp2.md\":\"BW3PdaI5\",\"notes_03-04-dp3.md\":\"DW2E5wU8\",\"notes_03-04-dp4.md\":\"23g9qSUp\",\"notes_03-04-dp44.md\":\"C2H22XJT\",\"notes_03-algorithms.md\":\"D4bWd1I_\",\"notes_04-binary-search.md\":\"CvJKxSaH\",\"notes_04-frontend.md\":\"D0SU1fUs\",\"notes_05-backtrack.md\":\"CzKeP1XF\",\"notes_catalan.md\":\"TR2oXnOe\",\"notes_dp-frontend-blog.md\":\"9lL0Xhgy\",\"notes_leetcode.md\":\"NLtkdwYT\",\"notes_route_0_map.md\":\"CeyDbeaK\",\"notes_route_1s-1-array.md\":\"D66JGtu1\",\"notes_route_1s-2-link-self.md\":\"C5h0t4gA\",\"notes_route_1s-2-link.md\":\"BtHyGlD8\",\"notes_route_1s-3-hashtable.md\":\"BuT03oij\",\"notes_route_1s-3-queuestack.md\":\"ZQty3b86\",\"notes_route_1s-4-binarytree.md\":\"Btiky_rn\",\"notes_route_1s-4-traversedc.md\":\"C24mqx0C\",\"notes_route_1s-5-searchtree.md\":\"BCejJqcD\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"数据结构与算法学习笔记\",\"description\":\"前端工程师的算法系统化学习指南\",\"base\":\"/ds-algo/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"学习笔记\",\"link\":\"/notes/01-prepare\"},{\"text\":\"刷题指南\",\"link\":\"/notes/leetcode\"}],\"sidebar\":{\"/notes/\":[{\"text\":\"前置准备\",\"link\":\"/notes/01-prepare\"},{\"text\":\"基础数据结构\",\"link\":\"/notes/02-data-structures\",\"items\":[{\"text\":\"数组 & 链表\",\"link\":\"/notes/02-data-structures#数组--链表\"},{\"text\":\"单向链表实现详解\",\"link\":\"/notes/02-01-linked-list-implementation\"},{\"text\":\"栈 & 队列\",\"link\":\"/notes/02-data-structures#栈--队列\"},{\"text\":\"栈 & 队列实现详解\",\"link\":\"/notes/02-03-stack-queue-implementation\"},{\"text\":\"哈希表\",\"link\":\"/notes/02-data-structures#哈希表\"},{\"text\":\"哈希表实现详解\",\"link\":\"/notes/02-02-hash-table-implementation\"},{\"text\":\"树 & 堆\",\"link\":\"/notes/02-data-structures#树--堆\"},{\"text\":\"二叉树实现详解\",\"link\":\"/notes/02-04-binary-tree-implementation\"},{\"text\":\"二叉树优化版实现\",\"link\":\"/notes/02-04-binary-tree-optimized\"},{\"text\":\"堆实现详解\",\"link\":\"/notes/02-05-heap-implementation\"}]},{\"text\":\"核心算法思想\",\"link\":\"/notes/03-algorithms\",\"items\":[{\"text\":\"算法思想总览\",\"link\":\"/notes/03-algorithms\"},{\"text\":\"双指针详解\",\"link\":\"/notes/03-01-two-pointers\"},{\"text\":\"动态规划\",\"collapsed\":false,\"items\":[{\"text\":\"DP基础：五部曲框架\",\"link\":\"/notes/03-04-dp1\"},{\"text\":\"DP进阶：背包问题\",\"link\":\"/notes/03-04-dp2\"},{\"text\":\"DP高级：完全背包变形\",\"link\":\"/notes/03-04-dp3\"},{\"text\":\"前端必备DP：10道经典题目\",\"link\":\"/notes/dp-frontend-blog\"}]}]},{\"text\":\"前端专项算法\",\"link\":\"/notes/04-frontend\"},{\"text\":\"LeetCode 刷题\",\"link\":\"/notes/leetcode\"}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/frontzhm/ds-algo\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>