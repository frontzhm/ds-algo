<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端算法必备：双指针从入门到很熟练（快慢指针+相向指针+滑动窗口） | 数据结构与算法学习笔记</title>
    <meta name="description" content="前端工程师的算法系统化学习指南">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/ds-algo/assets/style.B66l8Vrp.css" as="style">
    <link rel="preload stylesheet" href="/ds-algo/vp-icons.css" as="style">
    
    <script type="module" src="/ds-algo/assets/app.B10ddQOp.js"></script>
    <link rel="preload" href="/ds-algo/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/theme.fCM-gQVs.js">
    <link rel="modulepreload" href="/ds-algo/assets/chunks/framework.CRdajAWK.js">
    <link rel="modulepreload" href="/ds-algo/assets/notes_03-01-two-pointers.md.B3W6fSVu.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-6d407042><!--[--><!--]--><!--[--><span tabindex="-1" data-v-ba3da56b></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-ba3da56b>Skip to content</a><!--]--><!----><header class="VPNav" data-v-6d407042 data-v-d7238be4><div class="VPNavBar" data-v-d7238be4 data-v-8c571379><div class="wrapper" data-v-8c571379><div class="container" data-v-8c571379><div class="title" data-v-8c571379><div class="VPNavBarTitle has-sidebar" data-v-8c571379 data-v-980706ad><a class="title" href="/ds-algo/" data-v-980706ad><!--[--><!--]--><!----><span data-v-980706ad>数据结构与算法学习笔记</span><!--[--><!--]--></a></div></div><div class="content" data-v-8c571379><div class="content-body" data-v-8c571379><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8c571379><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8c571379 data-v-a2551964><span id="main-nav-aria-label" class="visually-hidden" data-v-a2551964> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/01-prepare.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>学习笔记</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/ds-algo/notes/leetcode.html" tabindex="0" data-v-a2551964 data-v-812e1d2c><!--[--><span data-v-812e1d2c>刷题指南</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8c571379 data-v-b2d09d06><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-b2d09d06 data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8c571379 data-v-71ee68fe data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8c571379 data-v-3b81dbff data-v-db67345a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-db67345a><span class="vpi-more-horizontal icon" data-v-db67345a></span></button><div class="menu" data-v-db67345a><div class="VPMenu" data-v-db67345a data-v-2d04c868><!----><!--[--><!--[--><!----><div class="group" data-v-3b81dbff><div class="item appearance" data-v-3b81dbff><p class="label" data-v-3b81dbff>Appearance</p><div class="appearance-action" data-v-3b81dbff><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3b81dbff data-v-c7167bae data-v-d9b02ede><span class="check" data-v-d9b02ede><span class="icon" data-v-d9b02ede><!--[--><span class="vpi-sun sun" data-v-c7167bae></span><span class="vpi-moon moon" data-v-c7167bae></span><!--]--></span></span></button></div></div></div><div class="group" data-v-3b81dbff><div class="item social-links" data-v-3b81dbff><div class="VPSocialLinks social-links-list" data-v-3b81dbff data-v-90891f1c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/frontzhm/ds-algo" aria-label="github" target="_blank" rel="noopener" data-v-90891f1c data-v-7f27ca5f><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8c571379 data-v-c7311208><span class="container" data-v-c7311208><span class="top" data-v-c7311208></span><span class="middle" data-v-c7311208></span><span class="bottom" data-v-c7311208></span></span></button></div></div></div></div><div class="divider" data-v-8c571379><div class="divider-line" data-v-8c571379></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-6d407042 data-v-81ec55a2><div class="container" data-v-81ec55a2><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-81ec55a2><span class="vpi-align-left menu-icon" data-v-81ec55a2></span><span class="menu-text" data-v-81ec55a2>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-81ec55a2 data-v-dfa7dd31><button data-v-dfa7dd31>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-6d407042 data-v-f5bdc5c7><div class="curtain" data-v-f5bdc5c7></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-f5bdc5c7><span class="visually-hidden" id="sidebar-aria-label" data-v-f5bdc5c7> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/01-prepare.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前置准备</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>基础数据结构</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%95%B0%E7%BB%84--%E9%93%BE%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>数组 & 链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-01-linked-list-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>单向链表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%88--%E9%98%9F%E5%88%97" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-03-stack-queue-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>栈 & 队列实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E5%93%88%E5%B8%8C%E8%A1%A8" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-02-hash-table-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>哈希表实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-data-structures.html#%E6%A0%91--%E5%A0%86" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>树 & 堆</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树实现详解</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-04-binary-tree-optimized.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>二叉树优化版实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/02-05-heap-implementation.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>堆实现详解</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0 is-link has-active" data-v-d59efcb4 data-v-fe5fc7a5><div class="item" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><h2 class="text" data-v-fe5fc7a5>核心算法思想</h2><!--]--></a><!----></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-algorithms.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>算法思想总览</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-01-two-pointers.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>双指针详解</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" role="button" tabindex="0" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><h3 class="text" data-v-fe5fc7a5>动态规划</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-fe5fc7a5><span class="vpi-chevron-right caret-icon" data-v-fe5fc7a5></span></div></div><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp1.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP基础：五部曲框架</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp2.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP进阶：背包问题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/03-04-dp3.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>DP高级：完全背包变形</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/dp-frontend-blog.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端必备DP：10道经典题目</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-d59efcb4><section class="VPSidebarItem level-0" data-v-d59efcb4 data-v-fe5fc7a5><!----><div class="items" data-v-fe5fc7a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/04-frontend.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>前端专项算法</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-fe5fc7a5 data-v-fe5fc7a5><div class="item" data-v-fe5fc7a5><div class="indicator" data-v-fe5fc7a5></div><a class="VPLink link link" href="/ds-algo/notes/leetcode.html" data-v-fe5fc7a5><!--[--><p class="text" data-v-fe5fc7a5>LeetCode 刷题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-6d407042 data-v-7ba754bd><div class="VPDoc has-sidebar has-aside" data-v-7ba754bd data-v-87c78cff><!--[--><!--]--><div class="container" data-v-87c78cff><div class="aside" data-v-87c78cff><div class="aside-curtain" data-v-87c78cff></div><div class="aside-container" data-v-87c78cff><div class="aside-content" data-v-87c78cff><div class="VPDocAside" data-v-87c78cff data-v-a4047630><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-a4047630 data-v-fc01bd9a><div class="content" data-v-fc01bd9a><div class="outline-marker" data-v-fc01bd9a></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-fc01bd9a>On this page</div><ul class="VPDocOutlineItem root" data-v-fc01bd9a data-v-d7fbdf5f><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-a4047630></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-87c78cff><div class="content-container" data-v-87c78cff><!--[--><!--]--><main class="main" data-v-87c78cff><div style="position:relative;" class="vp-doc _ds-algo_notes_03-01-two-pointers" data-v-87c78cff><div><h1 id="前端算法必备-双指针从入门到很熟练-快慢指针-相向指针-滑动窗口" tabindex="-1">前端算法必备：双指针从入门到很熟练（快慢指针+相向指针+滑动窗口） <a class="header-anchor" href="#前端算法必备-双指针从入门到很熟练-快慢指针-相向指针-滑动窗口" aria-label="Permalink to &quot;前端算法必备：双指针从入门到很熟练（快慢指针+相向指针+滑动窗口）&quot;">​</a></h1><h2 id="📑-目录" tabindex="-1">📑 目录 <a class="header-anchor" href="#📑-目录" aria-label="Permalink to &quot;📑 目录&quot;">​</a></h2><ul><li><a href="#一双指针是什么">一、双指针是什么？</a></li><li><a href="#二双指针的分类">二、双指针的分类</a><ul><li><a href="#21-快慢指针fast--slow-pointers">2.1 快慢指针</a></li><li><a href="#22-左右指针相向指针left--right-pointers">2.2 左右指针（相向指针）</a></li><li><a href="#23-同向指针滑动窗口sliding-window">2.3 同向指针（滑动窗口）</a><ul><li><a href="#231-滑动窗口与相向指针的相似性剪枝优化">2.3.1 滑动窗口与相向指针的相似性：剪枝优化</a></li></ul></li></ul></li><li><a href="#三快速判断什么时候用哪种双指针">三、快速判断：什么时候用哪种双指针？</a></li><li><a href="#四双指针的学习技巧">四、双指针的学习技巧</a></li><li><a href="#五刷题清单从基础到进阶">五、刷题清单：从基础到进阶</a><ul><li><a href="#前端必刷题目按难度和面试频次">前端必刷题目（按难度和面试频次）</a></li></ul></li><li><a href="#六常见错误和避坑点">六、常见错误和避坑点</a></li></ul><h2 id="一、双指针是什么" tabindex="-1">一、双指针是什么？ <a class="header-anchor" href="#一、双指针是什么" aria-label="Permalink to &quot;一、双指针是什么？&quot;">​</a></h2><p><strong>核心定义</strong>：用<strong>两个指针（索引）</strong> 遍历数据结构（数组/链表），通过指针的&quot;移动规则&quot;减少遍历次数，将时间复杂度从 O(n²) 优化到 O(n)。</p><p>简单说：不用嵌套循环遍历所有可能，而是用两个指针&quot;协作&quot;，一次遍历解决问题。</p><h2 id="二、双指针的分类" tabindex="-1">二、双指针的分类 <a class="header-anchor" href="#二、双指针的分类" aria-label="Permalink to &quot;二、双指针的分类&quot;">​</a></h2><p>双指针的核心是**&quot;指针的移动规则&quot;<strong>，不同规则对应不同场景。按照</strong>指针的移动方式和相对位置**，主要分为以下3大类：</p><table tabindex="0"><thead><tr><th>分类</th><th>指针位置</th><th>移动方式</th><th>核心特点</th><th>典型问题</th></tr></thead><tbody><tr><td><strong>快慢指针</strong></td><td>同一端出发</td><td>同向移动，速度不同</td><td>利用速度差制造相对位置</td><td>环检测、找中点、找倒数第k个</td></tr><tr><td><strong>左右指针（相向指针）</strong></td><td>两端出发</td><td>相向移动（向中间靠拢）</td><td>利用有序性缩小搜索范围</td><td>两数之和、回文判断、盛水容器</td></tr><tr><td><strong>同向指针（滑动窗口）</strong></td><td>同一端出发</td><td>同向移动，维护窗口</td><td>利用单调性压缩遍历维度</td><td>无重复子串、最小子数组、子数组计数</td></tr></tbody></table><blockquote><p>💡 <strong>说明</strong>：Vue3 diff 四个指针是左右指针的进阶应用，会在&quot;前端应用场景&quot;部分作为实际案例介绍。</p></blockquote><h3 id="_2-1-快慢指针-fast-slow-pointers" tabindex="-1">2.1 快慢指针（Fast &amp; Slow Pointers） <a class="header-anchor" href="#_2-1-快慢指针-fast-slow-pointers" aria-label="Permalink to &quot;2.1 快慢指针（Fast &amp; Slow Pointers）&quot;">​</a></h3><p>快慢指针（Fast &amp; Slow Pointers）本质是用两个步长不同的指针（如快指针走 2 步、慢指针走 1 步）遍历线性数据结构（链表 / 数组），核心解决「环检测、找中点、找倒数第 k 个元素」三类问题，优势是：空间复杂度从 O (n) 降到 O (1)，且无需额外容器（如哈希表）。</p><p><strong>指针位置</strong>：两个指针从<strong>同一端（通常是开头）</strong> 出发</p><p><strong>移动规则</strong>：快指针每次走2步，慢指针每次走1步（或其他&quot;速度差&quot;）</p><p><strong>适用场景</strong>：链表/数组的&quot;环形问题&quot;、&quot;找特定位置（中点 倒数k个点）&quot;</p><p><strong>核心原理</strong>：利用&quot;速度差&quot;制造&quot;相对位置&quot;——比如快指针先到终点，慢指针刚好在中间；或快指针追上慢指针，说明有环。</p><p><strong>核心模板</strong>：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快慢指针通用模板</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fastSlowPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 关键：循环条件确保快指针可以安全移动</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快指针走2步</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 慢指针走1步</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 根据具体问题判断</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1. 环检测：if (fast === slow) return true;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2. 找中点：循环结束后 slow 就是中点</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3. 找倒数第k个：先让 fast 走 k 步，再一起走</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或返回 slow（中点）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>经典场景+模板+例题</strong>：</p><h4 id="场景1-判断链表是否有环" tabindex="-1">场景1：判断链表是否有环 <a class="header-anchor" href="#场景1-判断链表是否有环" aria-label="Permalink to &quot;场景1：判断链表是否有环&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noreferrer">141. 环形链表</a></p><p>给你一个链表的头节点 <code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [3,2,0,-4], pos = 1</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第二个节点。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2], pos = 0</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第一个节点。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1], pos = -1</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：链表中没有环。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：快慢指针（Floyd 判圈算法）</strong></p><p>使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步。如果链表中存在环，快指针最终会追上慢指针（相遇）；如果没有环，快指针会先到达链表末尾（<code>null</code>）。</p><p><strong>为什么快慢指针能检测环？</strong></p><ol><li><strong>无环情况</strong>：快指针会先到达链表末尾，循环结束，返回 <code>false</code></li><li><strong>有环情况</strong>：快指针和慢指针都会进入环内 <ul><li>假设慢指针进入环时，快指针已经在环内某个位置</li><li>由于快指针每次比慢指针多走一步，它们之间的距离会逐渐缩小</li><li>最终快指针会追上慢指针（相遇），证明有环</li></ul></li></ol><p><strong>数学证明（为什么一定会相遇）：</strong></p><p>假设：</p><ul><li>环外长度为 <code>a</code>（从头节点到环入口的距离）</li><li>环长度为 <code>b</code></li><li>慢指针进入环时，快指针在环内距离入口 <code>c</code> 的位置（0 ≤ c &lt; b）</li></ul><p>当慢指针进入环时：</p><ul><li>慢指针位置：<code>a</code></li><li>快指针位置：<code>a + c</code></li><li>快慢指针距离：<code>c</code>（快指针在慢指针前面 <code>c</code> 步）</li></ul><p>由于快指针每次比慢指针多走 1 步，它们之间的距离每次减少 1：</p><ul><li>第 1 次移动后：距离变为 <code>c - 1</code></li><li>第 2 次移动后：距离变为 <code>c - 2</code></li><li>...</li><li>第 <code>c</code> 次移动后：距离变为 <code>0</code>（相遇）</li></ul><p>因此，最多经过 <code>c</code> 次移动（<code>c &lt; b</code>），快慢指针一定会相遇。</p><p><strong>代码实现：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasCycle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 快指针需要检查 fast 和 fast.next，避免空指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快指针走2步</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 慢指针走1步</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 相遇则有环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快指针到达末尾，无环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>初始化</strong>：快慢指针都从头节点开始</li><li><strong>循环条件</strong>：<code>fast &amp;&amp; fast.next</code> 确保快指针可以安全地移动两步</li><li><strong>移动规则</strong>：快指针每次移动 2 步，慢指针每次移动 1 步</li><li><strong>判断相遇</strong>：如果 <code>fast === slow</code>，说明两指针相遇，存在环</li><li><strong>无环情况</strong>：快指针到达 <code>null</code>，循环结束，返回 <code>false</code></li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是链表中节点的数量</p><ul><li>无环：快指针最多遍历 n 个节点</li><li>有环：快慢指针最多在环内相遇，时间复杂度仍为 O(n)</li></ul><p><strong>空间复杂度：</strong> O(1)，只使用了两个额外的指针</p><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>有环链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 3 (5指向3，形成环)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：fast = 1, slow = 1</span></span>
<span class="line"><span>第1步：fast = 3, slow = 2</span></span>
<span class="line"><span>第2步：fast = 5, slow = 3</span></span>
<span class="line"><span>第3步：fast = 4, slow = 4 (相遇！返回 true)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="场景2-找链表中间节点" tabindex="-1">场景2：找链表中间节点 <a class="header-anchor" href="#场景2-找链表中间节点" aria-label="Permalink to &quot;场景2：找链表中间节点&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/" target="_blank" rel="noreferrer">876. 链表的中间结点</a></p><p>给你单链表的头结点 <code>head</code>，请你找出并返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4,5]</span></span>
<span class="line"><span>输出：[3,4,5]</span></span>
<span class="line"><span>解释：链表只有一个中间结点，值为 3。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4,5,6]</span></span>
<span class="line"><span>输出：[4,5,6]</span></span>
<span class="line"><span>解释：该链表有两个中间结点，值分别为 3 和 4，返回第二个结点。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：快慢指针</strong></p><p>使用两个指针，快指针每次移动两步，慢指针每次移动一步。当快指针到达链表末尾时，慢指针刚好在中间位置。</p><p><strong>为什么慢指针在中间？</strong></p><ul><li>假设链表长度为 <code>n</code></li><li>快指针移动了 <code>n</code> 步（到达末尾）</li><li>慢指针移动了 <code>n/2</code> 步（刚好在中间）</li></ul><p><strong>偶数个节点的情况：</strong></p><ul><li>如果有 6 个节点，快指针移动 6 步到末尾，慢指针移动 3 步</li><li>由于题目要求&quot;两个中间结点返回第二个&quot;，所以返回慢指针指向的节点是正确的</li></ul><p><strong>代码实现：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> middleNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 快指针每次走2步，慢指针每次走1步</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 慢指针在中间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>循环条件</strong>：<code>fast &amp;&amp; fast.next</code> 确保快指针可以安全地移动两步</li><li><strong>移动规则</strong>：快指针移动 2 步，慢指针移动 1 步</li><li><strong>返回结果</strong>：慢指针指向的节点就是中间节点</li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是链表的节点数，需要遍历链表一次</p><p><strong>空间复杂度：</strong> O(1)，只使用了两个额外的指针</p><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：fast = 1, slow = 1</span></span>
<span class="line"><span>第1步：fast = 3, slow = 2</span></span>
<span class="line"><span>第2步：fast = 5, slow = 3</span></span>
<span class="line"><span>fast.next = null，循环结束</span></span>
<span class="line"><span>返回 slow = 3（中间节点）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="场景3-删除倒数第k个节点" tabindex="-1">场景3：删除倒数第k个节点 <a class="header-anchor" href="#场景3-删除倒数第k个节点" aria-label="Permalink to &quot;场景3：删除倒数第k个节点&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noreferrer">19. 删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4,5], n = 2</span></span>
<span class="line"><span>输出：[1,2,3,5]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1], n = 1</span></span>
<span class="line"><span>输出：[]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2], n = 1</span></span>
<span class="line"><span>输出：[1]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：快慢指针 + 虚拟头节点</strong></p><ol><li><strong>快指针先走 n 步</strong>：让快指针领先慢指针 n 个位置</li><li><strong>快慢指针同时移动</strong>：当快指针到达末尾时，慢指针刚好在倒数第 n+1 个节点</li><li><strong>删除节点</strong>：将慢指针的下一个节点删除</li></ol><p><strong>为什么慢指针在倒数第 n+1 个节点？</strong></p><ul><li>假设链表长度为 <code>L</code>，要删除倒数第 <code>n</code> 个节点</li><li>快指针先走 <code>n</code> 步，此时快指针在正数第 <code>n+1</code> 个节点</li><li>快慢指针同时移动，当快指针到达末尾（第 <code>L</code> 个节点）时</li><li>慢指针移动了 <code>L - n</code> 步，位于第 <code>L - n + 1</code> 个节点</li><li>第 <code>L - n + 1</code> 个节点就是倒数第 <code>n + 1</code> 个节点（因为 <code>L - (L - n + 1) + 1 = n + 1</code>）</li></ul><p><strong>边界情况处理：</strong></p><ul><li>如果 <code>fast</code> 为 <code>null</code>（快指针先走 n 步后为空），说明要删除的是头节点</li><li>直接返回 <code>head.next</code></li></ul><p><strong>代码实现：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeNthFromEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 快指针先跑n步</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果快指针为空，说明要删除的是头节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fast) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 快慢指针一起跑，快指针到终点时，慢指针在倒数第n+1个节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 删除倒数第n个节点（slow.next）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>快指针先走 n 步</strong>：建立快慢指针之间的相对位置</li><li><strong>边界检查</strong>：<code>if (!fast)</code> 处理删除头节点的情况</li><li><strong>循环条件</strong>：<code>fast.next</code> 确保慢指针停在倒数第 n+1 个节点</li><li><strong>删除操作</strong>：<code>slow.next = slow.next.next</code> 跳过要删除的节点</li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是链表的节点数，需要遍历链表一次</p><p><strong>空间复杂度：</strong> O(1)，只使用了两个额外的指针</p><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5，删除倒数第 2 个节点（4）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：fast = 1, slow = 1</span></span>
<span class="line"><span>快指针先走2步：fast = 3, slow = 1</span></span>
<span class="line"><span>快慢指针一起移动：</span></span>
<span class="line"><span>  第1步：fast = 4, slow = 2</span></span>
<span class="line"><span>  第2步：fast = 5, slow = 3</span></span>
<span class="line"><span>fast.next = null，循环结束</span></span>
<span class="line"><span>slow = 3（倒数第3个节点），slow.next = 4（要删除的节点）</span></span>
<span class="line"><span>删除：slow.next = slow.next.next，即 3.next = 5</span></span>
<span class="line"><span>结果：1 -&gt; 2 -&gt; 3 -&gt; 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_2-2-左右指针-相向指针-left-right-pointers" tabindex="-1">2.2 左右指针（相向指针，Left &amp; Right Pointers） <a class="header-anchor" href="#_2-2-左右指针-相向指针-left-right-pointers" aria-label="Permalink to &quot;2.2 左右指针（相向指针，Left &amp; Right Pointers）&quot;">​</a></h3><blockquote><p>🎯 <strong>交互演示</strong>：<a href="https://frontzhm.github.io/blog-demo/two-pointers-headtail.html" target="_blank" rel="noreferrer">点击这里查看动态演示</a> - 通过交互式可视化，直观看到每一步剪掉的组合！</p></blockquote><p>左右指针（Left &amp; Right Pointers）本质是用两个指针从「数组 / 字符串的两端」向中间移动，核心解决「有序数组 / 字符串的双值匹配、区间收缩、回文判断、区间最值」四类问题，优势是：将暴力枚举的 O(n²) 时间复杂度降到 O(n)，且空间复杂度 O(1)。</p><p><strong>指针位置</strong>：两个指针从<strong>两端（开头+结尾）</strong> 出发</p><p><strong>移动规则</strong>：根据条件向中间移动（比如&quot;左指针右移&quot;或&quot;右指针左移&quot;）</p><p><strong>适用场景</strong>：有序数组、回文、区间最值</p><p><strong>核心原理</strong>：利用&quot;两端向中间收缩&quot;的方式，缩小搜索范围，避免遍历所有组合。</p><p>满足以下任一条件，直接用左右指针：数据结构是数组 / 字符串（可随机访问），且是「有序」的；问题涉及「两端向中间匹配」（如回文、两数之和）；问题涉及「区间收缩 / 滑动窗口」（如去重、子串 / 子数组）；要求「O (n) 时间 + O (1) 空间」，且无需处理「环」相关问题。</p><p>抖音上有个<a href="https://v.douyin.com/gQhWu32_Wxg" target="_blank" rel="noreferrer">博主的视频</a> ，我觉得讲的很好，可以先看完，对相向有个可视化的认识，简单说，每次移动左指针和右指针，在脑海里，就会干掉了某一行或者某列表的组合，以此进行优化，本质是剪枝思想</p><p><strong>核心模板</strong>：</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 左右指针通用模板</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> leftRightPointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 关键：循环条件确保两个指针不会相遇</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 根据具体问题判断</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr[right]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或比较 arr[left] 和 arr[right]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足条件) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 找到答案或更新答案</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (需要增大) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 左指针右移</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 右指针左移</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>经典场景+模板+例题</strong>：</p><h4 id="场景1-有序数组两数之和" tabindex="-1">场景1：有序数组两数之和 <a class="header-anchor" href="#场景1-有序数组两数之和" aria-label="Permalink to &quot;场景1：有序数组两数之和&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noreferrer">167. 两数之和 II - 输入有序数组</a></p><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code>，该数组已按 <strong>非递减顺序排列</strong>，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code>，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong>，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：numbers = [2,7,11,15], target = 9</span></span>
<span class="line"><span>输出：[1,2]</span></span>
<span class="line"><span>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：numbers = [2,3,4], target = 6</span></span>
<span class="line"><span>输出：[1,3]</span></span>
<span class="line"><span>解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：numbers = [-1,0], target = -1</span></span>
<span class="line"><span>输出：[1,2]</span></span>
<span class="line"><span>解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：左右指针向中间收缩</strong></p><p>由于数组是有序的，可以利用这个特性：</p><ul><li>如果两数之和小于目标值，说明需要更大的数，左指针右移</li><li>如果两数之和大于目标值，说明需要更小的数，右指针左移</li><li>如果两数之和等于目标值，找到答案</li></ul><p><strong>为什么这样移动指针是正确的？</strong></p><blockquote><p>💡 <strong>提示</strong>：想要更直观地理解剪枝过程？<a href="https://frontzhm.github.io/blog-demo/two-pointers-headtail.html" target="_blank" rel="noreferrer">点击这里体验交互式演示</a>，每一步都能看到被剪掉的组合！</p></blockquote><p>这涉及到<strong>剪枝优化</strong>的核心思想。让我们用矩阵可视化来理解：</p><p><strong>第一步：理解暴力枚举的搜索空间</strong></p><p>暴力枚举需要检查所有可能的 <code>(i, j)</code> 组合，其中 <code>i &lt; j</code>。这形成了一个矩阵：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>所有可能的组合 (i, j)，其中 i &lt; j：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      j=0  1  2  3</span></span>
<span class="line"><span>i=0   -  01 02 03  ← 第0行</span></span>
<span class="line"><span>i=1   -  -  12 13  ← 第1行</span></span>
<span class="line"><span>i=2   -  -  -  23  ← 第2行</span></span>
<span class="line"><span>i=3   -  -  -  -   ← 第3行（空）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>总共有 N*(N-1)/2 = 4*3/2 = 6 个组合需要检查</span></span>
<span class="line"><span>时间复杂度：O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>第二步：双指针的剪枝策略</strong></p><p>假设当前 <code>left = 0</code>, <code>right = 3</code>，数组为 <code>[2, 7, 11, 15]</code>，<code>target = 9</code>。</p><p><strong>情况1：<code>sum &lt; target</code>（需要增大和）</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=0, right=3</span></span>
<span class="line"><span>当前和：sum = 2 + 15 = 17 &gt; 9（实际是 &gt; target，但先看 &lt; target 的情况）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>假设 sum = 2 + 7 = 9 &lt; target = 10（为了演示）：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3</span></span>
<span class="line"><span>i=0   -  [01] 02 03  ← 当前检查 (0,1)</span></span>
<span class="line"><span>i=1   -  -  12 13</span></span>
<span class="line"><span>i=2   -  -  -  23</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 sum &lt; target，那么：</span></span>
<span class="line"><span>- 对于固定的 left，所有 numbers[left] + numbers[j]（j &lt; right）都 &lt; target</span></span>
<span class="line"><span>- 因为数组有序，numbers[j] ≤ numbers[right]（j &lt; right）</span></span>
<span class="line"><span>- 所以可以剪掉第 left 行的所有剩余组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以剪掉第 left 行的剩余部分：</span></span>
<span class="line"><span>      j=0  1  2  3</span></span>
<span class="line"><span>i=0   -  [01] ✂️ ✂️  ← 剪掉整行！</span></span>
<span class="line"><span>i=1   -  -  12 13</span></span>
<span class="line"><span>i=2   -  -  -  23</span></span>
<span class="line"><span></span></span>
<span class="line"><span>移动 left++，跳过第0行的所有剩余组合</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p><strong>情况2：<code>sum &gt; target</code>（需要减小和）</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=0, right=3</span></span>
<span class="line"><span>当前和：sum = 2 + 15 = 17 &gt; 9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3</span></span>
<span class="line"><span>i=0   -  01 02 [03]  ← 当前检查 (0,3)</span></span>
<span class="line"><span>i=1   -  -  12 13</span></span>
<span class="line"><span>i=2   -  -  -  23</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 sum &gt; target，那么：</span></span>
<span class="line"><span>- 对于固定的 right，所有 numbers[i] + numbers[right]（i &gt; left）都 &gt; target</span></span>
<span class="line"><span>- 因为数组有序，numbers[i] ≥ numbers[left]（i &gt; left）</span></span>
<span class="line"><span>- 所以可以剪掉第 right 列的所有剩余组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以剪掉第 right 列的剩余部分：</span></span>
<span class="line"><span>      j=0  1  2  3</span></span>
<span class="line"><span>i=0   -  01 02 [03]</span></span>
<span class="line"><span>i=1   -  -  12 ✂️  ← 剪掉整列！</span></span>
<span class="line"><span>i=2   -  -  -  ✂️  ← 剪掉整列！</span></span>
<span class="line"><span></span></span>
<span class="line"><span>移动 right--，跳过第3列的所有剩余组合</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>第三步：剪枝效果可视化</strong></p><p>每次移动指针，都会剪掉<strong>整行</strong>或<strong>整列</strong>，大大减少搜索空间：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数组：[2, 7, 11, 15]，target = 9</span></span>
<span class="line"><span>初始：需要检查 6 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第1步：left=0, right=3, sum=2+15=17 &gt; 9</span></span>
<span class="line"><span>       移动 right--，剪掉第3列（2个组合）</span></span>
<span class="line"><span>       剩余：6 - 2 = 4 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第2步：left=0, right=2, sum=2+11=13 &gt; 9</span></span>
<span class="line"><span>       移动 right--，剪掉第2列（1个组合）</span></span>
<span class="line"><span>       剩余：4 - 1 = 3 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第3步：left=0, right=1, sum=2+7=9 = 9</span></span>
<span class="line"><span>       找到答案！</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终：只需要检查 O(n) 个组合，而不是 O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>数学证明：</strong></p><p>假设当前 <code>sum = numbers[left] + numbers[right]</code>：</p><ol><li><p><strong>如果 <code>sum &lt; target</code></strong>：</p><ul><li>由于数组有序，<code>numbers[left]</code> 是当前左区间的最小值</li><li>要增大和，只能让 <code>left++</code>（右移左指针）</li><li>如果右移右指针，和会变得更小，不符合要求</li><li><strong>剪枝效果</strong>：可以剪掉第 <code>left</code> 行的所有剩余组合</li></ul></li><li><p><strong>如果 <code>sum &gt; target</code></strong>：</p><ul><li>由于数组有序，<code>numbers[right]</code> 是当前右区间的最大值</li><li>要减小和，只能让 <code>right--</code>（左移右指针）</li><li>如果左移左指针，和会变得更大，不符合要求</li><li><strong>剪枝效果</strong>：可以剪掉第 <code>right</code> 列的所有剩余组合</li></ul></li></ol><p><strong>代码实现：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers[right];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 题目要求下标从1开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 太小，左指针右移（增大和）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 太大，右指针左移（减小和）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 未找到（题目保证有解，这里不会执行）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>循环条件</strong>：<code>left &lt; right</code> 确保两个指针不会相遇</li><li><strong>移动规则</strong>：根据和与目标值的大小关系决定移动哪个指针</li><li><strong>返回值</strong>：注意题目要求下标从 1 开始，所以返回 <code>[left + 1, right + 1]</code></li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是数组的长度，最多遍历数组一次</p><p><strong>空间复杂度：</strong> O(1)，只使用了两个额外的指针</p><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数组：[2, 7, 11, 15]，target = 9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：left = 0, right = 3</span></span>
<span class="line"><span>第1次：sum = 2 + 15 = 17 &gt; 9，right--，right = 2</span></span>
<span class="line"><span>第2次：sum = 2 + 11 = 13 &gt; 9，right--，right = 1</span></span>
<span class="line"><span>第3次：sum = 2 + 7 = 9 = 9，找到答案，返回 [1, 2]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="场景2-盛最多水的容器" tabindex="-1">场景2：盛最多水的容器 <a class="header-anchor" href="#场景2-盛最多水的容器" aria-label="Permalink to &quot;场景2：盛最多水的容器&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noreferrer">11. 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code>。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code>。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong> 你不能倾斜容器。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：[1,8,6,2,5,4,8,3,7]</span></span>
<span class="line"><span>输出：49</span></span>
<span class="line"><span>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：height = [1,1]</span></span>
<span class="line"><span>输出：1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：左右指针 + 贪心策略</strong></p><p>容器的面积由两个因素决定：</p><ol><li><strong>宽度</strong>：<code>right - left</code>（两指针之间的距离）</li><li><strong>高度</strong>：<code>Math.min(height[left], height[right])</code>（较矮的那条边）</li></ol><p><strong>贪心策略：移动较矮的边</strong></p><p>为什么移动较矮的边？这涉及到<strong>剪枝优化</strong>的核心思想。</p><blockquote><p>💡 <strong>提示</strong>：想要更直观地理解剪枝过程？<a href="https://frontzhm.github.io/blog-demo/two-pointers-headtail.html" target="_blank" rel="noreferrer">点击这里体验交互式演示</a>，选择&quot;盛最多水的容器&quot;问题，每一步都能看到被剪掉的组合！</p></blockquote><p>让我们用矩阵可视化来理解：</p><p><strong>第一步：理解暴力枚举的搜索空间</strong></p><p>暴力枚举需要检查所有可能的 <code>(i, j)</code> 组合，其中 <code>i &lt; j</code>。这形成了一个矩阵：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>所有可能的组合 (i, j)，其中 i &lt; j：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7  8</span></span>
<span class="line"><span>i=0   -  01 02 03 04 05 06 07 08  ← 第0行</span></span>
<span class="line"><span>i=1   -  -  12 13 14 15 16 17 18  ← 第1行</span></span>
<span class="line"><span>i=2   -  -  -  23 24 25 26 27 28  ← 第2行</span></span>
<span class="line"><span>i=3   -  -  -  -  34 35 36 37 38  ← 第3行</span></span>
<span class="line"><span>i=4   -  -  -  -  -  45 46 47 48  ← 第4行</span></span>
<span class="line"><span>i=5   -  -  -  -  -  -  56 57 58  ← 第5行</span></span>
<span class="line"><span>i=6   -  -  -  -  -  -  -  67 68  ← 第6行</span></span>
<span class="line"><span>i=7   -  -  -  -  -  -  -  -  78  ← 第7行</span></span>
<span class="line"><span>i=8   -  -  -  -  -  -  -  -  -   ← 第8行（空）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>总共有 N*(N-1)/2 = 9*8/2 = 36 个组合需要检查</span></span>
<span class="line"><span>时间复杂度：O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>第二步：双指针的剪枝策略</strong></p><p>假设当前 <code>left = 1</code>, <code>right = 3</code>，高度为 <code>height[1] = 8</code>, <code>height[3] = 2</code>。</p><p><strong>情况1：<code>height[left] &lt; height[right]</code>（当前：<code>height[1] = 8</code> &gt; <code>height[3] = 2</code>，不满足，但先看这个情况）</strong></p><p>如果 <code>height[left] &lt; height[right]</code>，比如 <code>height[1] = 2</code>, <code>height[3] = 8</code>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=1, right=3</span></span>
<span class="line"><span>当前面积：S = (3-1) * min(2, 8) = 2 * 2 = 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7  8</span></span>
<span class="line"><span>i=0   -  01 02 03 04 05 06 07 08</span></span>
<span class="line"><span>i=1   -  -  12 [13] 14 15 16 17 18  ← 当前检查 (1,3)</span></span>
<span class="line"><span>i=2   -  -  -  23 24 25 26 27 28</span></span>
<span class="line"><span>i=3   -  -  -  -  34 35 36 37 38</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 height[left] &lt; height[right]，那么：</span></span>
<span class="line"><span>- 所有 (left, left+1) ... (left, right-1) 的面积都 &lt; (left, right)</span></span>
<span class="line"><span>- 因为宽度更小，高度受限于 height[left]（或更小）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以剪掉第 left 行的剩余部分：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7  8</span></span>
<span class="line"><span>i=0   -  01 02 03 04 05 06 07 08</span></span>
<span class="line"><span>i=1   -  -  12 [13] ✂️ ✂️ ✂️ ✂️ ✂️ ✂️  ← 剪掉整行！</span></span>
<span class="line"><span>i=2   -  -  -  23 24 25 26 27 28</span></span>
<span class="line"><span>i=3   -  -  -  -  34 35 36 37 38</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>移动 left++，跳过第1行的所有剩余组合</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>情况2：<code>height[left] &gt; height[right]</code>（当前实际：<code>height[1] = 8</code> &gt; <code>height[3] = 2</code>）</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=1, right=3</span></span>
<span class="line"><span>当前面积：S = (3-1) * min(8, 2) = 2 * 2 = 4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7  8</span></span>
<span class="line"><span>i=0   -  01 02 03 04 05 06 07 08</span></span>
<span class="line"><span>i=1   -  -  12 [13] 14 15 16 17 18  ← 当前检查 (1,3)</span></span>
<span class="line"><span>i=2   -  -  -  23 24 25 26 27 28</span></span>
<span class="line"><span>i=3   -  -  -  -  34 35 36 37 38</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 height[left] &gt; height[right]，那么：</span></span>
<span class="line"><span>- 所有 (left+1, right) ... (right-1, right) 的面积都 &lt; (left, right)</span></span>
<span class="line"><span>- 因为宽度更小，高度受限于 height[right]（或更小）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以剪掉第 right 列的剩余部分：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7  8</span></span>
<span class="line"><span>i=0   -  01 02 03 04 05 06 07 08</span></span>
<span class="line"><span>i=1   -  -  12 [13] 14 15 16 17 18</span></span>
<span class="line"><span>i=2   -  -  -  ✂️  24 25 26 27 28  ← 剪掉整列！</span></span>
<span class="line"><span>i=3   -  -  -  ✂️  34 35 36 37 38  ← 剪掉整列！</span></span>
<span class="line"><span>      ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>移动 right--，跳过第3列的所有剩余组合</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>第三步：剪枝效果可视化</strong></p><p>每次移动指针，都会剪掉<strong>整行</strong>或<strong>整列</strong>，大大减少搜索空间：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始：需要检查 36 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第1步：left=0, right=8, height[0]=1 &lt; height[8]=7</span></span>
<span class="line"><span>       移动 left++，剪掉第0行（8个组合）</span></span>
<span class="line"><span>       剩余：36 - 8 = 28 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第2步：left=1, right=8, height[1]=8 &gt; height[8]=7</span></span>
<span class="line"><span>       移动 right--，剪掉第8列（7个组合）</span></span>
<span class="line"><span>       剩余：28 - 7 = 21 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第3步：left=1, right=7, height[1]=8 &gt; height[7]=3</span></span>
<span class="line"><span>       移动 right--，剪掉第7列（6个组合）</span></span>
<span class="line"><span>       剩余：21 - 6 = 15 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>... 继续剪枝</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终：只需要检查 O(n) 个组合，而不是 O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>数学证明：</strong></p><p>假设当前左右指针指向的高度为 <code>h[left]</code> 和 <code>h[right]</code>，且 <code>h[left] &lt; h[right]</code>：</p><ul><li>当前面积：<code>S = (right - left) * h[left]</code></li><li>如果移动右指针（较高的边）： <ul><li>新宽度：<code>right - left - 1</code>（减小）</li><li>新高度：<code>≤ h[left]</code>（受限于较矮的边）</li><li>新面积：<code>≤ (right - left - 1) * h[left] &lt; S</code>（一定更小）</li><li><strong>剪枝效果</strong>：可以剪掉第 <code>left</code> 行的所有剩余组合 <code>(left, left+1)</code> 到 <code>(left, right-1)</code></li></ul></li><li>如果移动左指针（较矮的边）： <ul><li>新宽度：<code>right - left - 1</code>（减小）</li><li>新高度：可能 <code>&gt; h[left]</code>（如果新的边更高）</li><li>新面积：可能更大</li><li><strong>剪枝效果</strong>：可以剪掉第 <code>right</code> 列的所有剩余组合 <code>(left+1, right)</code> 到 <code>(right-1, right)</code></li></ul></li></ul><p>因此，移动较矮的边是更优的选择，同时能剪掉整行或整列，实现 O(n) 时间复杂度。</p><blockquote><p>💡 <strong>提示</strong>：想要更直观地理解剪枝过程？<a href="https://frontzhm.github.io/blog-demo/two-pointers-headtail.html" target="_blank" rel="noreferrer">点击这里体验交互式演示</a>，选择&quot;盛最多水的容器&quot;问题，每一步都能看到被剪掉的组合！</p></blockquote><p><strong>代码实现：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxArea</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 计算当前面积：宽度 * 较矮的边</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> area</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(height[left], height[right]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max, area);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 移动较矮的边（贪心策略）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (height[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height[right]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 左指针右移</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 右指针左移</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>面积计算</strong>：<code>(right - left) * Math.min(height[left], height[right])</code></li><li><strong>移动策略</strong>：比较左右两边的高度，移动较矮的那一边</li><li><strong>更新最大值</strong>：每次计算面积后，更新 <code>max</code></li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是数组的长度，需要遍历数组一次</p><p><strong>空间复杂度：</strong> O(1)，只使用了两个额外的指针</p><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数组：[1,8,6,2,5,4,8,3,7]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：left = 0, right = 8, max = 0</span></span>
<span class="line"><span>第1次：area = (8-0) * min(1,7) = 8 * 1 = 8，max = 8</span></span>
<span class="line"><span>        height[0] &lt; height[8]，left++，left = 1</span></span>
<span class="line"><span>第2次：area = (8-1) * min(8,7) = 7 * 7 = 49，max = 49</span></span>
<span class="line"><span>        height[1] &gt; height[8]，right--，right = 7</span></span>
<span class="line"><span>第3次：area = (7-1) * min(8,3) = 6 * 3 = 18，max = 49</span></span>
<span class="line"><span>        height[1] &gt; height[7]，right--，right = 6</span></span>
<span class="line"><span>...继续移动，最终返回 max = 49</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="场景3-验证回文串" tabindex="-1">场景3：验证回文串 <a class="header-anchor" href="#场景3-验证回文串" aria-label="Permalink to &quot;场景3：验证回文串&quot;">​</a></h4><p><strong>题目描述：</strong> <a href="https://leetcode.cn/problems/valid-palindrome/" target="_blank" rel="noreferrer">125. 验证回文串</a></p><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong>。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong>，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入: s = &quot;A man, a plan, a canal: Panama&quot;</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：&quot;amanaplanacanalpanama&quot; 是回文串。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：s = &quot;race a car&quot;</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：&quot;raceacar&quot; 不是回文串。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：s = &quot; &quot;</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：s 是一个空字符串 &quot;&quot; 或者只包含空格，所以它是回文串。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解题思路详解：</strong></p><p><strong>核心思想：左右指针向中间收缩，逐字符比较</strong></p><ol><li><strong>预处理</strong>：移除所有非字母数字字符，转换为小写</li><li><strong>双指针比较</strong>：左右指针分别从两端向中间移动，逐字符比较</li><li><strong>判断回文</strong>：如果所有字符都匹配，则是回文串</li></ol><p><strong>优化版本（不预处理，边遍历边处理）：</strong></p><p>可以不用预处理，在遍历过程中跳过非字母数字字符，这样空间复杂度更优。</p><p><strong>代码实现（预处理版本）：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isPalindrome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 预处理：移除非字母数字字符，转换为小写</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">a-zA-Z0-9]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (s[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s[right]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>代码实现（优化版本，O(1) 空间）：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isPalindrome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 跳过非字母数字字符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[a-zA-Z0-9]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s[left])) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[a-zA-Z0-9]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s[right])) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 比较字符（转换为小写）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (s[left].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s[right].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>关键点解析：</strong></p><ol><li><strong>预处理</strong>：使用正则表达式 <code>/[^a-zA-Z0-9]/g</code> 移除非字母数字字符</li><li><strong>大小写处理</strong>：使用 <code>toLowerCase()</code> 统一转换为小写</li><li><strong>循环条件</strong>：<code>left &lt; right</code> 确保两个指针不会相遇</li><li><strong>字符比较</strong>：逐字符比较，发现不匹配立即返回 <code>false</code></li></ol><p><strong>时间复杂度：</strong> O(n)，其中 n 是字符串的长度，需要遍历字符串一次</p><p><strong>空间复杂度：</strong></p><ul><li>预处理版本：O(n)，需要创建新字符串</li><li>优化版本：O(1)，只使用了两个额外的指针</li></ul><p><strong>执行过程示例：</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>字符串：&quot;A man, a plan, a canal: Panama&quot;</span></span>
<span class="line"><span>预处理后：&quot;amanaplanacanalpanama&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>初始：left = 0, right = 20</span></span>
<span class="line"><span>第1次：s[0] = &#39;a&#39;, s[20] = &#39;a&#39;，匹配，left++, right--</span></span>
<span class="line"><span>第2次：s[1] = &#39;m&#39;, s[19] = &#39;m&#39;，匹配，left++, right--</span></span>
<span class="line"><span>...继续比较，所有字符都匹配</span></span>
<span class="line"><span>最终返回 true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-3-同向指针-滑动窗口-sliding-window" tabindex="-1">2.3 同向指针（滑动窗口，Sliding Window） <a class="header-anchor" href="#_2-3-同向指针-滑动窗口-sliding-window" aria-label="Permalink to &quot;2.3 同向指针（滑动窗口，Sliding Window）&quot;">​</a></h3><p><strong>指针位置</strong>：两个指针从<strong>同一端</strong>出发，同向移动</p><p><strong>移动规则</strong>：维护一个&quot;窗口&quot;，根据条件动态调整窗口大小</p><p><strong>适用场景</strong>：连续子数组/子串问题（固定长度或可变长度）</p><p><strong>核心原理</strong>：利用窗口状态的单调性，通过扩窗和缩窗跳过无效区间，将 O(n²) 优化到 O(n)。</p><blockquote><p>📖 <strong>详细内容</strong>：滑动窗口有独立的文档 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a>，包含完整的原理、模板和例题。本文只介绍核心思想和与相向指针的相似性。</p></blockquote><h4 id="_2-3-1-滑动窗口与相向指针的相似性-剪枝优化" tabindex="-1">2.3.1 滑动窗口与相向指针的相似性：剪枝优化 <a class="header-anchor" href="#_2-3-1-滑动窗口与相向指针的相似性-剪枝优化" aria-label="Permalink to &quot;2.3.1 滑动窗口与相向指针的相似性：剪枝优化&quot;">​</a></h4><p><strong>核心相似点</strong>：滑动窗口和相向指针都通过<strong>移动指针来&quot;干掉&quot;某些组合</strong>，实现从 O(n²) 到 O(n) 的优化。</p><p><strong>相向指针的剪枝</strong>（回顾）：</p><ul><li>移动左指针 → 剪掉第 <code>left</code> 行的所有剩余组合</li><li>移动右指针 → 剪掉第 <code>right</code> 列的所有剩余组合</li></ul><p><strong>滑动窗口的剪枝</strong>（同样原理）：</p><p>以&quot;无重复字符的最长子串&quot;为例，字符串 <code>s = &quot;abcabcbb&quot;</code>：</p><p><strong>第一步：理解暴力枚举的搜索空间</strong></p><p>暴力枚举需要检查所有可能的 <code>(i, j)</code> 组合，其中 <code>i ≤ j</code>。这形成了一个矩阵：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>所有可能的组合 (i, j)，其中 i ≤ j：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7</span></span>
<span class="line"><span>i=0   00 01 02 03 04 05 06 07  ← 第0行</span></span>
<span class="line"><span>i=1   -  11 12 13 14 15 16 17  ← 第1行</span></span>
<span class="line"><span>i=2   -  -  22 23 24 25 26 27  ← 第2行</span></span>
<span class="line"><span>i=3   -  -  -  33 34 35 36 37  ← 第3行</span></span>
<span class="line"><span>i=4   -  -  -  -  44 45 46 47  ← 第4行</span></span>
<span class="line"><span>i=5   -  -  -  -  -  55 56 57  ← 第5行</span></span>
<span class="line"><span>i=6   -  -  -  -  -  -  66 67  ← 第6行</span></span>
<span class="line"><span>i=7   -  -  -  -  -  -  -  77  ← 第7行</span></span>
<span class="line"><span></span></span>
<span class="line"><span>总共有 N*(N+1)/2 = 8*9/2 = 36 个组合需要检查</span></span>
<span class="line"><span>时间复杂度：O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>第二步：滑动窗口的剪枝策略</strong></p><p>假设当前 <code>left = 0</code>, <code>right = 3</code>，窗口 <code>[0,3] = &quot;abca&quot;</code> 包含重复字符 &#39;a&#39;。</p><p><strong>剪枝规则1：如果 <code>(left, right)</code> 存在重复字符，则 <code>(left, right+1...end)</code> 都存在重复字符</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=0, right=3</span></span>
<span class="line"><span>当前窗口：[0,3] = &quot;abca&quot;（存在重复字符 &#39;a&#39;）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7</span></span>
<span class="line"><span>i=0   00 01 02 [03] 04 05 06 07  ← 当前检查 (0,3)</span></span>
<span class="line"><span>i=1   -  11 12 13 14 15 16 17</span></span>
<span class="line"><span>i=2   -  -  22 23 24 25 26 27</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 (left, right) 存在重复字符，那么：</span></span>
<span class="line"><span>- 所有 (left, right+1) ... (left, end) 都包含重复字符</span></span>
<span class="line"><span>- 因为窗口 [left, right+1] 包含窗口 [left, right]，必然也重复</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以剪掉第 left 行的所有后续组合：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7</span></span>
<span class="line"><span>i=0   00 01 02 [03] ✂️ ✂️ ✂️ ✂️ ✂️  ← 剪掉整行！</span></span>
<span class="line"><span>i=1   -  11 12 13 14 15 16 17</span></span>
<span class="line"><span>i=2   -  -  22 23 24 25 26 27</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>移动 left++，跳过第0行的所有剩余组合</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>剪枝规则2：如果 <code>(left, right)</code> 不存在重复字符，则 <code>(left+1...right, right)</code> 也不存在重复字符</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>当前状态：left=0, right=2</span></span>
<span class="line"><span>当前窗口：[0,2] = &quot;abc&quot;（不存在重复字符）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>矩阵中当前检查的位置：</span></span>
<span class="line"><span>      j=0  1  2  3  4  5  6  7</span></span>
<span class="line"><span>i=0   00 01 [02] 03 04 05 06 07  ← 当前检查 (0,2)</span></span>
<span class="line"><span>i=1   -  11 12 13 14 15 16 17</span></span>
<span class="line"><span>i=2   -  -  22 23 24 25 26 27</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>剪枝逻辑：</span></span>
<span class="line"><span>如果 (left, right) 不存在重复字符，那么：</span></span>
<span class="line"><span>- 所有 (left+1, right) ... (right, right) 都不存在重复字符</span></span>
<span class="line"><span>- 因为窗口 [left+1, right] 是窗口 [left, right] 的子集</span></span>
<span class="line"><span></span></span>
<span class="line"><span>因此，可以继续扩展 right，探索更长的有效窗口</span></span>
<span class="line"><span>移动 right++，继续探索</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>第三步：剪枝效果可视化</strong></p><p>每次移动指针，都会剪掉<strong>整行</strong>或<strong>整列</strong>，大大减少搜索空间：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>字符串：&quot;abcabcbb&quot;</span></span>
<span class="line"><span>初始：需要检查 36 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第1步：left=0, right=0, 窗口=&quot;a&quot;（无重复）</span></span>
<span class="line"><span>       移动 right++，继续探索</span></span>
<span class="line"><span>       剩余：36 个组合（未剪枝，但只检查了1个）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第2步：left=0, right=1, 窗口=&quot;ab&quot;（无重复）</span></span>
<span class="line"><span>       移动 right++，继续探索</span></span>
<span class="line"><span>       剩余：36 个组合（未剪枝，但只检查了2个）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第3步：left=0, right=2, 窗口=&quot;abc&quot;（无重复）</span></span>
<span class="line"><span>       移动 right++，继续探索</span></span>
<span class="line"><span>       剩余：36 个组合（未剪枝，但只检查了3个）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第4步：left=0, right=3, 窗口=&quot;abca&quot;（有重复！）</span></span>
<span class="line"><span>       移动 left++，剪掉第0行的所有剩余组合（4个组合）</span></span>
<span class="line"><span>       剩余：36 - 4 = 32 个组合</span></span>
<span class="line"><span></span></span>
<span class="line"><span>第5步：left=1, right=3, 窗口=&quot;bca&quot;（无重复）</span></span>
<span class="line"><span>       移动 right++，继续探索</span></span>
<span class="line"><span>       剩余：32 个组合（未剪枝，但只检查了5个）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>... 继续剪枝</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最终：只需要检查 O(n) 个组合，而不是 O(n²)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><strong>核心思想总结</strong>：</p><ol><li><strong>相向指针</strong>：通过比较两端值，移动指针剪掉整行或整列</li><li><strong>滑动窗口</strong>：通过判断窗口状态，移动指针剪掉整行或整列</li><li><strong>共同点</strong>：每次移动指针，都会&quot;干掉&quot;某些组合，避免无效计算</li></ol><p><strong>分类</strong>：根据窗口大小是否固定，可分为：</p><ul><li><strong>固定窗口</strong>：窗口大小固定，两个指针同时移动</li><li><strong>可变窗口</strong>：窗口大小可变，根据条件动态调整（这才是真正的&quot;滑动窗口&quot;）</li></ul><blockquote><p>📖 <strong>详细内容</strong>：滑动窗口的完整原理、模板、例题和更多剪枝规则，请参考 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a></p></blockquote><h2 id="三、快速判断-什么时候用哪种双指针" tabindex="-1">三、快速判断：什么时候用哪种双指针？ <a class="header-anchor" href="#三、快速判断-什么时候用哪种双指针" aria-label="Permalink to &quot;三、快速判断：什么时候用哪种双指针？&quot;">​</a></h2><p>遇到问题时，按以下决策树快速判断：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>问题类型判断</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>├─ 是否涉及&quot;环&quot;或&quot;特定位置&quot;（中点、倒数第k个）？</span></span>
<span class="line"><span>│  └─ ✅ 快慢指针</span></span>
<span class="line"><span>│     - 环形链表检测</span></span>
<span class="line"><span>│     - 找链表中间节点</span></span>
<span class="line"><span>│     - 删除倒数第k个节点</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>├─ 是否涉及&quot;有序数组/字符串&quot;的&quot;两端匹配&quot;？</span></span>
<span class="line"><span>│  └─ ✅ 左右指针</span></span>
<span class="line"><span>│     - 两数之和（有序数组）</span></span>
<span class="line"><span>│     - 回文串判断</span></span>
<span class="line"><span>│     - 盛水容器（区间最值）</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>└─ 是否涉及&quot;连续子数组/子串&quot;问题？</span></span>
<span class="line"><span>   └─ ✅ 滑动窗口（同向指针）</span></span>
<span class="line"><span>      - 固定窗口：窗口大小固定</span></span>
<span class="line"><span>      - 可变窗口：窗口大小可变</span></span>
<span class="line"><span>      - 详见 [滑动窗口详解](https://juejin.cn/post/7593731473489690687)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>快速记忆口诀</strong>：</p><ul><li>🔄 <strong>快慢指针</strong>：速度差，找位置（环、中点、倒数k）</li><li>↔️ <strong>左右指针（相向指针）</strong>：两端向中间，有序数组/回文</li><li>➡️ <strong>同向指针（滑动窗口）</strong>：同一端出发，同向移动，维护窗口 <ul><li>通过移动指针剪掉整行或整列，实现 O(n²) → O(n) 优化</li><li>详见 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a></li></ul></li></ul><h2 id="四、双指针的学习技巧-必看" tabindex="-1">四、双指针的学习技巧（必看） <a class="header-anchor" href="#四、双指针的学习技巧-必看" aria-label="Permalink to &quot;四、双指针的学习技巧（必看）&quot;">​</a></h2><ol><li><p><strong>先记&quot;移动规则&quot;</strong>：不同分类的核心是&quot;指针怎么动&quot;——快慢指针是&quot;速度差&quot;，左右指针是&quot;向中间收缩&quot;，滑动窗口是&quot;同向移动维护窗口&quot;</p></li><li><p><strong>先刷&quot;模板题&quot;</strong>：每个分类先做2-3道简单题（比如先刷&quot;环形链表&quot;、&quot;两数之和II&quot;），熟练后再做变种</p></li><li><p><strong>注意&quot;边界条件&quot;</strong>：比如链表的<code>fast &amp;&amp; fast.next</code>（避免空指针）、数组的<code>left &lt; right</code>（避免越界）</p></li><li><p><strong>多总结&quot;适用场景&quot;</strong>：看到&quot;环形&quot;、&quot;倒数第k&quot;想快慢指针；看到&quot;有序数组&quot;、&quot;回文&quot;想左右指针；看到&quot;连续子数组/子串&quot;想滑动窗口</p></li><li><p><strong>掌握核心模板</strong>：每个分类都有固定模板，先背模板再刷题，事半功倍</p></li></ol><h2 id="五、刷题清单-从基础到进阶" tabindex="-1">五、刷题清单：从基础到进阶 <a class="header-anchor" href="#五、刷题清单-从基础到进阶" aria-label="Permalink to &quot;五、刷题清单：从基础到进阶&quot;">​</a></h2><p><strong>Day 1：快慢指针基础</strong></p><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noreferrer">141. 环形链表</a></li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/" target="_blank" rel="noreferrer">876. 链表的中间结点</a></li></ul><p><strong>Day 2：快慢指针进阶</strong></p><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noreferrer">142. 环形链表 II</a></li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noreferrer">19. 删除链表的倒数第 N 个结点</a></li></ul><p><strong>Day 3：左右指针基础</strong></p><ul><li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noreferrer">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode.cn/problems/valid-palindrome/" target="_blank" rel="noreferrer">125. 验证回文串</a></li></ul><p><strong>Day 4：左右指针进阶</strong></p><ul><li><a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noreferrer">11. 盛最多水的容器</a></li><li><a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noreferrer">344. 反转字符串</a></li></ul><p><strong>Day 5：固定窗口</strong></p><ul><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noreferrer">209. 长度最小的子数组</a></li><li>固定长度子数组的最大和（模板题）</li></ul><p><strong>Day 6：滑动窗口（进阶）</strong></p><ul><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noreferrer">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noreferrer">209. 长度最小的子数组</a></li><li>详见 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a></li></ul><hr><h2 id="前端必刷题目-按难度和面试频次" tabindex="-1">前端必刷题目（按难度和面试频次） <a class="header-anchor" href="#前端必刷题目-按难度和面试频次" aria-label="Permalink to &quot;前端必刷题目（按难度和面试频次）&quot;">​</a></h2><p>以下题目按难度和面试频次分类，建议优先刷高频题目：</p><h3 id="⭐-简单-高频-必刷" tabindex="-1">⭐ 简单-高频（必刷） <a class="header-anchor" href="#⭐-简单-高频-必刷" aria-label="Permalink to &quot;⭐ 简单-高频（必刷）&quot;">​</a></h3><p><strong>面试出现频率：★★★★★</strong> | <strong>难度：简单</strong></p><ul><li><a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noreferrer">344. 反转字符串</a> - 双指针基础</li><li><a href="https://leetcode.cn/problems/valid-palindrome/" target="_blank" rel="noreferrer">125. 验证回文串</a> - 相向指针经典题</li><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noreferrer">26. 删除有序数组中的重复项</a> - 快慢指针</li><li><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noreferrer">27. 移除元素</a> - 快慢指针</li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/" target="_blank" rel="noreferrer">876. 链表的中间结点</a> - 快慢指针找中点</li><li><a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noreferrer">141. 环形链表</a> - 快慢指针环检测</li></ul><h3 id="⭐⭐-简单-中频-推荐" tabindex="-1">⭐⭐ 简单-中频（推荐） <a class="header-anchor" href="#⭐⭐-简单-中频-推荐" aria-label="Permalink to &quot;⭐⭐ 简单-中频（推荐）&quot;">​</a></h3><p><strong>面试出现频率：★★★☆☆</strong> | <strong>难度：简单</strong></p><ul><li><a href="https://leetcode.cn/problems/reverse-string-ii/" target="_blank" rel="noreferrer">541. 反转字符串 II</a> - 字符串分段处理</li><li><a href="https://leetcode.cn/problems/valid-palindrome-ii/" target="_blank" rel="noreferrer">680. 验证回文串 II</a> - 容错验证</li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noreferrer">19. 删除链表的倒数第 N 个结点</a> - 快慢指针</li></ul><h3 id="⭐⭐⭐-中等-高频-必刷" tabindex="-1">⭐⭐⭐ 中等-高频（必刷） <a class="header-anchor" href="#⭐⭐⭐-中等-高频-必刷" aria-label="Permalink to &quot;⭐⭐⭐ 中等-高频（必刷）&quot;">​</a></h3><p><strong>面试出现频率：★★★★★</strong> | <strong>难度：中等</strong></p><ul><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noreferrer">3. 无重复字符的最长子串</a> - 滑动窗口经典题</li><li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noreferrer">167. 两数之和 II - 输入有序数组</a> - 相向指针经典题</li><li><a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noreferrer">11. 盛最多水的容器</a> - 相向指针+贪心</li><li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noreferrer">209. 长度最小的子数组</a> - 滑动窗口</li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noreferrer">142. 环形链表 II</a> - 快慢指针进阶</li></ul><h3 id="⭐⭐⭐⭐-中等-中频-推荐" tabindex="-1">⭐⭐⭐⭐ 中等-中频（推荐） <a class="header-anchor" href="#⭐⭐⭐⭐-中等-中频-推荐" aria-label="Permalink to &quot;⭐⭐⭐⭐ 中等-中频（推荐）&quot;">​</a></h3><p><strong>面试出现频率：★★★☆☆</strong> | <strong>难度：中等</strong></p><ul><li><a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noreferrer">151. 反转字符串中的单词</a> - 字符串处理</li><li><a href="https://leetcode.cn/problems/subarray-product-less-than-k/" target="_blank" rel="noreferrer">713. 乘积小于 K 的子数组</a> - 滑动窗口计数</li><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noreferrer">438. 找到字符串中所有字母异位词</a> - 固定窗口</li><li><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank" rel="noreferrer">567. 字符串的排列</a> - 固定窗口</li></ul><h3 id="⭐⭐⭐⭐⭐-困难-高频-进阶" tabindex="-1">⭐⭐⭐⭐⭐ 困难-高频（进阶） <a class="header-anchor" href="#⭐⭐⭐⭐⭐-困难-高频-进阶" aria-label="Permalink to &quot;⭐⭐⭐⭐⭐ 困难-高频（进阶）&quot;">​</a></h3><p><strong>面试出现频率：★★★★☆</strong> | <strong>难度：困难</strong></p><p>放弃也行，我觉得</p><ul><li><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noreferrer">42. 接雨水</a> - 相向指针+动态规划（进阶题）</li></ul><h2 id="六、常见错误和避坑点" tabindex="-1">六、常见错误和避坑点 <a class="header-anchor" href="#六、常见错误和避坑点" aria-label="Permalink to &quot;六、常见错误和避坑点&quot;">​</a></h2><h3 id="_6-1-快慢指针常见错误" tabindex="-1">6.1 快慢指针常见错误 <a class="header-anchor" href="#_6-1-快慢指针常见错误" aria-label="Permalink to &quot;6.1 快慢指针常见错误&quot;">​</a></h3><ol><li><p><strong>❌ 空指针检查缺失</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：没有检查 fast.next</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可能报错：Cannot read property &#39;next&#39; of null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：检查 fast 和 fast.next</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li><li><p><strong>❌ 快慢指针初始化错误</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：快慢指针从不同位置开始（某些场景需要，但大多数不需要）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.next;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：大多数情况从头节点开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p><strong>❌ 删除节点时未处理头节点</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：删除倒数第n个节点时，如果删除的是头节点，会出错</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeNthFromEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果 fast 为 null，说明要删除的是头节点，需要特殊处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fast) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 必须检查</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li></ol><h3 id="_6-2-左右指针常见错误" tabindex="-1">6.2 左右指针常见错误 <a class="header-anchor" href="#_6-2-左右指针常见错误" aria-label="Permalink to &quot;6.2 左右指针常见错误&quot;">​</a></h3><ol><li><p><strong>❌ 循环条件错误</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：使用 &lt;= 可能导致越界或重复计算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 某些场景下，left === right 时不应该继续</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：大多数情况使用 &lt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li><li><p><strong>❌ 指针移动方向错误</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：两数之和问题中，和太大时移动了左指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 错误：应该移动右指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：和太大时移动右指针（减小和）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li><li><p><strong>❌ 边界情况未处理</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：没有处理空数组或单元素数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">numbers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果 numbers.length === 0，right = -1，会出错</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ✅ 应该先检查边界</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ol><h3 id="_6-3-固定窗口常见错误" tabindex="-1">6.3 固定窗口常见错误 <a class="header-anchor" href="#_6-3-固定窗口常见错误" aria-label="Permalink to &quot;6.3 固定窗口常见错误&quot;">​</a></h3><ol><li><p><strong>❌ 窗口初始化错误</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：没有先计算第一个窗口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[right] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// right &lt; k 时会出错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 正确：先计算第一个窗口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k; right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[right] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  max </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(max, sum);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li><li><p><strong>❌ 窗口大小检查缺失</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误：没有检查 k 是否大于数组长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxSubarraySum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">k</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果 k &gt; nums.length，应该返回错误或特殊值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 应该检查</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol><h3 id="_6-4-通用避坑点" tabindex="-1">6.4 通用避坑点 <a class="header-anchor" href="#_6-4-通用避坑点" aria-label="Permalink to &quot;6.4 通用避坑点&quot;">​</a></h3><ol><li><strong>边界条件处理</strong>：空数组、单元素、全相同元素、全负数等</li><li><strong>索引越界</strong>：确保指针移动后不会越界</li><li><strong>初始化值</strong>：根据问题类型选择合适的初始值（0、Infinity、-Infinity等）</li><li><strong>循环条件</strong>：仔细考虑 <code>while</code> vs <code>for</code>，<code>&lt;</code> vs <code>&lt;=</code></li><li><strong>指针移动时机</strong>：确保在正确的时机移动指针</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>双指针是<strong>数组/链表问题的&quot;最优解工具&quot;</strong>，掌握这3类分类+对应的模板，90%的双指针题都能解决。核心是理解&quot;指针的移动规则&quot;，然后根据问题特点选择合适的分类。</p><h3 id="核心要点回顾" tabindex="-1">核心要点回顾 <a class="header-anchor" href="#核心要点回顾" aria-label="Permalink to &quot;核心要点回顾&quot;">​</a></h3><ol><li><strong>快慢指针</strong>：速度差，解决环检测、找中点、找倒数第k个问题</li><li><strong>左右指针（相向指针）</strong>：两端向中间，通过移动指针剪掉整行或整列，解决有序数组匹配、回文、区间最值问题</li><li><strong>同向指针（滑动窗口）</strong>：同一端出发，同向移动，通过移动指针剪掉整行或整列，解决连续子数组/子串问题（详见 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a>）</li></ol><h3 id="学习路径建议" tabindex="-1">学习路径建议 <a class="header-anchor" href="#学习路径建议" aria-label="Permalink to &quot;学习路径建议&quot;">​</a></h3><ol><li><strong>基础阶段</strong>：先掌握快慢指针和左右指针的3-5道模板题</li><li><strong>进阶阶段</strong>：学习滑动窗口（详见 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a>）</li><li><strong>实战阶段</strong>：结合前端应用场景，解决实际问题</li><li><strong>总结阶段</strong>：整理错题，总结避坑点，形成自己的模板库</li></ol><h3 id="相关资源" tabindex="-1">相关资源 <a class="header-anchor" href="#相关资源" aria-label="Permalink to &quot;相关资源&quot;">​</a></h3><ul><li>📖 <a href="https://juejin.cn/post/7593731473489690687" target="_blank" rel="noreferrer">滑动窗口详解</a> - 双指针的重要应用</li><li>💻 <a href="https://leetcode.cn/tag/two-pointers/" target="_blank" rel="noreferrer">LeetCode 双指针专题</a> - 刷题练习</li></ul></div></div></main><footer class="VPDocFooter" data-v-87c78cff data-v-156be078><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-156be078><span class="visually-hidden" id="doc-footer-aria-label" data-v-156be078>Pager</span><div class="pager" data-v-156be078><a class="VPLink link pager-link prev" href="/ds-algo/notes/03-algorithms.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Previous page</span><span class="title" data-v-156be078>核心算法思想</span><!--]--></a></div><div class="pager" data-v-156be078><a class="VPLink link pager-link next" href="/ds-algo/notes/03-04-dp1.html" data-v-156be078><!--[--><span class="desc" data-v-156be078>Next page</span><span class="title" data-v-156be078>DP基础：五部曲框架</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"BEzItQig\",\"index.md\":\"B4ycJzSv\",\"markdown-examples.md\":\"C6Br5WQ0\",\"notes_01-prepare.md\":\"CWdzl9k_\",\"notes_01-structure.md\":\"BiG0xj3J\",\"notes_02-01-linked-list-implementation.md\":\"DaJw558a\",\"notes_02-02-hash-table-implementation.md\":\"C91ApNil\",\"notes_02-03-stack-queue-implementation.md\":\"CdBHuB1g\",\"notes_02-04-binary-tree-implementation.md\":\"BKjoZpvX\",\"notes_02-04-binary-tree-optimized.md\":\"yNCeGoY4\",\"notes_02-05-heap-implementation.md\":\"BTA0i6Jn\",\"notes_02-data-structures.md\":\"BM87vHyD\",\"notes_03-01-basic-exercise.md\":\"C2Q82BwY\",\"notes_03-01-strarr-exercise.md\":\"xTH0sqH_\",\"notes_03-01-two-pointers.md\":\"B3W6fSVu\",\"notes_03-02-sliding-window.md\":\"CRVtcW0S\",\"notes_03-04-dp1.md\":\"CpNakAf-\",\"notes_03-04-dp2.md\":\"BW3PdaI5\",\"notes_03-04-dp3.md\":\"DW2E5wU8\",\"notes_03-04-dp4.md\":\"23g9qSUp\",\"notes_03-04-dp44.md\":\"C2H22XJT\",\"notes_03-algorithms.md\":\"D4bWd1I_\",\"notes_04-binary-search.md\":\"CvJKxSaH\",\"notes_04-frontend.md\":\"D0SU1fUs\",\"notes_05-backtrack.md\":\"CzKeP1XF\",\"notes_catalan.md\":\"TR2oXnOe\",\"notes_dp-frontend-blog.md\":\"9lL0Xhgy\",\"notes_leetcode.md\":\"NLtkdwYT\",\"notes_route_0_map.md\":\"CeyDbeaK\",\"notes_route_1s-1-array.md\":\"D66JGtu1\",\"notes_route_1s-2-link-self.md\":\"C5h0t4gA\",\"notes_route_1s-2-link.md\":\"BtHyGlD8\",\"notes_route_1s-3-hashtable.md\":\"BuT03oij\",\"notes_route_1s-3-queuestack.md\":\"ZQty3b86\",\"notes_route_1s-4-binarytree.md\":\"Btiky_rn\",\"notes_route_1s-4-q1.md\":\"BL-DIsA1\",\"notes_route_1s-4-q2.md\":\"EvsgWRa0\",\"notes_route_1s-4-traversedc.md\":\"C24mqx0C\",\"notes_route_1s-5-rbtree.md\":\"BqVyE6mw\",\"notes_route_1s-5-searchtree.md\":\"2vGTKVMT\",\"notes_route_1s-6-gragh.md\":\"5hRUJgcj\",\"notes_route_2a-0-guide.md\":\"Bmuagw44\",\"notes_route_2a-1-link.md\":\"D7i8j7gx\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"数据结构与算法学习笔记\",\"description\":\"前端工程师的算法系统化学习指南\",\"base\":\"/ds-algo/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"学习笔记\",\"link\":\"/notes/01-prepare\"},{\"text\":\"刷题指南\",\"link\":\"/notes/leetcode\"}],\"sidebar\":{\"/notes/\":[{\"text\":\"前置准备\",\"link\":\"/notes/01-prepare\"},{\"text\":\"基础数据结构\",\"link\":\"/notes/02-data-structures\",\"items\":[{\"text\":\"数组 & 链表\",\"link\":\"/notes/02-data-structures#数组--链表\"},{\"text\":\"单向链表实现详解\",\"link\":\"/notes/02-01-linked-list-implementation\"},{\"text\":\"栈 & 队列\",\"link\":\"/notes/02-data-structures#栈--队列\"},{\"text\":\"栈 & 队列实现详解\",\"link\":\"/notes/02-03-stack-queue-implementation\"},{\"text\":\"哈希表\",\"link\":\"/notes/02-data-structures#哈希表\"},{\"text\":\"哈希表实现详解\",\"link\":\"/notes/02-02-hash-table-implementation\"},{\"text\":\"树 & 堆\",\"link\":\"/notes/02-data-structures#树--堆\"},{\"text\":\"二叉树实现详解\",\"link\":\"/notes/02-04-binary-tree-implementation\"},{\"text\":\"二叉树优化版实现\",\"link\":\"/notes/02-04-binary-tree-optimized\"},{\"text\":\"堆实现详解\",\"link\":\"/notes/02-05-heap-implementation\"}]},{\"text\":\"核心算法思想\",\"link\":\"/notes/03-algorithms\",\"items\":[{\"text\":\"算法思想总览\",\"link\":\"/notes/03-algorithms\"},{\"text\":\"双指针详解\",\"link\":\"/notes/03-01-two-pointers\"},{\"text\":\"动态规划\",\"collapsed\":false,\"items\":[{\"text\":\"DP基础：五部曲框架\",\"link\":\"/notes/03-04-dp1\"},{\"text\":\"DP进阶：背包问题\",\"link\":\"/notes/03-04-dp2\"},{\"text\":\"DP高级：完全背包变形\",\"link\":\"/notes/03-04-dp3\"},{\"text\":\"前端必备DP：10道经典题目\",\"link\":\"/notes/dp-frontend-blog\"}]}]},{\"text\":\"前端专项算法\",\"link\":\"/notes/04-frontend\"},{\"text\":\"LeetCode 刷题\",\"link\":\"/notes/leetcode\"}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/frontzhm/ds-algo\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>