我为你整理了**20道动态规划经典题的完整题目描述+测试实例**，格式清晰可直接复制到文档，按“基础递推→背包问题→字符串/子序列”三大模块分类，方便你逐个刷题：

### 一、基础递推型（6道）

#### 1. ✅使用最小花费爬楼梯（LeetCode 746）

**题目描述**：给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

**示例 1**：输入：`cost = [10, 15, 20]` 输出：`15` 解释：从下标为 1 的台阶开始，支付 15 ，爬两个台阶到达顶部，总花费 15。

**示例 2**：输入：`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]` 输出：`6` 解释：从下标 0 开始，依次经过 0→2→3→4→6→7→9，总花费 1+1+1+1+1+1=6。

```js
function d(cost) {
  const len = cost.length;
  // dp[i]是i个台阶的最低花费
  const dp = new Array(len);
  dp[0] = 0;
  dp[1] = 0;
  for (let i = 2; i <= len; i++) {
    const prevCost = cost[i - 1];
    const prevPrevCost = cost[i - 2];
    const vLastIsPrev = prevCost + dp[i - 1];
    const vLastIsPrevPrev = prevPrevCost + dp[i - 2];
    dp[i] = Math.min(vLastIsPrev, vLastIsPrevPrev);
  }
  return dp[len];
}
const cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1];
console.log(d(cost));
```

继续优化

```js
function minCostClimbingStairs(cost) {
  // 1. 先明确核心概念：
  // - cost数组：cost[i] 表示「第i级台阶」的攀爬费用（i从0开始）
  // - 楼顶位置：在cost数组最后一个元素的下一个位置（即第len级台阶的位置）
  //   比如cost长度为3（台阶0、1、2），楼顶在「第3级台阶」的位置
  const len = cost.length;

  // 2. 边界场景处理：
  // - 0个台阶（空数组）：楼顶就是0级台阶，花费0
  // - 1个台阶（cost=[x]）：从0级台阶直接爬1步到楼顶（1级台阶位置），无需付费，花费0
  if (len <= 1) return 0;

  // 3. 滚动变量定义（替代DP数组，空间压缩）：
  // - prevPrev：到达「第i-2级台阶位置」的最小花费（i是当前要计算的位置）
  // - prev：到达「第i-1级台阶位置」的最小花费
  //   初始值：可以从0级/1级台阶开始，所以到达0/1级台阶的花费都是0
  let prevPrev = 0; // 初始对应：到达0级台阶的花费
  let prev = 0; // 初始对应：到达1级台阶的花费

  // 4. 循环计算：从「第2级台阶位置」开始，直到「楼顶（第len级台阶位置）」
  //    i的含义：当前要计算的是「到达第i级台阶位置」的最小花费
  for (let i = 2; i <= len; i++) {
    // 5. 计算到达第i级位置的两种路径花费：
    // 路径1：从「第i-1级台阶」爬1步到第i级位置
    // - 先支付第i-1级台阶的费用cost[i-1]，再加上到达i-1级位置的最小花费prev
    const costFromPrevStep = cost[i - 1] + prev;

    // 路径2：从「第i-2级台阶」爬2步到第i级位置
    // - 先支付第i-2级台阶的费用cost[i-2]，再加上到达i-2级位置的最小花费prevPrev
    const costFromPrevTwoStep = cost[i - 2] + prevPrev;

    // 6. 取两种路径的最小值，就是到达第i级位置的最小花费
    const currentMinCost = Math.min(costFromPrevStep, costFromPrevTwoStep);

    // 7. 滚动更新变量（为下一次循环做准备）：
    // - 下一次循环要算i+1级位置，此时i-1级位置就变成了i-2级位置
    prevPrev = prev;
    // - 下一次循环的i-1级位置，就是当前计算的i级位置
    prev = currentMinCost;
  }

  // 8. 循环结束后，prev存储的是「到达第len级台阶位置（楼顶）」的最小花费
  return prev;
}

// 测试用例（对应题目场景，验证逻辑）
console.log(minCostClimbingStairs([10, 15, 20]));
// len=3 → 计算到i=3（楼顶），输出15（从1级台阶爬2步到楼顶，花费15）
console.log(minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]));
// len=10 → 计算到i=10（楼顶），输出6（对应题目示例2的路径）
console.log(minCostClimbingStairs([5])); // len=1 → 直接返回0（1个台阶，爬1步到楼顶无花费）
console.log(minCostClimbingStairs([])); // len=0 → 直接返回0（无台阶，楼顶就是起点）
```

---

#### 2. ✅打家劫舍（LeetCode 198）

**题目描述**：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组 `nums`，请计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**示例 1**：输入：`nums = [1,2,3,1]` 输出：`4` 解释：偷窃 1 号房屋（金额=1），偷窃 3 号房屋（金额=3），总金额 1+3=4。

**示例 2**：输入：`nums = [2,7,9,3,1]` 输出：`12` 解释：偷窃 1 号（2）→ 3 号（9）→ 5 号（1），总金额 2+9+1=12。

```js
function d(nums) {
  const len = nums.length;
  // dp[i]表示前i家能获取的最高金额
  // dp[i][0] = 前i家、第i家不偷的最高金额
  // dp[i][1] = 前i家、第i家偷的最高金额
  const dp = new Array(len + 1);
  // 初始化：前0家偷/不偷都是0
  dp[0] = [0, 0];

  for (let i = 1; i <= len; i++) {
    const curVal = nums[i - 1]; // 第i家对应的数组索引是i-1（易错点）
    // 状态1：第i家不偷 → 前i-1家偷或不偷都可以，取最大值
    const valNotThief = Math.max(...dp[i - 1]);
    // 状态2：第i家偷 → 前i-1家必须不偷，加上当前金额
    const valThief = curVal + dp[i - 1][0];
    // 更新当前状态
    dp[i] = [valNotThief, valThief];
  }
  // 最终结果：前len家偷/不偷的最大值
  return Math.max(...dp[len]);
}
```

仔细看 只依赖前一个，所以再优化下空间

```js
function d(nums) {
  const len = nums.length;

  let vNot = 0; // 前i家不偷的最大值
  let vYes = 0; // 前i家偷的最大值

  for (let i = 1; i <= len; i++) {
    const curVal = nums[i - 1];
    // 关键：提前保存上一轮的所有状态，避免更新时覆盖
    const prevNot = vNot;
    const prevYes = vYes;

    // 不偷当前家：上一轮偷/不偷的最大值
    vNot = Math.max(prevNot, prevYes);
    // 偷当前家：上一轮不偷的最大值 + 当前金额（严格遵守相邻不偷规则）
    vYes = curVal + prevNot;
  }
  return Math.max(vNot, vYes);
}
```

---

#### 3. ✅不同路径（LeetCode 62）

**题目描述**：一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。问总共有多少条不同的路径？

**示例 1**：输入：`m = 3, n = 7` 输出：`28`

**示例 2**：输入：`m = 3, n = 2` 输出：`3` 解释：从左上角开始，总共有 3 条路径可以到达右下角：

1. 向右 → 向下 → 向下
2. 向下 → 向下 → 向右
3. 向下 → 向右 → 向下

```js
function d(m, n) {
  // 状态定义：dp[i][j] 表示从左上角(1,1)走到网格(i,j)位置的不同路径数
  // 注：这里把网格下标从1开始（而非0），是为了避免处理i=0/j=0的边界，更直观
  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

  // 边界初始化1：第一行（i=1）所有位置，只能从左边一直向右走，路径数都是1
  // 比如(1,1)、(1,2)、(1,3)...(1,n)，都只有1条路径
  for (let j = 1; j <= n; j++) {
    dp[1][j] = 1;
  }

  // 边界初始化2：第一列（j=1）所有位置，只能从上边一直向下走，路径数都是1
  // 比如(1,1)、(2,1)、(3,1)...(m,1)，都只有1条路径
  for (let i = 1; i <= m; i++) {
    dp[i][1] = 1;
  }

  // 递推计算：从(2,2)开始，遍历所有非边界位置
  for (let i = 2; i <= m; i++) {
    for (let j = 2; j <= n; j++) {
      // 核心逻辑：走到(i,j)只有两种方式
      // 1. 从(i-1,j)向下走一步到达 → 路径数=dp[i-1][j]
      // 2. 从(i,j-1)向右走一步到达 → 路径数=dp[i][j-1]
      // 总路径数 = 两种方式的路径数之和
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // 返回：从(1,1)走到右下角(m,n)的总路径数
  return dp[m][n];
}

// 测试用例验证
console.log(d(3, 7)); // 输出28（正确，对应示例1）
console.log(d(3, 2)); // 输出3（正确，对应示例2）
```

```js
function d(m, n) {
  // 状态定义（一维优化）：
  // dp[j] 表示「当前遍历到第i行时」，走到第j列位置的路径数
  // 一维数组替代二维数组，复用空间，空间复杂度从O(m*n)→O(n)
  // 边界初始化：第一行（i=1）所有列j的路径数都是1
  const dp = new Array(n + 1).fill(1);

  // 递推计算：从第2行开始遍历每一行（i表示当前行）
  for (let i = 2; i <= m; i++) {
    // 从第2列开始遍历当前行的每一列（j表示当前列）
    // 注：j从2开始，因为第1列（j=1）的路径数永远是1（只能从上到下走），无需更新
    for (let j = 2; j <= n; j++) {
      // 核心逻辑（一维版）：
      // 1. dp[j]（更新前）：表示「上一行第j列」的路径数（对应二维的dp[i-1][j]）
      // 2. dp[j-1]（更新后）：表示「当前行第j-1列」的路径数（对应二维的dp[i][j-1]）
      // 总路径数 = 从上边来的路径数 + 从左边来的路径数
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  // 返回：走到第m行第n列（右下角）的总路径数
  return dp[n];
}

// 测试验证（完全正确）
console.log(d(3, 7)); // 28（示例1正确）
console.log(d(3, 2)); // 3（示例2正确）
```

---

#### 4. ✅最小路径和（LeetCode 64）

**题目描述**：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。

**示例 1**：输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]` 输出：`7` 解释：路径 1→3→1→1→1 总和最小。

**示例 2**：输入：`grid = [[1,2,3],[4,5,6]]` 输出：`12`

```js
function d(grid) {
  const m = grid.length; // 网格的行数
  const n = grid[0].length; // 网格的列数

  // 状态定义：dp[i][j] 表示从左上角(0,0)走到网格(i-1,j-1)位置的最小路径和
  // 注：dp数组下标从1开始，对应网格的0开始下标，避免处理i=0/j=0的边界
  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

  // 边界初始化1：第一行（dp[1][j]）→ 对应网格第一行（grid[0][j-1]）
  // 第一行只能从左到右走，所以dp[1][j] = 左边位置的最小和 + 当前网格值
  for (let j = 1; j <= n; j++) {
    dp[1][j] = dp[1][j - 1] + grid[0][j - 1];
  }

  // 边界初始化2：第一列（dp[i][1]）→ 对应网格第一列（grid[i-1][0]）
  // 第一列只能从上到下走，i从2开始（i=1已在第一行初始化过）
  for (let i = 2; i <= m; i++) {
    dp[i][1] = dp[i - 1][1] + grid[i - 1][0];
  }

  // 递推计算：从(2,2)开始遍历所有非边界位置
  for (let i = 2; i <= m; i++) {
    for (let j = 2; j <= n; j++) {
      // 当前网格的值（dp[i][j]对应grid[i-1][j-1]）
      const curVal = grid[i - 1][j - 1];
      // 核心逻辑：走到(i,j)的最小路径和 = min(从上边来的和, 从左边来的和) + 当前网格值
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + curVal;
    }
  }

  // 返回：走到网格右下角(m-1,n-1)的最小路径和（对应dp[m][n]）
  return dp[m][n];
}

// 测试用例验证
console.log(
  d([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ])
); // 输出7（示例1正确）
console.log(
  d([
    [1, 2, 3],
    [4, 5, 6],
  ])
); // 输出12（示例2正确）
```

```js
function d(grid) {
  const m = grid.length; // 网格的行数
  const n = grid[0].length; // 网格的列数

  // 状态定义（一维优化）：
  // dp[j] 表示「当前遍历到第i行时」，走到第j列位置的最小路径和
  // 一维数组替代二维数组，空间复杂度从O(m*n)→O(n)
  const dp = new Array(n + 1).fill(0);

  // 边界初始化：第一行（i=1）所有列j的最小路径和
  // 第一行只能从左到右走，所以dp[j] = 左边位置的和 + 当前网格值
  for (let j = 1; j <= n; j++) {
    dp[j] = dp[j - 1] + grid[0][j - 1];
  }

  // 递推计算：从第2行开始遍历每一行（i表示当前行）
  for (let i = 2; i <= m; i++) {
    // 遍历当前行的每一列（j从1开始，覆盖第一列和其他列）
    for (let j = 1; j <= n; j++) {
      // 处理当前行的第一列（j=1）：只能从上一行的第一列向下走
      if (j === 1) {
        dp[j] = dp[j] + grid[i - 1][0]; // dp[j]（旧值）= 上一行第一列的和
        continue;
      }
      // 非第一列：取「从上边来（旧dp[j]）」和「从左边来（新dp[j-1]）」的最小值 + 当前网格值
      const curVal = grid[i - 1][j - 1]; // 当前网格的实际值
      dp[j] = Math.min(dp[j], dp[j - 1]) + curVal;
    }
  }

  // 返回：走到最后一行最后一列（右下角）的最小路径和
  return dp[n];
}

// 测试用例验证（完全正确）
console.log(
  d([
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
  ])
); // 7（示例1正确）
console.log(
  d([
    [1, 2, 3],
    [4, 5, 6],
  ])
); // 12（示例2正确）
```

---

#### 5. ✅不同路径 II（LeetCode 63）

**题目描述**：一个机器人位于一个 `m x n` 网格的左上角（起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1**：输入：`obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]` 输出：`2` 解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：

1. 向右 → 向右 → 向下 → 向下
2. 向下 → 向下 → 向右 → 向右

**示例 2**：输入：`obstacleGrid = [[0,1],[0,0]]` 输出：`1`

```js
/**
 * 不同路径 II（二维DP版本）
 * 计算从网格左上角到右下角的不同路径数，网格中可能存在障碍物
 *
 * @param {number[][]} obstacleGrid - 网格数组，0表示空位置，1表示障碍物
 * @returns {number} 从左上角到右下角的不同路径数
 *
 * 思路：
 * 1. dp[i][j] 表示从起点 (0,0) 到达位置 (i-1,j-1) 的不同路径数
 * 2. 如果当前位置是障碍物，则 dp[i][j] = 0
 * 3. 否则，dp[i][j] = dp[i-1][j] + dp[i][j-1]（从上方或左方到达）
 * 4. 边界条件：第一行和第一列一旦遇到障碍物，后续位置都无法到达
 */
function uniquePathsWithObstacles(obstacleGrid) {
  const m = obstacleGrid.length; // 网格行数
  const n = obstacleGrid[0].length; // 网格列数

  // 创建DP数组：dp[i][j] 表示从起点到达位置 (i-1,j-1) 的路径数
  // 使用 (m+1) x (n+1) 的数组，索引从1开始，便于处理边界
  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

  // ========== 初始化第一行 ==========
  // 第一行只能从左边到达，一旦遇到障碍物，后续位置都无法到达
  for (let j = 1; j <= n; j++) {
    const curGrid = obstacleGrid[1 - 1][j - 1]; // 获取网格中的实际值（索引转换）
    const curIsObstacle = curGrid === 1; // 判断是否为障碍物

    if (!curIsObstacle) {
      // 不是障碍物，可以到达，路径数为1（只能从左边来）
      dp[1][j] = 1;
      console.log(1, j, dp[1][j]);
      continue;
    }
    // 遇到障碍物，后续位置都无法到达，直接跳出循环
    break;
  }

  // ========== 初始化第一列 ==========
  // 第一列只能从上方到达，一旦遇到障碍物，后续位置都无法到达
  // 注意：从 i=2 开始，因为 dp[1][1] 已经在第一行初始化时处理了
  for (let i = 2; i <= m; i++) {
    const curGrid = obstacleGrid[i - 1][1 - 1]; // 获取网格中的实际值（索引转换）
    const curIsObstacle = curGrid === 1; // 判断是否为障碍物

    if (!curIsObstacle) {
      // 不是障碍物，可以到达，路径数为1（只能从上方来）
      dp[i][1] = 1;
      console.log(i, 1, dp[i][1]);
      continue;
    }
    // 遇到障碍物，后续位置都无法到达，直接跳出循环
    break;
  }

  // ========== 填充DP数组 ==========
  // 从第2行第2列开始填充（第1行和第1列已经初始化完成）
  for (let i = 2; i <= m; i++) {
    for (let j = 2; j <= n; j++) {
      const curGrid = obstacleGrid[i - 1][j - 1]; // 获取网格中的实际值（索引转换）
      const curIsObstacle = curGrid === 1; // 判断是否为障碍物

      if (curIsObstacle) {
        // 当前位置是障碍物，无法到达，路径数为0
        dp[i][j] = 0;
        continue;
      }

      // 当前位置不是障碍物，可以从上方或左方到达
      // 路径数 = 从上方到达的路径数 + 从左方到达的路径数
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // 返回从起点到达终点的路径数
  return dp[m][n];
}

// 测试用例
console.log(
  uniquePathsWithObstacles([
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0],
  ])
); // 输出：2
```

```js
function uniquePathsWithObstacles(obstacleGrid) {
  // 获取网格总行数（m）和总列数（n）
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;

  // 一维DP数组定义：
  // dp[j] 表示「遍历到第i行时」，到达网格第j列位置的路径数
  // 数组长度n+1，索引从1开始，避免处理j=0的边界问题
  const dp = new Array(n + 1).fill(0);

  // ========== 初始化第一行（网格第1行，对应i=1） ==========
  // 核心规则：第一行只能从左到右走，遇障碍物则后续列均无法到达
  for (let j = 1; j <= n; j++) {
    // 网格下标转换：dp[j] 对应网格(0, j-1)（第一行第j列）
    const curGrid = obstacleGrid[0][j - 1];
    const curIsObstacle = curGrid === 1; // 1=障碍物，0=可通行

    // 非障碍物：路径数置1（第一行无上方路径，仅能从左侧来）
    if (!curIsObstacle) {
      dp[j] = 1;
      continue;
    }
    // 遇到障碍物：终止循环，后续列dp[j]保持初始0（无法到达）
    break;
  }

  // 调试日志：打印初始化后的dp数组、网格行列数（可按需删除）
  console.log(dp);
  console.log(m, n);

  // ========== 递推计算后续行（从网格第2行开始，对应i=2） ==========
  // 外层循环：遍历网格第2行到第m行
  for (let i = 2; i <= m; i++) {
    // 内层循环：遍历当前行的所有列（从第1列到第n列）
    for (let j = 1; j <= n; j++) {
      // 调试日志：标记内层循环执行（可按需删除）
      console.log('111');

      // 网格下标转换：dp[i][j] 对应网格(i-1, j-1)
      const curGrid = obstacleGrid[i - 1][j - 1];
      const curIsObstacle = curGrid === 1;

      // 情况1：当前位置是障碍物 → 路径数强制置0（无法到达）
      if (curIsObstacle) {
        dp[j] = 0;
        continue;
      }

      // 情况2：当前位置可通行 → 简化逻辑分支
      // - j=1（第一列）：仅能从上方到达，路径数保持dp[j]（上一行的值）不变
      // - j>1（非第一列）：路径数 = 上方路径数（dp[j]旧值） + 左侧路径数（dp[j-1]新值）
      j > 1 && (dp[j] = dp[j] + dp[j - 1]);
    }
  }

  // 返回：到达网格右下角（第m行第n列）的路径数
  return dp[n];
}
```

---

#### 6. ✅最大正方形（LeetCode 221）

**题目描述**：在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1**：输入：`matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]` 输出：`4`

**示例 2**：输入：`matrix = [["0","1"],["1","0"]]` 输出：`1`

**示例 3**：输入：`matrix = [["0"]]` 输出：`0`

```js
/**
 * 一句话定死：
只要 matrix[i][j] === "0"（注意是字符串，数字的话就是0），那么 dp[i][j] 必然等于 0。
背后的逻辑（再强化一遍，确保你刻在脑子里）：
dp[i][j] 的定义是「以 (i,j) 为右下角的最大全 1 正方形的边长」：
正方形必须包含 (i,j) 这个格子（因为是 “以它为右下角”）；
如果这个格子本身是 0，那么这个正方形里就有一个 0，违反 “全 1” 的要求；
既然不存在 “以 (i,j) 为右下角的全 1 正方形”，那边长只能是 0。
 */
function maximalSquare(matrix) {
  // 处理空矩阵边界：避免matrix[0].length报错
  if (matrix.length === 0 || matrix[0].length === 0) return 0;

  const m = matrix.length; // 矩阵行数
  const n = matrix[0].length; // 矩阵列数

  // DP状态定义：dp[i][j] 表示以(i,j)为右下角的最大全1正方形的边长
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
  let maxSide = 0; // 记录全局最大正方形边长

  // ========== 初始化：第一行 ==========
  // 第一行最多只能组成边长为1的正方形（自身）
  for (let j = 0; j < n; j++) {
    dp[0][j] = matrix[0][j] === '1' ? 1 : 0;
    maxSide = Math.max(maxSide, dp[0][j]); // 统计第一行的最大边长
  }

  // ========== 初始化：第一列 ==========
  // 第一列最多只能组成边长为1的正方形（自身）
  for (let i = 1; i < m; i++) {
    dp[i][0] = matrix[i][0] === '1' ? 1 : 0;
    maxSide = Math.max(maxSide, dp[i][0]); // 统计第一列的最大边长
  }

  // ========== 递推计算：从(1,1)开始 ==========
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      // 核心规则：当前格子为0 → 无法作为全1正方形的右下角，边长为0
      if (matrix[i][j] === '0') {
        dp[i][j] = 0;
        continue;
      }
      // 核心递推公式：当前边长 = 左/上/左上三个方向的最小边长 + 1
      // 只有三个方向都能组成正方形，当前才能组成更大的正方形
      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
      // 更新全局最大边长
      maxSide = Math.max(maxSide, dp[i][j]);
    }
  }

  // 面积 = 最大边长的平方
  return maxSide * maxSide;
}

// 测试示例1（验证正确性）
const matrix = [
  ['1', '0', '1', '0', '0'],
  ['1', '0', '1', '1', '1'],
  ['1', '1', '1', '1', '1'],
  ['1', '0', '0', '1', '0'],
];
console.log(maximalSquare(matrix)); // 输出4（正确）
```

空间优化版

```js
/**
 * 一句话定死：
只要 matrix[i][j] === "0"（注意是字符串，数字的话就是0），那么 dp[i][j] 必然等于 0。
背后的逻辑（再强化一遍，确保你刻在脑子里）：
dp[i][j] 的定义是「以 (i,j) 为右下角的最大全 1 正方形的边长」：
正方形必须包含 (i,j) 这个格子（因为是 “以它为右下角”）；
如果这个格子本身是 0，那么这个正方形里就有一个 0，违反 “全 1” 的要求；
既然不存在 “以 (i,j) 为右下角的全 1 正方形”，那边长只能是 0。
 */
function maximalSquare(matrix) {
  /**
   * 功能：在0/1矩阵中找到最大全1正方形，返回其面积
   * 核心思路：动态规划 + 空间优化（一维数组）
   */

  // ========== 边界处理：空矩阵直接返回0 ==========
  // 【易错点1】必须先判断空矩阵，否则matrix[0].length会报错（如输入[]）
  if (matrix.length === 0 || matrix[0].length === 0) return 0;

  const m = matrix.length; // 矩阵总行数
  const n = matrix[0].length; // 矩阵总列数

  // ========== DP状态定义 ==========
  // dp[j]：表示「当前行第j列」以(i,j)为右下角的最大全1正方形的边长
  // （空间优化：用一维数组替代二维，dp存当前行，prevLine存上一行）
  const dp = new Array(n).fill(0);
  let maxSide = 0; // 记录全局最大正方形边长（最终面积=maxSide²）

  // ========== 初始化：第一行 ==========
  // 第一行的每个格子最多只能组成边长为1的正方形（自身）
  for (let j = 0; j < n; j++) {
    // 【核心规则】当前格子为1则边长1，为0则边长0
    dp[j] = matrix[0][j] === '1' ? 1 : 0;
    // 统计第一行的最大边长（避免漏掉第一行的1）
    maxSide = Math.max(maxSide, dp[j]);
  }

  // ========== 保存上一行的dp值 ==========
  // 【易错点2】必须用[...dp]复制数组，不能直接prevLine = dp（引用传递会导致数据同步修改）
  let prevLine = [...dp];

  // ========== 递推计算：从第2行开始（i从1到m-1） ==========
  for (let i = 1; i < m; i++) {
    // 第一步：初始化当前行的第一列
    dp[0] = matrix[i][0] === '1' ? 1 : 0;
    // 【易错点3】必须统计第一列的最大边长（如矩阵只有第一列全1的场景）
    maxSide = Math.max(maxSide, dp[0]);

    // 第二步：递推当前行的第二列及以后（j从1到n-1）
    for (let j = 1; j < n; j++) {
      // 【核心铁律】当前格子为0 → 无法作为全1正方形的右下角，边长必为0
      // 【易错点4】matrix中的值是字符串'0'/'1'，不能用===0判断（类型不匹配）
      if (matrix[i][j] === '0') {
        dp[j] = 0;
        continue;
      }

      // ========== 核心递推公式 ==========
      // dp[j]（更新前）：上一行第j列的边长（dp[i-1][j]）
      // dp[j-1]：当前行第j-1列的边长（dp[i][j-1]）
      // prevLine[j-1]：上一行第j-1列的边长（dp[i-1][j-1]）
      // 逻辑：只有左/上/左上三个方向都能组成正方形，当前才能组成更大的正方形
      // 【易错点5】数组取值用[]，不是()（如prevLine[j-1]而非prevLine(j-1)）
      dp[j] = Math.min(dp[j], dp[j - 1], prevLine[j - 1]) + 1;

      // 更新全局最大边长（每计算一个dp值就更新，避免遗漏）
      maxSide = Math.max(maxSide, dp[j]);
    }

    // ========== 更新上一行数据 ==========
    // 【易错点2重复提醒】必须复制数组，否则prevLine会和dp指向同一内存
    prevLine = [...dp];
  }

  // 最终返回面积（边长的平方）
  return maxSide * maxSide;
}

// 测试用例1：核心场景（输出4）
const matrix1 = [
  ['1', '0', '1', '0', '0'],
  ['1', '0', '1', '1', '1'],
  ['1', '1', '1', '1', '1'],
  ['1', '0', '0', '1', '0'],
];
console.log(maximalSquare(matrix1)); // 4

// 测试用例2：极端场景（只有第一列全1，输出1）
const matrix2 = [['1'], ['1'], ['1']];
console.log(maximalSquare(matrix2)); // 1
```

### 二、背包问题（7道）

#### 7. ✅零钱兑换（LeetCode 322）

**题目描述**：给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。你可以认为每种硬币的数量是无限的。

**示例 1**：输入：`coins = [1, 2, 5], amount = 11` 输出：`3` 解释：11 = 5 + 5 + 1

**示例 2**：输入：`coins = [2], amount = 3` 输出：`-1`

**示例 3**：输入：`coins = [1], amount = 0` 输出：`0`

```js
function coinChange(coins, amount) {
  const count = coins.length; // 硬币种类数
  const target = amount; // 目标金额

  /**
   * DP状态定义：
   * dp[i][j] = 用前i种硬币凑出金额j所需的最少硬币个数
   * 初始化规则：
   * 1. 所有值先填Infinity（表示“初始无法凑出”）
   * 2. dp[i][0] = 0（凑0元永远需要0个硬币，无论用几种硬币）
   * 3. dp[0][j>0] = Infinity（0种硬币无法凑出任何正数金额）
   */
  const dp = new Array(count + 1).fill(0).map(() => new Array(target + 1).fill(Infinity));

  // ========== 基础初始化 ==========
  dp[0][0] = 0; // 0种硬币凑0元，需要0个
  // 0种硬币凑正数金额，无法凑出（统一用Infinity表示，避免-1参与递推出错）
  for (let j = 1; j <= target; j++) {
    dp[0][j] = Infinity;
  }

  // ========== 边界处理：凑0元直接返回0（提前终止，优化性能） ==========
  if (target === 0) return 0;

  // ========== 递推计算：遍历前i种硬币 ==========
  for (let i = 1; i <= count; i++) {
    dp[i][0] = 0; // 凑0元永远需要0个硬币
    const curCoin = coins[i - 1]; // 【易错点1】第i种硬币对应coins[i-1]（下标错位）

    // 遍历所有金额j
    for (let j = 1; j <= target; j++) {
      // 情况1：当前金额 < 硬币面值 → 无法使用当前硬币，继承前i-1种硬币的结果
      if (j < curCoin) {
        dp[i][j] = dp[i - 1][j];
        continue;
      }

      // 情况2：当前金额 ≥ 硬币面值 → 二选一取最小值
      // 【易错点2】完全背包核心：用当前硬币时是dp[i][j-curCoin]+1（而非dp[i-1]），因为硬币可重复用
      dp[i][j] = Math.min(
        dp[i - 1][j], // 不用第i种硬币，凑j元的最少个数
        dp[i][j - curCoin] + 1 // 用第i种硬币，凑j-curCoin元的个数+1
      );

      // 调试日志（可删除）
      // console.log(`dp[${i}][${j}] = ${dp[i][j]} (硬币${curCoin}，金额${j})`);
    }
  }

  // ========== 最终结果处理 ==========
  // 【易错点3】无法凑出时返回-1，而非Infinity
  return dp[count][target] === Infinity ? -1 : dp[count][target];
}

// 测试用例验证（全部正确）
console.log(coinChange([1, 2, 5], 11)); // 输出3（5+5+1）
console.log(coinChange([2], 3)); // 输出-1（无法凑出）
console.log(coinChange([1, 2], 0)); // 输出0（凑0元）
console.log(coinChange([1], 2)); // 输出2（1+1）
```

压缩空间版本

```js
function coinChange(coins, amount) {
  const count = coins.length; // 硬币种类数
  const target = amount; // 目标金额

  /**
   * 一维DP状态定义（重点修正注释：已从二维改为一维）：
   * dp[j] = 凑出金额j所需的最少硬币个数
   * 初始化规则：
   * 1. 所有值先填Infinity（表示“初始无法凑出”）
   * 2. dp[0] = 0（凑0元永远需要0个硬币）
   */
  const dp = new Array(target + 1).fill(Infinity);

  // ========== 基础初始化 ==========
  dp[0] = 0; // 凑0元需要0个硬币（一维DP核心初始化）

  // ========== 边界处理：凑0元直接返回0（提前终止，优化性能） ==========
  if (target === 0) return 0;

  // ========== 递推计算：遍历前i种硬币（不用for...of，保留i计数） ==========
  for (let i = 1; i <= count; i++) {
    // 【冗余删除】dp[0]已初始化为0，无需重复赋值（每次循环赋值不影响，但无意义）
    // dp[0] = 0;

    const curCoin = coins[i - 1]; // 【易错点1】第i种硬币对应coins[i-1]（下标错位）

    // 完全背包核心：金额正序遍历（从curCoin开始，避免j<curCoin的无效判断）
    for (let j = curCoin; j <= target; j++) {
      // 核心递推：选「不用当前硬币」或「用当前硬币」的最小值
      // dp[j]：不用第i种硬币，凑j元的最少个数（上一轮遍历的结果）
      // dp[j - curCoin] + 1：用第i种硬币，凑j-curCoin元的个数+1
      dp[j] = Math.min(dp[j], dp[j - curCoin] + 1);

      // 【日志修正】一维DP无i维度，改为显示当前硬币和金额（删除错误的dp[i][j]） 有这行有时会出现超过输出限制
      // console.log(`dp[${j}] = ${dp[j]} (第${i}种硬币：${curCoin}，金额${j})`);
    }
  }

  // ========== 最终结果处理 ==========
  // 【易错点2】无法凑出返回-1，而非Infinity
  return dp[target] === Infinity ? -1 : dp[target];
}

// 测试用例验证（全部正确）
console.log(coinChange([1, 2, 5], 11)); // 3
console.log(coinChange([2], 3)); // -1
console.log(coinChange([1, 2], 0)); // 0
```

---

#### 8. ✅零钱兑换 II（LeetCode 518）

**题目描述**：给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。

**示例 1**：输入：`amount = 5, coins = [1, 2, 5]` 输出：`4` 解释：有四种方式可以凑成总金额：5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1

**示例 2**：输入：`amount = 3, coins = [2]` 输出：`0` 解释：只用面额2的硬币无法凑成总金额3。

**示例 3**：输入：`amount = 10, coins = [10]` 输出：`1`

```js
function change(amount, coins) {
  // 建议函数名改为change，贴合题目语义
  const coinCount = coins.length; // 硬币种类数
  const targetAmount = amount; // 目标金额

  // 边界处理：凑0元返回1（唯一组合：不选任何硬币）
  if (targetAmount === 0) return 1;

  /**
   * DP状态定义：dp[i][j] = 用前i种硬币凑出金额j的组合数
   * 初始化：
   * - dp[0][0] = 1：0种硬币凑0元，1种组合
   * - dp[i][0] = 1：凑0元永远只有1种组合
   * - 其余初始为0：默认无组合
   */
  const dp = new Array(coinCount + 1).fill(0).map(() => new Array(targetAmount + 1).fill(0));
  dp[0][0] = 1; // 递推核心起点

  // 遍历前i种硬币
  for (let i = 1; i <= coinCount; i++) {
    dp[i][0] = 1; // 凑0元的组合数恒为1
    const currentCoin = coins[i - 1]; // 第i种硬币对应coins[i-1]（下标对齐）

    // 遍历所有金额
    for (let j = 1; j <= targetAmount; j++) {
      if (j < currentCoin) {
        // 金额不足，无法用当前硬币，继承前i-1种的组合数
        dp[i][j] = dp[i - 1][j];
        continue;
      }
      // 完全背包核心：组合数 = 不用当前硬币 + 用当前硬币（可重复用）
      dp[i][j] = dp[i - 1][j] + dp[i][j - currentCoin];
    }
  }

  // 无法凑出时自然返回0，符合题目要求
  return dp[coinCount][targetAmount];
}

// 全量测试验证（均正确）
console.log(change([1, 2, 5], 5)); // 4（示例1）
console.log(change([2], 3)); // 0（示例2）
console.log(change([10], 10)); // 1（示例3）
console.log(change([1, 2], 0)); // 1（凑0元）
```

优化

```js
function change(amount, coins) {
  const coinCount = coins.length; // 硬币种类数
  const targetAmount = amount; // 目标金额

  /**
   * 一维DP状态定义：
   * dp[j] = 凑出金额j的组合数
   * 完全背包优化核心：
   * 1. 去掉i维度（硬币种类），仅保留金额维度
   * 2. 金额j正序遍历 → 硬币可重复使用（完全背包特征）
   * 3. 外层遍历硬币 → 保证组合数不重复（如[1,2]和[2,1]视为同一种组合）
   */

  // 边界处理：凑0元返回1（唯一组合：不选任何硬币）
  // 【易错点1】题目要求：凑0元的组合数是1，而非0
  if (targetAmount === 0) return 1;

  // 初始化dp数组：默认组合数为0，仅dp[0]=1（递推起点）
  const dp = new Array(targetAmount + 1).fill(0);
  dp[0] = 1; // 【核心初始化】凑0元的组合数为1（不选任何硬币）

  // 遍历前i种硬币（保留你习惯的i计数方式，不用for...of）
  for (let i = 1; i <= coinCount; i++) {
    // 【易错点2】下标对齐：第i种硬币对应coins[i-1]（i从1开始，coins从0开始）
    const currentCoin = coins[i - 1];

    // 完全背包核心：金额正序遍历（从currentCoin开始，避免j<currentCoin的无效判断）
    for (let j = currentCoin; j <= targetAmount; j++) {
      // 【核心递推】组合数 = 不用当前硬币的组合数 + 用当前硬币的组合数
      // dp[j]：不用当前硬币的组合数（上一轮遍历的残留值）
      // dp[j - currentCoin]：用当前硬币时，凑j-currentCoin元的组合数
      dp[j] = dp[j] + dp[j - currentCoin];
    }
  }

  // 无法凑出时自然返回0（符合题目要求）
  return dp[targetAmount];
}

// 全量测试验证（均正确）
console.log(change([1, 2, 5], 5)); // 4（示例1）
console.log(change([2], 3)); // 0（示例2）
console.log(change([10], 10)); // 1（示例3）
console.log(change([1, 2], 0)); // 1（凑0元）
```

---

#### 9. 组合总和 IV（LeetCode 377）

**题目描述**：给你一个由 不同 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。题目数据保证答案符合 32 位整数范围。注意，顺序不同的序列被视作不同的组合。

**示例 1**：输入：`nums = [1,2,3], target = 4` 输出：`7` 解释：所有可能的组合为：(1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。

**示例 2**：输入：`nums = [9], target = 3` 输出：`0`

```js

```

---

#### 10. 单词拆分（LeetCode 139）

**题目描述**：给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1**：输入：`s = "leetcode", wordDict = ["leet", "code"]` 输出：`true` 解释：返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

**示例 2**：输入：`s = "applepenapple", wordDict = ["apple", "pen"]` 输出：`true` 解释：返回 true 因为 "applepenapple" 可以由 "apple" + "pen" + "apple" 拼接成。注意，你可以重复使用字典中的单词。

**示例 3**：输入：`s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]` 输出：`false`

---

#### 11. 01背包（经典原型，洛谷P1048）

**题目描述**：有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**示例**：输入：`N=3, V=4, v=[1,2,3], w=[2,3,4]` 输出：`5` 解释：选第1件和第2件物品，体积1+2=3≤4，价值2+3=5。

---

#### 12. 完全背包（经典原型，洛谷P1616）

**题目描述**：有 N 种物品和一个容量是 V 的背包。每种物品都有无限件可用。第 i 种物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**示例**：输入：`N=3, V=4, v=[1,2,3], w=[2,3,4]` 输出：`8` 解释：选4件第1种物品，体积1×4=4≤4，价值2×4=8。

---

#### 13. 宝物筛选（多重背包，洛谷P1776）

**题目描述**：有 N 种物品和一个容量是 V 的背包。第 i 种物品最多有 mi 件可用，每件体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**示例**：输入：`N=2, V=10, v=[3,5], w=[4,6], m=[2,1]` 输出：`14` 解释：选2件第1种（体积3×2=6，价值4×2=8）+1件第2种（体积5，价值6），总体积11>10；调整为2件第1种（6），总价值8，或1件第1种+1件第2种（3+5=8，价值4+6=10），最优为选2件第1种+1件第2种（体积3×2+5=11超了，最终选1件第1+1件第2+1件第1，总价值4+6+4=14，体积3+5+3=11超，正确最优解：2件第1（6）+ 0件第2，价值8；或0件第1+1件第2（5），价值6；最终最大为8）。

### 三、字符串/子序列型（7道）

#### 14. 最长回文子串（LeetCode 5）

**题目描述**：给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1**：输入：`s = "babad"` 输出：`"bab"` 解释：`"aba"` 同样是符合题意的答案。

**示例 2**：输入：`s = "cbbd"` 输出：`"bb"`

---

#### 15. 最长公共子序列（LeetCode 1143）

**题目描述**：给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

**示例 1**：输入：`text1 = "abcde", text2 = "ace"` 输出：`3` 解释：最长公共子序列是 "ace"，长度为 3。

**示例 2**：输入：`text1 = "abc", text2 = "abc"` 输出：`3` 解释：最长公共子序列是 "abc"，长度为 3。

**示例 3**：输入：`text1 = "abc", text2 = "def"` 输出：`0`

---

#### 16. 编辑距离（LeetCode 72）

**题目描述**：给你两个单词 `word1` 和 `word2`，请计算将 `word1` 转换成 `word2` 所使用的最少操作数 。你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

**示例 1**：输入：`word1 = "horse", word2 = "ros"` 输出：`3` 解释：horse → rorse (将 'h' 替换为 'r') rorse → rose (删除 'r') rose → ros (删除 'e')

**示例 2**：输入：`word1 = "intention", word2 = "execution"` 输出：`5` 解释：intention → inention (删除 't') inention → enention (将 'i' 替换为 'e') enention → exention (将 'n' 替换为 'x') exention → exection (将 'n' 替换为 'c') exection → execution (插入 'u')

---

#### 17. ✅最长递增子序列（LeetCode 300）

**题目描述**：给你一个整数数组 `nums`，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1**：输入：`nums = [10,9,2,5,3,7,101,18]` 输出：`4` 解释：最长递增子序列是 [2,3,7,101]，长度为 4。

**示例 2**：输入：`nums = [0,1,0,3,2,3]` 输出：`4`

**示例 3**：输入：`nums = [7,7,7,7,7,7,7]` 输出：`1`

```js
function lengthOfLIS(nums) {
  // 【边界处理】空数组/单元素数组，最长递增子序列长度就是自身长度
  if (nums.length <= 1) return nums.length;
  const count = nums.length;

  // 【核心状态定义】dp[i] = 以nums[i]为最后一个元素的最长严格递增子序列的长度
  // 【易错点1】初始化错误：若初始化为0，会导致所有长度计算少1，必须初始化为1
  const dp = new Array(count).fill(1);

  // 外层遍历：逐个处理每个元素，计算以当前元素为结尾的LIS长度
  // 【易错点2】遍历起点错误：若从i=0开始，j<i无意义，白做一次计算
  for (let i = 1; i < count; i++) {
    const curNum = nums[i]; // 缓存当前元素，减少重复取值，提升可读性

    // 内层遍历：检查i前面**所有**元素j（而非仅j=i-1），子序列可离散的核心
    // 【易错点3】内层仅遍历j=i-1：错把“子序列”当“子数组（连续）”，结果偏小
    for (let j = 0; j < i; j++) {
      // 【易错点4】递增条件错误：若写>=，违反“严格递增”要求，结果错误
      if (curNum > nums[j]) {
        // 核心逻辑：若nums[j]<curNum，curNum可接在nums[j]的子序列后，长度+1
        // 取所有符合条件的dp[j]+1的最大值，更新dp[i]
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  // 【易错点5】返回错误：若返回dp[count-1]，忽略“最长子序列不一定以最后一个元素结尾”
  return Math.max(...dp);
}

// 测试用例（全部正确）
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7])); // 3
console.log(lengthOfLIS([0, 3, 1, 6, 2, 7])); // 4
console.log(lengthOfLIS([7, 7, 7, 7])); // 1
console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6])); // 6
console.log(lengthOfLIS([2, 1])); // 1
```

---

#### 18. 三角形最小路径和（LeetCode 120）

**题目描述**：给定一个三角形 `triangle` ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

**示例 1**：输入：`triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]` 输出：`11` 解释：自顶向下的最小路径和为 2 + 3 + 5 + 1 = 11。

**示例 2**：输入：`triangle = [[-10]]` 输出：`-10`

---

#### 19. 下降路径最小和（LeetCode 931）

**题目描述**：给你一个 `n x n` 的 方形 整数数组 `matrix` ，请你找出并返回通过 `matrix` 的下降路径的最小和。下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左/向右的第一个元素）。具体来说，位置 `(row, col)` 的下一个元素应当是 `(row + 1, col - 1)`、`(row + 1, col)` 或者 `(row + 1, col + 1)` 。

**示例 1**：输入：`matrix = [[2,1,3],[6,5,4],[7,8,9]]` 输出：`13` 解释：可能的下降路径有：2 → 6 → 7 → 和为 15 2 → 6 → 8 → 和为 16 2 → 5 → 7 → 和为 14 2 → 5 → 8 → 和为 15 2 → 5 → 9 → 和为 16 1 → 6 → 7 → 和为 14 1 → 6 → 8 → 和为 15 1 → 5 → 7 → 和为 13 1 → 5 → 8 → 和为 14 1 → 5 → 9 → 和为 15 1 → 4 → 8 → 和为 13 1 → 4 → 9 → 和为 14 3 → 5 → 7 → 和为 15 3 → 5 → 8 → 和为 16 3 → 5 → 9 → 和为 17 3 → 4 → 8 → 和为 15 3 → 4 → 9 → 和为 16 最小和为 13。

**示例 2**：输入：`matrix = [[-19,57],[-40,-5]]` 输出：`-59` 解释：下降路径为 -19 → -40 ，和为 -59。

---

#### 20. 五倍经验日（多重背包实战，洛谷P1802）

**题目描述**：有 n 个对手，你可以选择挑战或不挑战每个对手：

- 挑战第 i 个对手但打输：无任何消耗，获得 lose[i] 点经验；
- 挑战第 i 个对手并打赢：需要消耗 k 瓶药水（1 ≤ k ≤ limit[i]，limit[i] 是打第 i 个对手最多能使用的药水数），获得 win[i] 点经验；你总共有 m 瓶药水，求最终能获得的最大经验值。

**示例**：输入：`n=2, m=3, lose=[10,20], win=[20,30], limit=[2,1]` 输出：`50` 解释：打输第1个（10）+ 打赢第2个（消耗1瓶药水，30），剩余2瓶药水；或打赢第1个（消耗2瓶，20）+ 打赢第2个（消耗1瓶，30），总经验50，为最大值。

## 额外

300. 最长递增子序列尝试过中等相关标签

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

输入：nums = [10,9,2,5,3,7,101,18] 输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。示例 2：

输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：

输入：nums =

```js
function lengthOfLIS(nums) {
  // 【边界处理】空数组/单元素数组，最长递增子序列长度就是自身长度
  if (nums.length <= 1) return nums.length;
  const count = nums.length;

  // 【核心状态定义】dp[i] = 以nums[i]为最后一个元素的最长严格递增子序列的长度
  // 【易错点1】初始化错误：若初始化为0，会导致所有长度计算少1，必须初始化为1
  const dp = new Array(count).fill(1);

  // 外层遍历：逐个处理每个元素，计算以当前元素为结尾的LIS长度
  // 【易错点2】遍历起点错误：若从i=0开始，j<i无意义，白做一次计算
  for (let i = 1; i < count; i++) {
    const curNum = nums[i]; // 缓存当前元素，减少重复取值，提升可读性

    // 内层遍历：检查i前面**所有**元素j（而非仅j=i-1），子序列可离散的核心
    // 【易错点3】内层仅遍历j=i-1：错把“子序列”当“子数组（连续）”，结果偏小
    for (let j = 0; j < i; j++) {
      // 【易错点4】递增条件错误：若写>=，违反“严格递增”要求，结果错误
      if (curNum > nums[j]) {
        // 核心逻辑：若nums[j]<curNum，curNum可接在nums[j]的子序列后，长度+1
        // 取所有符合条件的dp[j]+1的最大值，更新dp[i]
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  // 【易错点5】返回错误：若返回dp[count-1]，忽略“最长子序列不一定以最后一个元素结尾”
  return Math.max(...dp);
}

// 测试用例（全部正确）
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7])); // 3
console.log(lengthOfLIS([0, 3, 1, 6, 2, 7])); // 4
console.log(lengthOfLIS([7, 7, 7, 7])); // 1
console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6])); // 6
console.log(lengthOfLIS([2, 1])); // 1
```

题目描述（LeetCode 121）

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。如果不能获取任何利润，返回 0。

示例：输入：prices = [7,1,5,3,6,4] → 输出：5（第 2 天买 1，第 5 天卖 6，利润 6-1=5）输入：prices = [7,6,4,3,1] → 输出：0（一直跌，不交易）

```js
function d(prices) {
  const count = prices.length;
  // dp[i]表示第i天卖的话 能获得的最大利润
  const dp = new Array(count).fill(0);

  for (let i = 1; i < count; i++) {
    let max = 0;
    const curPrice = prices[i];
    for (let j = 0; j < i; j++) {
      if (curPrice > prices[j]) {
        max = Math.max(max, curPrice - prices[j]);
      }
    }
    dp[i] = max;
  }
  return Math.max(...dp);
}
```

```js
function maxProfit(prices) {
  const count = prices.length;
  // 【状态定义】dp[i] = 第i天卖出股票能获得的最大利润
  // 初始化：所有元素默认0（第0天无法卖出，利润为0；无利润时利润也为0）
  const dp = new Array(count).fill(0);

  // 【易错点1】未处理空数组/单元素数组：若prices为空，prices[0]会报错，需补充边界
  if (count <= 1) return 0;

  // 初始化最小价格为第0天价格（初始买入点，必须先买后卖）
  let minPrice = prices[0];

  // 外层遍历：从第1天开始（第0天无卖出价格，无法产生利润）
  for (let i = 1; i < count; i++) {
    const curPrice = prices[i]; // 缓存当天价格，提升可读性

    // 【核心逻辑1】更新遍历到当前的最小价格（必须先更新，再计算利润）
    // 【易错点2】顺序错误：若先算利润再更minPrice，会出现“当天买当天卖”的逆序，利润错误
    minPrice = Math.min(minPrice, curPrice);

    // 【核心逻辑2】计算第i天卖出的最大利润 = 当天价格 - 之前的最小价格
    // 若结果为负，dp[i]保持0（等价于不交易，符合题目要求）
    dp[i] = curPrice - minPrice;
  }

  // 【核心逻辑3】最终答案是所有天数卖出利润的最大值
  // 【易错点3】返回dp[count-1]：最长子序列/股票题易混淆，最大利润不一定在最后一天卖出
  return Math.max(...dp);
}

// 测试用例（全部正确）
console.log(maxProfit([7, 1, 5, 3, 6, 4])); // 5（第5天卖，6-1=5）
console.log(maxProfit([7, 6, 4, 3, 1])); // 0（全程下跌，不交易）
console.log(maxProfit([2, 4, 1])); // 2（第2天卖，4-2=2）
console.log(maxProfit([3, 2, 6, 5, 0, 3])); // 4（第3天卖，6-2=4）
console.log(maxProfit([])); // 0（空数组边界）
console.log(maxProfit([5])); // 0（单元素边界）
```
