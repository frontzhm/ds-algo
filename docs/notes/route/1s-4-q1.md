# 二叉树遍历思维实战：一文搞定所有路径/层序高频面试题

在算法面试中，二叉树是绕不开的基础核心，而「遍历」更是解决二叉树问题的「万能钥匙」。无论是根到叶的路径统计、层间节点的特殊处理，还是路径值的计算与判断，只要题目围绕二叉树的「树枝」做文章，用遍历思维解题都会无比自然、高效。

很多新手在面对二叉树题时，容易陷入「一题一解」的困境，每道题都重新设计遍历逻辑，既浪费时间又容易出错。实际上，二叉树的遍历题高度同质化，只需掌握两套通用模板，再根据题目需求修改核心业务逻辑，就能轻松搞定90%的高频考点。

本文将从「模板提炼→实战拆解→避坑优化」三个维度，手把手教你用遍历思维破解二叉树路径/层序类高频题，结合6道力扣经典真题，让你从「套模板」到「灵活用」，彻底掌握二叉树遍历的解题精髓。

# 一、先背会两套通用模板：递归+层序，覆盖所有场景

二叉树遍历题可分为两大核心类型，对应两套通用模板，无需记忆复杂逻辑，背会就能直接套用，重点在于理解「模板结构」和「业务填充点」。

## 1.1 递归遍历模板（前序+回溯）：适配根到叶路径类问题

递归遍历的核心是「前序入栈、后序出栈」的回溯思想，适合需要跟踪「根节点到叶子节点完整路径」的场景（如路径收集、路径值计算、路径特征判断）。其优势在于能自然记录节点访问轨迹，代码简洁且逻辑清晰。

以下是优化后的通用模板（两种实现方式，按需选择）：

### 方式1：path数组+手动回溯（直观易懂，新手首选）

```javascript
function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器（视题目需求：数组/字符串/数字）
  const res = [];
  // 3. 定义路径容器，用于回溯记录根到当前节点的轨迹
  const path = [];
  // 4. 启动递归遍历
  traverse(root);
  // 5. 返回最终结果
  return res;

  // 递归遍历辅助函数（闭包共享外层res、path）
  function traverse(node) {
    // 递归终止：空节点直接返回，防止无限递归
    if (node === null) return;

    // 前序位置：进入节点，执行「入栈」操作（核心：记录轨迹）
    path.push(node.val);

    // 【核心业务区】视题目需求编写逻辑（如叶子节点判断、路径处理）
    if (node.left === null && node.right === null) {
      // 叶子节点：通常是路径处理的关键节点（收集/计算/判断）
      res.push([...path]); // 浅拷贝，避免后续回溯修改路径
    }

    // 递归遍历左右子树（必须先左后右，不可重复遍历）
    traverse(node.left);
    traverse(node.right);

    // 后序位置：离开节点，执行「出栈」操作（核心：回溯，恢复轨迹）
    path.pop();
  }
}
```

### 方式2：带参遍历+自动回溯（简洁高效，进阶首选）

核心原理：JavaScript的基本类型（数字、字符串、位掩码）是「值传递」，递归时传递的是值的副本，子树修改不会影响上一层，递归返回后自动恢复状态，无需手动执行pop回溯，代码更简洁。

```javascript
function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器（视题目需求：数组/字符串/数字）
  const res = [];
  // 3. 启动递归遍历：初始路径为空，传递给根节点
  traverse(root, []);
  // 4. 返回最终结果
  return res;

  // 递归遍历辅助函数：参数传递「根到当前节点的路径」
  function traverse(node, path) {
    // 递归终止：空节点直接返回
    if (node === null) return;

    // 前序位置：更新路径 → 浅拷贝原路径，添加当前节点值（避免修改上一层路径）
    const newPath = [...path, node.val];

    // 【核心业务区】叶子节点：路径处理（收集/计算/比较/格式化）
    if (node.left === null && node.right === null) {
      res.push(newPath); // 叶子节点处理逻辑，按需修改
      return;
    }

    // 递归遍历左右子树：传递更新后的新路径，自动回溯
    traverse(node.left, newPath);
    traverse(node.right, newPath);
    // 无需手动回溯：newPath是浅拷贝的新数组，不影响上一层的path
  }
}
```

### 递归模板核心要点

- 闭包特性：辅助函数traverse共享外层res和path，无需额外传参，简化代码；

- 回溯逻辑：方式1需保证push和pop成对出现，方式2借助值传递实现自动回溯；

- 关键节点：叶子节点（node.left === null && node.right === null）是路径类题的核心处理点，几乎所有路径题都在此处编写核心业务逻辑；

- 状态传递：带参遍历的核心是传递「上一层节点的状态」（如累计值、路径、位掩码），下一层基于该状态继续更新。

### 常见状态传递类型（记熟直接套用）

带参遍历的参数本质是「跨节点的状态」，常见类型只有3种，覆盖所有路径类题：

1. **累计值/中间结果**：如路径转数字（129题）、二进制和（1022题），核心更新逻辑：新状态 = 上一层状态 * 基数 + 当前节点值（基数为10、2等）；

2. **层数/深度**：如二叉树右视图（199题DFS解法），传递当前节点层数，实现按层处理；

3. **特征统计状态**：如伪回文路径（572题），用位掩码或数组统计路径中节点值的奇偶性、出现次数等特征。

## 1.2 层序遍历模板（BFS+队列）：适配层间节点类问题

层序遍历（广度优先搜索BFS）的核心是「按层处理节点」，通过队列控制「一层一遍历」，适合需要按层操作节点的场景（如取每层最后一个节点、层内节点统计、每层平均值）。其优势在于逻辑直观，符合人类「从上到下、从左到右」的观察习惯。

```javascript
function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器
  const res = [];
  // 3. 初始化队列，存入根节点（队列是层序遍历的核心载体）
  const queue = [root];

  // 层数 
  let level = 0 

  // 4. 层序遍历主循环：队列非空则继续
  while (queue.length) {

    // 遍历到哪层了，如果需要就用
    level++

    // 5. 记录当前层节点数（关键：确定每层的遍历边界）
    const curLevelSize = queue.length;

    // 6. 遍历当前层所有节点
    for (let i = 0; i < curLevelSize; i++) {
      // 7. 取出队首节点（当前层的待处理节点）
      const curNode = queue.shift();

      // 【核心业务区】视题目需求编写逻辑（如取层内特定节点、层内统计）
      // 例：取每层最后一个节点 → if (i === curLevelSize - 1) { ... }

      // 8. 子节点入队：左子节点先入，右子节点后入（保证层内顺序）
      if (curNode.left) queue.push(curNode.left);
      if (curNode.right) queue.push(curNode.right);
    }

    // 可选：整层遍历完成后统一处理（如层内节点汇总）
  }

  // 9. 返回最终结果
  return res;
}
```

### 层序模板核心要点

- 层边界控制：curLevelSize = queue.length是层序遍历的灵魂，确保每次循环只处理「当前层」的节点，不与下一层混淆；

- 队列操作：shift（取队首）和push（队尾入子节点）配合，实现节点的按层传递；

- 层内顺序：左子节点先入队，保证层内节点遍历顺序与「从左到右」的直观顺序一致。

# 二、模板实战：6道力扣高频题手把手拆解

以下6道题覆盖二叉树路径、层序的所有高频考法，全部基于上述模板实现，**保留模板核心结构，仅修改「核心业务区」代码**，让你直观感受「套模板解题」的高效性。同时标注易踩坑点和优化技巧，兼顾正确性和解题效率。

## 2.1 递归实战1：二叉树的所有路径（力扣257）

### 题目要求

给你二叉树的根节点，按任意顺序返回所有从根节点到叶子节点的路径，路径格式为"1->2->3"。

### 解题思路

- 模板：直接套用「递归遍历模板（path数组+手动回溯）」；

- 核心业务：叶子节点处将path数组格式化为"->"连接的字符串，存入结果容器；

- 优化：叶子节点处提前回溯+return，避免后续无意义的代码执行。

### 套模板实现代码（直接通关）

```javascript
var binaryTreePaths = function(root) {
  if (root === null) return [];
  const res = [];
  const path = [];
  traverse(root);
  return res;

  function traverse(node) {
    if (node === null) return;
    path.push(node.val); // 前序入栈

    // 核心业务：叶子节点格式化路径并收集
    if (node.left === null && node.right === null) {
      res.push(path.join('->'));
      path.pop(); // 叶子节点提前回溯，优化效率
      return;
    }

    traverse(node.left);
    traverse(node.right);
    path.pop(); // 后序出栈
  }
};
```

## 2.2 递归实战2：求根节点到叶节点数字之和（力扣129）

### 题目要求

树中每个节点存0-9的数字，根到叶的路径代表一个数字（如1→2→3代表123），计算所有根到叶数字的和。

### 解题思路

- 模板：基于「递归遍历模板（带参遍历）」优化，无需显式path数组；

- 核心优化：路径值通过curNum = curNum * 10 + node.val动态计算（值传递，无需回溯），替代path数组，降低空间复杂度；

- 核心业务：叶子节点处将动态计算的路径值累加到结果。

### 套模板优化代码（最优解）

```javascript
function sumNumbers(root) {
  // 1. 处理空树边界：空树返回0（数字，匹配题目要求）
  if (root === null) return 0;
  // 2. 定义结果容器：数字类型，初始为0
  let res = 0;
  // 3. 启动递归遍历：初始前序和为0（无节点时的基础值）
  traverse(root, 0);
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：prevSum=根到当前节点父节点的路径和（上一层状态）
  function traverse(node, prevSum) {
    // 递归终止：空节点直接返回
    if (node === null) return;

    // 前序位置：更新状态，计算根到当前节点的路径和（核心）
    const curSum = 10 * prevSum + node.val;

    // 【核心业务区】叶子节点：累加路径和到结果
    if (node.left === null && node.right === null) {
      res += curSum; // 累加
      return; // 提前返回，避免无意义的递归
    }

    // 递归遍历左右子树：传递当前状态给下一层
    traverse(node.left, curSum);
    traverse(node.right, curSum);

    // 无需后序回溯：prevSum/curSum是值传递，递归返回后自动恢复上一层状态
  }
}
```

## 2.3 层序实战：二叉树的右视图（力扣199）

### 题目要求

想象站在二叉树右侧，按从上到下顺序返回能看到的节点值（左子树更高时，能看到左子树高出的部分）。

### 解题思路

- 模板：直接套用「层序遍历模板」；

- 核心业务：每层遍历的最后一个节点（i === curLevelSize - 1）即为右侧能看到的节点，直接存入结果。

### 套模板实现代码（最优解）

```javascript
var rightSideView = function(root) {
  if (root === null) return [];
  const res = [];
  const queue = [root];

  while (queue.length) {
    const curLevelSize = queue.length;
    for (let i = 0; i < curLevelSize; i++) {
      const curNode = queue.shift();

      // 核心业务：取每层最后一个节点
      if (i === curLevelSize - 1) {
        res.push(curNode.val);
      }

      if (curNode.left) queue.push(curNode.left);
      if (curNode.right) queue.push(curNode.right);
    }
  }

  return res;
};
```

## 2.4 递归实战3：从叶结点开始的最小字符串（力扣988）

### 题目要求

节点值为0-25（对应a-z），返回从叶节点到根节点的字典序最小字符串（如"z" < "ab"）。

### 解题思路

- 模板：套用「递归遍历模板（带参遍历）」，用字符串传递路径；

- 核心技巧：头部拼接字符串（curChar + path），天然生成叶→根的路径，无需反转；

- 核心业务：叶子节点处将生成的字符串与当前最小值比较，更新最小字符串；

- 避坑点：切勿用节点值和判断字典序，需直接比较字符串本身。

### 套模板实现代码（避坑版）

```javascript
function smallestFromLeaf(root) {
  // 1. 处理空树边界：题目要求空树返回空字符串
  if (root === null) return '';
  // 2. 定义结果容器：初始为空字符串，用于存储字典序最小的叶→根字符串
  let res = '';
  // 3. 启动递归遍历：初始路径为空字符串（根节点无父节点）
  traverse(root, '');
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：path - 父节点到根节点的字符拼接字符串（叶→根格式）
  function traverse(node, path) {
    // 递归终止：空节点直接返回
    if (node === null) return;

    // 前序位置：头部拼接，天然生成当前节点到根的叶→根字符串
    const curChar = String.fromCharCode(node.val + 97); // 0→a，25→z
    const newPath = curChar + path;

    // 【核心业务区】叶子节点：比较并更新字典序最小的字符串
    if (node.left === null && node.right === null) {
      // 首次赋值 或 当前字符串字典序更小，更新结果
      if (res === '' || newPath < res) {
        res = newPath;
      }
      return; // 提前返回，避免无意义的递归
    }

    // 递归遍历左右子树：传递新路径，自动回溯
    traverse(node.left, newPath);
    traverse(node.right, newPath);
  }
}
```

## 2.5 递归实战4：从根到叶的二进制数之和（力扣1022）

### 题目要求

节点值为0或1，根到叶的路径代表二进制数（最高有效位开始），计算所有二进制数的十进制和。

### 解题思路

- 模板：同129题，基于「递归遍历模板（带参遍历）」，动态计算二进制值；

- 核心优化：二进制转十进制通过curNum = curNum * 2 + node.val实现（左移1位+当前值），效率高于幂运算；

- 核心业务：叶子节点处将动态计算的十进制值累加到结果。

### 套模板优化代码（最优解）

```javascript
function sumRootToLeaf(root) {
  // 1. 处理空树边界
  if (root === null) return 0;
  // 2. 定义结果容器
  let res = 0;
  // 3. 启动递归遍历：初始前序和为0
  traverse(root, 0);
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：prevSum=根到当前节点父节点的二进制转十进制和
  function traverse(node, prevSum) {
    if (node === null) return;

    // 前序位置：更新二进制转十进制的和（左移1位+当前值）
    const curSum = 2 * prevSum + node.val;

    // 【核心业务区】叶子节点：累加结果
    if (node.left === null && node.right === null) {
      res += curSum;
    }

    // 递归遍历左右子树
    traverse(node.left, curSum);
    traverse(node.right, curSum);
  }
}
```

## 2.6 递归实战5：二叉树中的伪回文路径（力扣572）

### 题目要求

节点值为1-9，根到叶路径为「伪回文」指路径值的排列能形成回文，统计伪回文路径的数目。

### 解题思路

- 模板：基于「递归遍历模板（带参遍历）」，用位掩码替代path统计路径特征；

- 核心知识点：伪回文判断条件 → 路径中奇数次数的数字≤1（偶数长度为0，奇数长度为1）；

- 位掩码原理：用9位二进制数统计1-9的出现奇偶性（0=偶，1=奇），叶子节点处通过mask & (mask-1) === 0判断；

- 核心业务：叶子节点处判断位掩码是否满足伪回文条件，满足则结果+1。

### 套模板优化代码（位掩码最优解）

```javascript
function pseudoPalindromicPaths(root) {
  // 1. 处理空树边界
  if (root === null) return 0;
  // 2. 定义结果容器（统计伪回文路径数量）
  let res = 0;
  // 3. 启动递归遍历：初始位掩码为0（全偶）
  traverse(root, 0);
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：mask=位掩码（统计1-9出现次数的奇偶性）
  function traverse(node, mask) {
    if (node === null) return;

    // 前序位置：更新位掩码（异或翻转对应位，0↔1）
    const newMask = mask ^ (1 << (node.val - 1));

    // 【核心业务区】叶子节点：判定伪回文
    if (node.left === null && node.right === null) {
      // 二进制中1的数量≤1，即为伪回文
      if ((newMask & (newMask - 1)) === 0) {
        res++;
      }
      return;
    }

    // 递归遍历左右子树，自动回溯
    traverse(node.left, newMask);
    traverse(node.right, newMask);
  }
}
```

### 基础版替代方案（数组统计，适合对位掩码不熟悉的新手）

```javascript
function pseudoPalindromicPaths(root) {
  if (root === null) return 0;
  let res = 0;
  traverse(root, new Array(10).fill(0), true);
  return res;

  function traverse(node, recordArr, isEven) {
    if (node === null) return;

    // 前序位置：更新数组统计奇偶性
    const newRecordArr = [...recordArr];
    newRecordArr[node.val] = (newRecordArr[node.val] + 1) % 2;
    isEven = !isEven;

    // 【核心业务区】叶子节点：判定伪回文
    if (node.left === null && node.right === null) {
      if (isEven) {
        if (newRecordArr.every(item => item === 0)) res++;
        return;
      }
      let oneCount = 0;
      for (let i = 0; i < newRecordArr.length; i++) {
        if (newRecordArr[i] === 1) {
          oneCount++;
          if (oneCount > 1) return;
        }
      }
      if (oneCount === 1) res++;
      return;
    }

    traverse(node.left, newRecordArr, isEven);
    traverse(node.right, newRecordArr, isEven);
  }
}
```

# 三、遍历思维解题核心总结（避坑+优化）

## 3.1 两大模板适用场景速判

|遍历模板|核心适用场景|典型题目|核心优势|
|---|---|---|---|
|递归遍历（前序+回溯）|根到叶路径类问题（需跟踪节点轨迹）|257、129、988、1022、572|天然记录路径，回溯逻辑简单，可灵活优化|
|层序遍历（BFS+队列）|层间节点类问题（需按层处理节点）|199、层序遍历、每层平均值|按层处理，逻辑直观，符合人类观察习惯|
## 3.2 递归遍历通用避坑点

1. 切勿重复遍历子树（如两次traverse(node.left)），导致右子树无法访问；

2. 可修改的结果变量（如res=0、minStr=''）需用let声明，const不可重新赋值；

3. path数组+手动回溯时，push和pop必须成对出现，避免路径轨迹混乱；

4. 核心业务逻辑仅在叶子节点处理（题目均要求「根到叶路径」）；

5. 字典序判断需直接比较字符串，不可用节点值和替代。

## 3.3 通用优化技巧

1. **路径优化**：路径转数字类问题，优先用动态值计算替代显式path数组，降低空间开销；

2. **特征统计优化**：节点值范围小时（如1-9），优先用位掩码替代数组/哈希表，空间复杂度降至O(1)；

3. **提前终止**：叶子节点处理完后提前return，避免无意义的递归和回溯；

4. **自动回溯**：用基本类型（数字、字符串、位掩码）做带参遍历，利用值传递实现自动回溯，简化代码。

## 3.4 核心解题心法

**「模板定结构，业务填细节」**—— 二叉树遍历题的核心逻辑高度统一，无需为每道题重新设计遍历框架。只需根据题目场景选择对应的模板，在「核心业务区」编写少量代码即可解决问题。

真正的难点不在于遍历本身，而在于：

- 把题目要求转化为「叶子节点/层内节点的处理规则」；

- 根据数据特征选择最优的轨迹记录方式（显式path/动态值/位掩码）。

# 四、最后：从模板到灵活运用

本文的模板是「入门抓手」，背会模板能解决90%的二叉树遍历题，但真正的算法能力在于理解模板背后的逻辑，并能灵活调整：

- 递归遍历不仅限于前序，可根据需求在中序/后序位置编写业务逻辑（如利用中序遍历的有序性解决二叉搜索树问题）；

- 层序遍历可增加层容器，收集每层的所有节点（如二叉树层序遍历输出二维数组）；

- 复杂问题可结合两种遍历思维（如先层序确定树的高度，再递归处理路径）。

通过本文的6道实战题，你已经掌握了遍历思维的核心用法。后续只需多做同类题，熟练运用「模板+优化技巧」，就能轻松搞定所有二叉树遍历相关的高频考点，面试时遇到这类题也能从容应对！

<!-- # 二叉树遍历思维实战：搞定所有路径/层序高频题

二叉树是算法面试的基础核心，而**遍历**是解决二叉树问题的「万能钥匙」—— 尤其是当题目要求在二叉树的「树枝」（根到叶路径、层间节点）上做文章时，用遍历思维解题会无比自然。本文将先提炼**递归遍历**和**层序遍历**的通用模板，再结合6道高频经典题（二叉树路径、数字和、右视图等），手把手教你套模板、避坑点、做优化，让你彻底掌握「遍历思维」解二叉树题的精髓。

## 一、二叉树两大核心遍历模板（背会即用）

二叉树的遍历题可分为两大类型：**根到叶路径类**（需跟踪节点轨迹）、**层间节点类**（需按层处理节点），对应两套通用模板，所有同类题都可基于模板稍作修改实现，无需重复造轮子。

### 1.1 递归遍历模板（前序+回溯，适配根到叶路径类问题）

递归遍历的核心是**前序入栈、后序出栈的回溯思想**，适合需要跟踪「根节点到叶子节点完整路径」的场景，能自然记录节点的访问轨迹，是路径类题的最优解。

```JavaScript

function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器（视题目需求，数组/数字/字符串）
  const res = [];
  // 3. 定义路径容器，用于回溯记录根到当前节点的轨迹
  // 4. 启动递归遍历
  traverse(root,[]);
  // 5. 返回最终结果
  return res;

  // 递归遍历辅助函数（闭包共享外层res、path）
  function traverse(node, path) {
    // 递归终止：空节点直接返回，防止无限递归
    if (node === null) return;

    // 前序位置：进入节点，执行「入栈」操作（核心：记录轨迹）
    const newPath = [...path,node.val];

    // 【核心业务区】视题目需求编写逻辑（如叶子节点判断、路径处理）
    if (node.left === null && node.right === null) {
      // 叶子节点：通常是路径处理的关键节点（收集/计算/判断）
    }

    // 递归遍历左右子树（必须先左后右，不可重复遍历）
    traverse(node.left, newPath);
    traverse(node.right, newPath);
  }
}
```

#### 模板核心要点

- 闭包特性：辅助函数`traverse`共享外层`res`和`path`，无需额外传参，简化代码；

- 回溯逻辑：`path.push`（前序入栈）和`path.pop`（后序出栈）成对出现，确保遍历完子树后轨迹恢复到上一层，无冗余节点；

- 关键节点：叶子节点（`node.left === null && node.right === null`）是路径类题的核心处理点，几乎所有路径题都在此处编写核心业务逻辑。



```JavaScript
function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器（视题目需求：数组/字符串/数字）
  const res = [];
  // 3. 启动递归遍历：初始路径为空数组，传递给根节点
  traverse(root, []);
  // 4. 返回最终结果
  return res;

  // 递归遍历辅助函数：参数传递「根到当前节点的路径」
  // node：当前遍历节点；path：根到当前节点的路径（数组）
  function traverse(node, path) {
    // 递归终止：空节点直接返回
    if (node === null) return;

    // 前序位置：更新路径 → 浅拷贝原路径，添加当前节点值（核心：避免修改上一层路径）
    const newPath = [...path, node.val];

    // 【核心业务区】叶子节点：路径处理（收集/计算/比较/格式化）
    if (node.left === null && node.right === null) {
      // 示例1：收集路径数组（如[1,2,3]）
      res.push(newPath);
      // 示例2：格式化为字符串（如"1->2->3"，适配257题）
      // res.push(newPath.join('->'));
      // 示例3：反转路径并转字符串（适配988题）
      // res.push(newPath.reverse().join(''));
      return;
    }

    // 递归遍历左右子树：传递更新后的新路径
    traverse(node.left, newPath);
    traverse(node.right, newPath);
    // ✅ 无需手动回溯：newPath是浅拷贝的新数组，不影响上一层的path，递归返回后自动恢复
  }
}
```

带参遍历：「传递状态 + 访问节点」，跨节点联动
带参的traverse，核心是把「上一层节点的状态」作为参数，传递给下一层节点，让下一层能基于这个状态继续处理。

你可能会疑惑：用path数组时需要push/pop回溯，为什么带参数的遍历不用？
核心原因是：JavaScript 的基本类型（数字、字符串、布尔、位掩码）是「值传递」—— 当把参数传递给下一层递归时，传递的是「值的副本」，不是原变量本身。
下一层递归对参数的修改（如newNum = curNum*10 + node.val），只会修改「副本」，不会影响上一层的原变量；
当递归返回时，上一层的参数值（如curNum）保持不变，相当于「自动回溯」，无需手动处理。

适用场景：下一层节点的处理依赖上一层的中间结果，需要「逐层传递、逐层更新」状态的需求（如路径转数字、进制转换、按层处理节点）。
核心优势：相比用path数组 + 回溯的方式，带参遍历通过值传递传递状态，递归返回后状态会「自动恢复」，无需手动执行pop等回溯操作，代码更简洁、效率更高。

历的参数都是为了传递「跨节点的状态」，常见的状态类型只有 3 种，记住后直接套用法即可，无需再纠结：
类型 1：累计值 / 中间结果（最常用，如 sumNumbers、二进制和）
作用：传递「根到当前节点的累计计算结果」，下一层基于该结果继续更新；
典型场景：路径转数字（129 题）、二进制路径转十进制（1022 题）、路径节点值求和；
核心更新逻辑：新状态 = 上一层状态 * 基数 + 当前节点值（基数可 10/2 / 等，依题目而定）。
类型 2：层数 / 深度（如二叉树右视图、按层收集节点）
作用：传递「当前节点所在的层数 / 深度」，实现按层处理节点；
典型场景：二叉树右视图（199 题 DFS 解法）、按层收集节点值（二维数组）、找第 k 层的节点；
示例（右视图 DFS 解法，传递层数参数）：
```javascript

var rightSideView = function(root) {
  const res = [];
  traverse(root, 0); // 第二个参数：当前节点的层数（从0开始）
  return res;

  function traverse(node, depth) {
    if (!node) return;
    // 层数=结果数组长度 → 该层第一个访问的节点（右子树先遍历，即为右视图节点）
    if (depth === res.length) res.push(node.val);
    traverse(node.right, depth + 1); // 层数+1传递给下一层
    traverse(node.left, depth + 1);
  }
};
```
类型 3：特征统计状态（如伪回文路径、奇偶性统计）
作用：传递「根到当前节点的特征统计结果」，如下一层继续更新统计状态；
典型场景：伪回文路径（572 题，位掩码统计奇偶）、路径中奇数节点的数量统计；
示例（伪回文路径，传递位掩码参数）：
```javascript

var pseudoPalindromicPaths = function(root) {
  let res = 0;
  traverse(root, 0); // 第二个参数：位掩码（统计1-9出现次数的奇偶）
  return res;

  function traverse(node, mask) {
    if (!node) return;
    mask ^= 1 << (node.val - 1); // 基于上一层mask更新当前mask
    if (!node.left && !node.right) {
      if ((mask & (mask - 1)) === 0) res++;
      return;
    }
    traverse(node.left, mask); // 传递更新后的mask给下一层
    traverse(node.right, mask);
  }
};
```

### 1.2 层序遍历模板（BFS+队列，适配层间节点类问题）

层序遍历（广度优先搜索BFS）的核心是**按层处理节点**，通过队列控制「一层一遍历」，适合需要按层操作节点的场景（如取每层最后一个节点、层内节点统计），逻辑直观，符合人类「从上到下、从左到右」的观察习惯。

```JavaScript

function fn(root) {
  // 1. 处理空树边界
  if (root === null) return [];
  // 2. 定义结果容器
  const res = [];
  // 3. 初始化队列，存入根节点（队列是层序遍历的核心载体）
  const queue = [root];

  // 4. 层序遍历主循环：队列非空则继续
  while (queue.length) {
    // 5. 记录当前层节点数（关键：确定每层的遍历边界）
    const curLevelSize = queue.length;

    // 6. 遍历当前层所有节点
    for (let i = 0; i < curLevelSize; i++) {
      // 7. 取出队首节点（当前层的待处理节点）
      const curNode = queue.shift();

      // 【核心业务区】视题目需求编写逻辑（如取层内特定节点、层内统计）
      // 例：取每层最后一个节点 → if (i === curLevelSize - 1) { ... }

      // 8. 子节点入队：左子节点先入，右子节点后入（保证层内顺序）
      if (curNode.left) queue.push(curNode.left);
      if (curNode.right) queue.push(curNode.right);
    }

    // 可选：整层遍历完成后统一处理（如层内节点汇总）
  }

  // 9. 返回最终结果
  return res;
}
```

#### 模板核心要点

- 层边界控制：`curLevelSize = queue.length`是层序遍历的灵魂，确保每次循环只处理「当前层」的节点，不与下一层混淆；

- 队列操作：`shift`（取队首）和`push`（队尾入子节点）配合，实现节点的按层传递；

- 层内顺序：左子节点先入队，保证层内节点遍历顺序与「从左到右」的直观顺序一致。

## 二、遍历模板实战：6道高频题手把手解

以下6道题覆盖二叉树路径、层序的所有高频考法，全部基于上述模板实现，**保留模板核心结构，仅修改「核心业务区」代码**，让你直观感受「套模板解题」的高效性。同时会标注**易踩坑点**和**优化技巧**，兼顾正确性和解题效率。

### 2.1 递归遍历实战1：二叉树的所有路径（力扣257）

#### 题目要求

给你二叉树的根节点，按任意顺序返回所有从根节点到叶子节点的路径，路径格式为`"1->2->3"`。

#### 解题思路

- 模板：直接套用**递归遍历模板**；

- 核心业务：叶子节点处将`path`数组格式化为`->`连接的字符串，存入结果容器。

#### 套模板实现代码（无冗余，直接通关）

```JavaScript

var binaryTreePaths = function(root) {
  if (root === null) return [];
  const res = [];
  const path = [];
  traverse(root);
  return res;

  function traverse(node) {
    if (node === null) return;
    path.push(node.val); // 前序入栈

    // 核心业务：叶子节点格式化路径并收集
    if (node.left === null && node.right === null) {
      res.push(path.join('->'));
      path.pop(); // 叶子节点提前回溯，优化效率
      return;
    }

    traverse(node.left);
    traverse(node.right);
    path.pop(); // 后序出栈
  }
};
```

#### 关键优化

叶子节点处**提前回溯+return**，避免后续无意义的代码执行，减少递归栈开销。

### 2.2 递归遍历实战2：求根节点到叶节点数字之和（力扣129）

#### 题目要求

树中每个节点存0-9的数字，根到叶的路径代表一个数字（如1→2→3代表123），计算所有根到叶数字的和。

#### 解题思路

- 模板：基于递归遍历模板优化（无需显式`path`，动态计算路径值）；

- 核心优化：路径值可通过`curNum = curNum * 10 + node.val`动态计算（值传递，无需回溯），替代`path`数组，降低空间复杂度；

- 核心业务：叶子节点处将动态计算的路径值累加到结果。

#### 套模板优化代码（最优解，无path数组）

```JavaScript
/**
 * @param {TreeNode} root
 * @return {number}
 */
function sumNumbers(root) {
  // 1. 处理空树边界：空树返回0（数字，匹配题目要求）
  if (root === null) return 0;
  // 2. 定义结果容器：数字类型，初始为0
  let res = 0;
  // 3. 启动递归遍历：初始前序和为0（无节点时的基础值）
  traverse(root, 0);
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：prevSum=根到当前节点父节点的路径和（上一层状态）
  function traverse(node, prevSum) {
    // 递归终止：空节点直接返回
    if (node === null) return;

    // 前序位置：更新状态，计算根到当前节点的路径和（核心）
    const curSum = 10 * prevSum + node.val;

    // 【核心业务区】叶子节点：累加路径和到结果
    if (node.left === null && node.right === null) {
      res += curSum; // 累加
      return; // 可选：提前返回，避免无意义的递归
    }

    // 递归遍历左右子树：传递当前状态给下一层
    traverse(node.left, curSum);
    traverse(node.right, curSum);

    // 无需后序回溯：prevSum/curSum是值传递，递归返回后自动恢复上一层状态
  }
}
```

#### 核心优势

去掉`path`数组后，空间复杂度从O(n)降至O(h)（h为树的高度，仅递归栈开销），计算效率远高于数组存储+事后遍历计算。

### 2.3 层序遍历实战：二叉树的右视图（力扣199）

#### 题目要求

想象站在二叉树右侧，按从上到下顺序返回能看到的节点值（左子树更高时，能看到左子树高出的部分）。

#### 解题思路

- 模板：直接套用**层序遍历模板**；

- 核心业务：每层遍历的最后一个节点（`i === curLevelSize - 1`）即为右侧能看到的节点，直接存入结果。

#### 套模板实现代码（最优解，逻辑直观）

```JavaScript

var rightSideView = function(root) {
  if (root === null) return [];
  const res = [];
  const queue = [root];

  while (queue.length) {
    const curLevelSize = queue.length;
    for (let i = 0; i < curLevelSize; i++) {
      const curNode = queue.shift();

      // 核心业务：取每层最后一个节点
      if (i === curLevelSize - 1) {
        res.push(curNode.val);
      }

      if (curNode.left) queue.push(curNode.left);
      if (curNode.right) queue.push(curNode.right);
    }
  }

  return res;
};
```

#### 补充思路

也可通过「根→右→左」的DFS实现，但层序遍历更符合本题的直观逻辑，代码更易理解和维护。

### 2.4 递归遍历实战3：从叶结点开始的最小字符串（力扣988）

#### 题目要求

节点值为0-25（对应a-z），返回从叶节点到根节点的**字典序最小**字符串（如"z" < "ab"）。

#### 解题思路

- 模板：套用递归遍历模板，保留`path`记录节点值；

- 核心业务：叶子节点处将`path`反转（叶→根）并转为字符串，与当前最小值比较，更新最小字符串；

- 关键细节：字典序可直接用JavaScript字符串`<`比较（按Unicode编码，与字母字典序一致）。

#### 套模板实现代码（避坑版，正确处理字典序）

```JavaScript
function smallestFromLeaf(root) {
  // 1. 处理空树边界：题目要求空树返回空字符串
  if (root === null) return '';
  // 2. 定义结果容器：初始为空字符串，用于存储字典序最小的叶→根字符串
  let res = '';
  // 3. 启动递归遍历：初始路径为空字符串（根节点无父节点）
  traverse(root, '');
  // 4. 返回最终结果
  return res;

  // 带参遍历函数：
  // node - 当前遍历节点；path - 父节点到根节点的字符拼接字符串（叶→根格式）
  function traverse(node, path) {
    // 递归终止：空节点直接返回，防止无限递归
    if (node === null) return;

    // 前序位置：核心技巧→头部拼接，天然生成当前节点到根的叶→根字符串
    // 步骤1：节点值转对应字符（0→a，25→z，97是a的ASCII码）
    const curChar = String.fromCharCode(node.val + 97);
    // 步骤2：当前字符拼接到路径头部，形成新的叶→根路径
    const newPath = curChar + path;

    // 【核心业务区】叶子节点：比较并更新字典序最小的字符串
    if (node.left === null && node.right === null) {
      // 首次赋值 或 当前字符串字典序更小，更新结果
      if (res === '' || newPath < res) {
        res = newPath;
      }
      return; // 提前返回，避免对空左右子树的无意义递归
    }

    // 递归遍历左右子树：传递新的叶→根路径，自动回溯（无手动操作）
    traverse(node.left, newPath);
    traverse(node.right, newPath);
  }
}
```

#### 避坑点

切勿用「节点值和」判断字典序（如z(25)和a(0)+b(1)，和25>1但字典序z<a b），需直接比较字符串本身。

### 2.5 递归遍历实战4：从根到叶的二进制数之和（力扣1022）

#### 题目要求

节点值为0或1，根到叶的路径代表二进制数（最高有效位开始），计算所有二进制数的十进制和。

#### 解题思路

- 模板：同129题，基于递归遍历模板优化，动态计算二进制值；

- 核心优化：二进制转十进制可通过`curNum = curNum * 2 + node.val`实现（左移1位+当前值），替代`Math.pow`，效率更高；

- 核心业务：叶子节点处将动态计算的十进制值累加到结果。

#### 套模板优化代码（最优解，无path数组）

```JavaScript

function sumRootToLeaf(root) {
  // 1. 处理空树边界
  if (root === null) return 0;
  // 2. 定义结果容器（视题目需求，数组/数字/字符串）
  let res = 0;
  // 3. 定义路径容器，用于回溯记录根到当前节点的轨迹
  // 4. 启动递归遍历
  traverse(root,0);
  // 5. 返回最终结果
  return res;

  // 递归遍历辅助函数（闭包共享外层res、path）
  function traverse(node,prevSum) {
    // 递归终止：空节点直接返回，防止无限递归
    if (node === null) return;

    const curSum = 2*prevSum+node.val

    // 【核心业务区】视题目需求编写逻辑（如叶子节点判断、路径处理）
    if (node.left === null && node.right === null) {
      // 叶子节点：通常是路径处理的关键节点（收集/计算/判断）
      res+=curSum
    }

    // 递归遍历左右子树（必须先左后右，不可重复遍历）
    traverse(node.left,curSum);
    traverse(node.right,curSum);

    // 后序位置：离开节点，执行「出栈」操作（核心：回溯，恢复轨迹）
  }
}
```

#### 核心知识点

二进制数的左移运算（`*2`）是最高效的进制转换方式，避免了数组存储和幂运算的额外开销。

### 2.6 递归遍历实战5：二叉树中的伪回文路径（力扣572）

#### 题目要求

节点值为1-9，根到叶路径为「伪回文」指路径值的排列能形成回文，统计伪回文路径的数目。

#### 解题思路

- 模板：基于递归遍历模板优化，用**位掩码**替代`path`统计路径特征（无需存储完整路径）；

- 核心知识点：伪回文判断条件 → 路径中**奇数次数的数字≤1**（偶数长度路径为0，奇数长度为1）；

- 位掩码原理：用9位二进制数统计1-9的出现奇偶性（0=偶，1=奇），叶子节点处通过`mask & (mask-1) === 0`判断是否为伪回文。

#### 套模板优化代码（位掩码最优解，空间O(1)）

```JavaScript

function pseudoPalindromicPaths(root) {
  // 1. 处理空树边界
  if (root === null) return 0;
  // 2. 定义结果容器（统计伪回文路径数量）
  let res = 0;
  // 3. 启动递归遍历：初始位掩码为0（二进制全0，对应所有数字出现次数为偶，替代原计数数组全0）
  traverse(root, 0);
  // 4. 返回最终结果
  return res;

  // 递归遍历辅助函数（闭包共享外层res）
  // node：当前遍历节点；mask：位掩码（核心：用二进制位记录1-9出现次数的奇偶性，替代原recordArr）
  // 位掩码规则：二进制第1-9位对应数字1-9，位值0=偶次、1=奇次（与原数组值定义完全一致）
  function traverse(node, mask) {
    // 递归终止：空节点直接返回，防止无限递归
    if (node === null) return;

    // 前序位置：更新位掩码（替代原数组浅拷贝+%2翻转奇偶性）
    // 核心位运算：1 << (node.val - 1) → 将1移到对应数字的二进制位；^ 异或操作 → 0↔1翻转奇偶性（与原(val+1)%2效果一致）
    const newMask = mask ^ (1 << (node.val - 1));

    // 【核心业务区】叶子节点：判定当前路径是否为伪回文（替代原数组遍历统计1的数量）
    if (node.left === null && node.right === null) {
      // 位掩码核心判定：newMask & (newMask - 1) === 0 → 表示二进制中1的数量≤1
      // 天然覆盖原isEven的两种情况：1的数量0（偶数长度路径）、1的数量1（奇数长度路径），无需单独标记路径长度
      if ((newMask & (newMask - 1)) === 0) {
        res++;
      }
      return;
    }

    // 递归遍历左右子树：传递更新后的位掩码（值传递，自动回溯，替代原数组浅拷贝的自动回溯）
    traverse(node.left, newMask);
    traverse(node.right, newMask);
    // 无需后序回溯：位掩码是数字（基本类型），值传递后子树修改不影响上层，自动恢复状态
  }
}
// function pseudoPalindromicPaths(root) {
//   // 1. 处理空树边界
//   if (root === null) return 0;
//   // 2. 定义结果容器（视题目需求，数组/数字/字符串）
//   let res = 0;
//   // 3. 定义路径容器，用于回溯记录根到当前节点的轨迹
//   // 4. 启动递归遍历
//   traverse(root,new Array(10).fill(0),true);
//   // 5. 返回最终结果
//   return res;

//   // 递归遍历辅助函数（闭包共享外层res、path）
//   function traverse(node, recordArr,isEven) {
//     // 递归终止：空节点直接返回，防止无限递归
//     if (node === null) return;

//     // 前序位置：进入节点，执行「入栈」操作（核心：记录轨迹）
//     const newRecordArr = [...recordArr]
//     newRecordArr[node.val] = (newRecordArr[node.val]+1)%2
//     isEven = !isEven
//     // 【核心业务区】视题目需求编写逻辑（如叶子节点判断、路径处理）
//     if (node.left === null && node.right === null) {
//       // 叶子节点：通常是路径处理的关键节点（收集/计算/判断）
//       if(isEven){
//         const isR = newRecordArr.every(item=>item === 0)
//         if(isR){
//           res++
//         }
//         return
//       }
//       // 只有一个1，其他都是0
//       let oneCount = 0
//       let zeroCount = 0
//       for(let i=0;i<newRecordArr.length;i++){
//         if(newRecordArr[i]===1 ){
//           oneCount++
//           if(oneCount>1){
//             return
//           }
//         }
//         if(newRecordArr[i]===0 ){
//           zeroCount++

//         }
//       }
//       if(oneCount === 1 && zeroCount === newRecordArr.length-1){
//         res++
//         return
//       }

//     }

//     // 递归遍历左右子树（必须先左后右，不可重复遍历）
//     traverse(node.left, newRecordArr, isEven);
//     traverse(node.right, newRecordArr, isEven);
//   }
// }

#### 基础版替代方案

若对位掩码不熟悉，可改用数组统计数字出现次数（逻辑更直观），仍基于递归模板实现，仅修改核心业务区即可。

## 三、遍历思维解题核心总结（避坑+优化）

### 3.1 两大模板适用场景速判

|遍历模板|核心适用场景|典型题目|核心优势|
|---|---|---|---|
|递归遍历（前序+回溯）|根到叶路径类问题（需跟踪节点轨迹）|257、129、988、1022、572|天然记录路径，回溯逻辑简单，可灵活优化（动态值/位掩码）|
|层序遍历（BFS+队列）|层间节点类问题（需按层处理节点）|199、二叉树层序遍历、每层平均值|按层处理，逻辑直观，符合人类观察习惯|
### 3.2 递归遍历模板通用避坑点

1. 切勿重复遍历子树（如两次`traverse(node.left)`，遗漏`traverse(node.right)`），导致右子树永远无法访问；

2. 需要修改的结果变量（如`res=0`、`minStr=''`）必须用`let`声明，`const`声明的变量不可重新赋值，会报语法错误；

3. 回溯操作（`path.pop`）必须与入栈操作（`path.push`）成对出现，避免路径轨迹混乱；

4. 仅在**叶子节点**处理核心业务，非叶子节点不处理（题目均要求「根到叶路径」）。

### 3.3 遍历模板通用优化技巧

1. **路径优化**：路径转数字类问题（129、1022），优先用**动态值计算**替代显式`path`数组，减少内存开销，提升效率；

2. **特征统计优化**：路径特征统计类问题（572），优先用**位掩码**（节点值范围小）替代`path`/哈希表，空间复杂度降至O(1)；

3. **提前终止**：叶子节点处理完后可**提前回溯+return**，避免后续无意义的递归和回溯操作；

4. **值传递替代回溯**：动态值、位掩码等**值传递**参数，递归返回后会自动恢复上一层状态，无需手动执行回溯操作，简化代码。

### 3.4 核心解题心法

**「模板定结构，业务填细节」**—— 二叉树遍历题的核心逻辑高度统一，无需为每道题重新设计遍历框架。只需根据题目场景选择对应的模板，在模板的「核心业务区」编写少量代码即可解决问题。

真正的解题难点不在于遍历本身，而在于**业务逻辑的转化**和**优化技巧的运用**：

- 把题目要求转化为「叶子节点/层内节点的处理规则」；

- 根据数据特征选择最优的轨迹记录方式（显式path/动态值/位掩码）。

## 四、最后：从模板到灵活运用

本文的模板是「入门抓手」，背会模板能解决90%的二叉树遍历题，但真正的算法能力在于**理解模板背后的逻辑**，并能根据题目需求灵活调整：

- 递归遍历不仅限于前序，可根据需求在中序/后序位置编写业务逻辑（如二叉树的中序遍历有序性）；

- 层序遍历可增加层容器，收集每层的所有节点（如二叉树的层序遍历输出二维数组）；

- 复杂问题可结合两种遍历思维（如先层序遍历确定树的高度，再递归遍历处理路径）。

通过本文的6道实战题，你已经掌握了遍历思维的核心用法，后续只需多做同类题，熟练运用「模板+优化技巧」，就能轻松搞定所有二叉树遍历相关的高频考点！

<!-- ## 【练习】用「遍历」思维解题 I


一般来说，如果让你在二叉树的「树枝」上做文章，那么用遍历的思维模式解题是比较自然的想法。

递归遍历的模板

```js
function fn(root){
  // 先处理null的情况
  if(root === null) return []
  // 收集答案 视情况定义
  const res = []
  // 处理path  视情况定义
  const path = []
  // 处理层数  视情况定义
  let level = 0
  // 走一趟遍历，遍历过程中处理上面的值
  traverse(root)
  // res就是需要的结果
  return res


  // 遍历函数
  function traverse(node){
    // 空节点就返回
    if(node === null) return
    // 需要进入节点干活的就在这里 res看情况处理
    // 层开始变多
    level++
    // 首次路过节点
    path.push(node.val)
    

    traverse(node.left)
    // 需要左子树信息的 或者在右子树之前处理信息的 在这里干活 res看情况处理
    traverse(node.left)

    // 离开节点干活的在这里 res看情况处理
    // 回到上层
    level--
    // path回退
    path.pop()

  }


}
```

层序遍历的模板

```js
function fn(root){
  // 先处理null的情况
  if(root === null) return []
  // 收集答案 视情况定义
  const res = []
  
  // 处理层数  视情况定义
  let level = 0

  const queue = [root]
  while(queue.length){
    // 开始进层  
    level++
    // 当前层的节点数
    const curLevelNodeCount = queue.length
    // 遍历curLevelNodeCount次 正好这层遍历完  视情况处理res
    // 开始遍历这层的每个节点
    for(let i=0;i<curLevelNodeCount;i++){
      // 当前节点是队列取一个 处理当前层当前节点  视情况处理res
      const curNode = queue.shift()
      console.log(curNode)
      // 当前节点的左节点进队列
      if(curNode.left) {
        queue.push(curNode.left)
      }
      // 当前节点的右节点进队列
      if(curNode.right) {
        queue.push(curNode.right)
      }
      
    }
    // 这层节点遍历完了  视情况处理res

  }
  // queue为空的时候，整个树也遍历完了 视情况处理res
  
  

  // res就是需要的结果
  return res
}
```

257. 二叉树的所有路径 {#slug_binary-tree-paths}
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

这里套模板，在前序那，如果是叶子节点更新res就没了！！！！

```js
function fn(root){
  if(root === null) return []
  const res = []
  const path = []
  // let level = 0
  traverse(root)
  return res


  function traverse(node){
    if(node === null) return
    // level++
    path.push(node.val)

  // 这里用前序就可以了，叶子节点的时候 更新res 就这样
    if(node.left ===null && node.right ===null){
      res.push([...path])
    }
    

    traverse(node.left)
    traverse(node.left)

    // level--
    path.pop()
  }


}
```


129. 求根节点到叶节点数字之和 {#slug_sum-root-to-leaf-numbers}
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

思路：res肯定是数字类型，中间肯定累加和，这个和刚刚的路径差不多，

```js
 
function fn(root){
  if(root === null) return 0
  const res = 0
  // 路径还是记录 这样知道叶子节点的时候的当前值
  const path = []
  // let level = 0
  traverse(root)
  return res


  function traverse(node){
    if(node === null) return
    // level++
    path.push(node.val)

  // 这里用前序就可以了，叶子节点的时候 更新res 就这样
    if(node.left ===null && node.right ===null){
      let s = path.length - 1
      // 根据路径算当前的值
      const curNum = path.reduce((acc,cur,index)=>{
        acc+= Math.pow(10,s-index)*cur
        return acc
      },0)
      res+=curNum
    }
    

    traverse(node.left)
    traverse(node.left)

    // level--
    path.pop()
  }


}
```

199. 二叉树的右视图 {#slug_binary-tree-right-side-view}
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 
这题有个细节，我开始以为 纯右边就行，后来发现如果左边高的话，是能看到高出的那部分节点，
这里用层序遍历最合适，每层的最后一个元素就是当层能看到的，push就完事


```js
function fn(root){
  if(root === null) return []
  const res = []
  
  let level = 0

  const queue = [root]
  while(queue.length){
    level++
    const curLevelNodeCount = queue.length
    for(let i=0;i<curLevelNodeCount;i++){
      const curNode = queue.shift()

      // 当前层最后一个节点 push进res完事！
      if(i === curLevelNodeCount-1){
        res.push(curNode.val)
      }

      console.log(curNode)
      if(curNode.left) {
        queue.push(curNode.left)
      }
      if(curNode.right) {
        queue.push(curNode.right)
      }

    }

  }
  
  

  // res就是需要的结果
  return res
}
```

988. 从叶结点开始的最小字符串 {#slug_smallest-string-starting-from-leaf}
给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个 [0, 25] 范围内的值，分别代表字母 'a' 到 'z'。

返回 按字典序最小 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。

注：字符串中任何较短的前缀在 字典序上 都是 较小 的：

例如，在字典序上 "ab" 比 "aba" 要小。叶结点是指没有子结点的结点。 
节点的叶节点是没有子节点的节点。

这个和那个叶子路径很像，

```js
function fn(root){
  // 先处理null的情况
  if(root === null) return ''
  // 收集和最小的路径
  const res = []
  // 路径
  const path = []
  // 处理最小值
  let minSum = Infinity
  // 处理层数  视情况定义
  let level = 0
  // 走一趟遍历，遍历过程中处理上面的值
  traverse(root)
  // res是最小的数字集合，需要处理成字符串
  const map = new Map([[a,0],.....])
  // 注意是反向遍历
  return res.reduceRight((acc,cur)=>{
    acc+=map.get(cur)
    return acc
  },'')


  // 遍历函数
  function traverse(node){
    // 空节点就返回
    if(node === null) return
    // 需要进入节点干活的就在这里 res看情况处理
    // 层开始变多
    level++
    // 首次路过节点
    path.push(node.val)
    if(node.left === null && node.right === null){
      const curSum = path.reduce((acc,cur)=>{
        acc+=cur
        return acc
      },0)
      if(curSum<minSum){
        minSum = curSum
        res = [...path]
      }
    }
    

    traverse(node.left)
    // 需要左子树信息的 或者在右子树之前处理信息的 在这里干活 res看情况处理
    traverse(node.left)

    // 离开节点干活的在这里 res看情况处理
    // 回到上层
    level--
    // path回退
    path.pop()

  }


}

```

1022. 从根到叶的二进制数之和 {#slug_sum-of-root-to-leaf-binary-numbers}
给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。

例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。
对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

返回这些数字之和。题目数据保证答案是一个 32 位 整数。


```js
function fn(root){
  // 先处理null的情况
  if(root === null) return 0
  // 收集答案 视情况定义
  const res = 0
  // 处理path  视情况定义
  const path = []
  // 处理层数  视情况定义
  let level = 0
  // 走一趟遍历，遍历过程中处理上面的值
  traverse(root)
  // res就是需要的结果
  return res


  // 遍历函数
  function traverse(node){
    // 空节点就返回
    if(node === null) return
    // 需要进入节点干活的就在这里 res看情况处理
    // 层开始变多
    level++
    // 首次路过节点
    path.push(node.val)

    if(node.left ===null && node.right ===null ){
      const s = path.length - 1
      const curNum = path.reduce((acc,cur,index)=>{
        acc+= Math.pow(2,s-index)*cur
        return acc
      },0)
      res+=curNum
    }
    

    traverse(node.left)
    // 需要左子树信息的 或者在右子树之前处理信息的 在这里干活 res看情况处理
    traverse(node.left)

    // 离开节点干活的在这里 res看情况处理
    // 回到上层
    level--
    // path回退
    path.pop()

  }


}
```
57. 二叉树中的伪回文路径 {#slug_pseudo-palindromic-paths-in-a-binary-tree}
给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。

请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。


```js
function fn(root){
  // 先处理null的情况
  if(root === null) return 0
  // 收集答案 视情况定义
  const res = 0
  // 处理path  视情况定义
  const path = []
  // 处理层数  视情况定义
  let level = 0
  // 走一趟遍历，遍历过程中处理上面的值
  traverse(root)
  // res就是需要的结果
  return res


  // 遍历函数
  function traverse(node){
    // 空节点就返回
    if(node === null) return
    // 需要进入节点干活的就在这里 res看情况处理
    // 层开始变多
    level++
    // 首次路过节点
    path.push(node.val)
    
    if(isR(path)){
      res++
    }

    traverse(node.left)
    // 需要左子树信息的 或者在右子树之前处理信息的 在这里干活 res看情况处理
    traverse(node.left)

    // 离开节点干活的在这里 res看情况处理
    // 回到上层
    level--
    // path回退
    path.pop()

  }


}

function isR(strArr){
  const arr = [...strArr]
  arr.sort((x,y)=>x-y)
  for()

}
``` --> -->
