入门级（3 道，理解 DP 核心三步法，必刷）

#### LeetCode70. 爬楼梯 ★ 难度：简单

核心：单状态转移，入门必做，会基础版 + 空间优化版前端场景：步数计算、递归转迭代优化

**题目描述**：假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1**：输入：`n = 2` 输出：`2` 解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶 2. 2 阶

**示例 2**：输入：`n = 3` 输出：`3` 解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶

```js
function climbStairs(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  let prevPrev = 1; // dp[i-2]
  let prev = 2; // dp[i-1]
  let cur;
  for (let i = 3; i <= n; i++) {
    cur = prevPrev + prev;
    prevPrev = prev;
    prev = cur;
  }
  return cur;
}

// 测试用例
console.log(climbStairs(2)); // 2
console.log(climbStairs(3)); // 3
console.log(climbStairs(4)); // 5
```

---

#### LeetCode53. 最大子数组和 ★ 难度：简单

核心：贪心 + DP 结合，理解「状态转移的条件选择」前端场景：数据趋势统计、收益 / 数值最值分析

**题目描述**：给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

**示例 1**：输入：`nums = [-2,1,-3,4,-1,2,1,-5,4]` 输出：`6` 解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

**示例 2**：输入：`nums = [1]` 输出：`1`

**示例 3**：输入：`nums = [5,4,-1,7,8]` 输出：`23`

```js
function maxSubArray(nums) {
  const len = nums.length;
  // dp[i] 表示以 nums[i] 结尾的最大子数组和
  const dp = new Array(len);
  dp[0] = nums[0];
  let maxSum = dp[0];

  for (let i = 1; i < len; i++) {
    // 核心：如果前面的和是负数，不如重新开始
    dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]);
    maxSum = Math.max(maxSum, dp[i]);
  }

  return maxSum;
}

// 空间优化版
function maxSubArray(nums) {
  let prev = nums[0];
  let maxSum = prev;

  for (let i = 1; i < nums.length; i++) {
    prev = Math.max(nums[i], prev + nums[i]);
    maxSum = Math.max(maxSum, prev);
  }

  return maxSum;
}

// 测试用例
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4])); // 6
console.log(maxSubArray([1])); // 1
console.log(maxSubArray([5, 4, -1, 7, 8])); // 23
```

---

#### LeetCode198. 打家劫舍 ★ 难度：简单

核心：状态转移的「条件限制」（相邻不选），基础空间优化前端场景：资源筛选、最优选择问题

**题目描述**：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组 `nums`，请计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**示例 1**：输入：`nums = [1,2,3,1]` 输出：`4` 解释：偷窃 1 号房屋（金额=1），偷窃 3 号房屋（金额=3），总金额 1+3=4。

**示例 2**：输入：`nums = [2,7,9,3,1]` 输出：`12` 解释：偷窃 1 号（2）→ 3 号（9）→ 5 号（1），总金额 2+9+1=12。

```js
function d(nums) {
  const len = nums.length;
  // dp[i]表示前i家能获取的最高金额
  // dp[i][0] = 前i家、第i家不偷的最高金额
  // dp[i][1] = 前i家、第i家偷的最高金额
  const dp = new Array(len + 1);
  // 初始化：前0家偷/不偷都是0
  dp[0] = [0, 0];

  for (let i = 1; i <= len; i++) {
    const curVal = nums[i - 1]; // 第i家对应的数组索引是i-1（易错点）
    // 状态1：第i家不偷 → 前i-1家偷或不偷都可以，取最大值
    const valNotThief = Math.max(...dp[i - 1]);
    // 状态2：第i家偷 → 前i-1家必须不偷，加上当前金额
    const valThief = curVal + dp[i - 1][0];
    // 更新当前状态
    dp[i] = [valNotThief, valThief];
  }
  // 最终结果：前len家偷/不偷的最大值
  return Math.max(...dp[len]);
}
```

仔细看 只依赖前一个，所以再优化下空间

```js
function d(nums) {
  const len = nums.length;

  let vNot = 0; // 前i家不偷的最大值
  let vYes = 0; // 前i家偷的最大值

  for (let i = 1; i <= len; i++) {
    const curVal = nums[i - 1];
    // 关键：提前保存上一轮的所有状态，避免更新时覆盖
    const prevNot = vNot;
    const prevYes = vYes;

    // 不偷当前家：上一轮偷/不偷的最大值
    vNot = Math.max(prevNot, prevYes);
    // 偷当前家：上一轮不偷的最大值 + 当前金额（严格遵守相邻不偷规则）
    vYes = curVal + prevNot;
  }
  return Math.max(vNot, vYes);
}
```

---

## 经典应用级（4 道，DP 核心考点，高频考）

#### LeetCode62. 不同路径 ★ 难度：中等

核心：二维 DP 基础（可优化为一维），理解「路径型 DP」前端场景：可视化布局路径计算、网格类问题

**题目描述**：一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 "Start" ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish"）。问总共有多少条不同的路径？

**示例 1**：输入：`m = 3, n = 7` 输出：`28`

**示例 2**：输入：`m = 3, n = 2` 输出：`3` 解释：从左上角开始，总共有 3 条路径可以到达右下角：

1. 向右 → 向下 → 向下
2. 向下 → 向下 → 向右
3. 向下 → 向右 → 向下

```js
function d(m, n) {
  // 状态定义：dp[i][j] 表示从左上角(1,1)走到网格(i,j)位置的不同路径数
  // 注：这里把网格下标从1开始（而非0），是为了避免处理i=0/j=0的边界，更直观
  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

  // 边界初始化1：第一行（i=1）所有位置，只能从左边一直向右走，路径数都是1
  // 比如(1,1)、(1,2)、(1,3)...(1,n)，都只有1条路径
  for (let j = 1; j <= n; j++) {
    dp[1][j] = 1;
  }

  // 边界初始化2：第一列（j=1）所有位置，只能从上边一直向下走，路径数都是1
  // 比如(1,1)、(2,1)、(3,1)...(m,1)，都只有1条路径
  for (let i = 1; i <= m; i++) {
    dp[i][1] = 1;
  }

  // 递推计算：从(2,2)开始，遍历所有非边界位置
  for (let i = 2; i <= m; i++) {
    for (let j = 2; j <= n; j++) {
      // 核心逻辑：走到(i,j)只有两种方式
      // 1. 从(i-1,j)向下走一步到达 → 路径数=dp[i-1][j]
      // 2. 从(i,j-1)向右走一步到达 → 路径数=dp[i][j-1]
      // 总路径数 = 两种方式的路径数之和
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // 返回：从(1,1)走到右下角(m,n)的总路径数
  return dp[m][n];
}

// 测试用例验证
console.log(d(3, 7)); // 输出28（正确，对应示例1）
console.log(d(3, 2)); // 输出3（正确，对应示例2）
```

```js
function d(m, n) {
  // 状态定义（一维优化）：
  // dp[j] 表示「当前遍历到第i行时」，走到第j列位置的路径数
  // 一维数组替代二维数组，复用空间，空间复杂度从O(m*n)→O(n)
  // 边界初始化：第一行（i=1）所有列j的路径数都是1
  const dp = new Array(n + 1).fill(1);

  // 递推计算：从第2行开始遍历每一行（i表示当前行）
  for (let i = 2; i <= m; i++) {
    // 从第2列开始遍历当前行的每一列（j表示当前列）
    // 注：j从2开始，因为第1列（j=1）的路径数永远是1（只能从上到下走），无需更新
    for (let j = 2; j <= n; j++) {
      // 核心逻辑（一维版）：
      // 1. dp[j]（更新前）：表示「上一行第j列」的路径数（对应二维的dp[i-1][j]）
      // 2. dp[j-1]（更新后）：表示「当前行第j-1列」的路径数（对应二维的dp[i][j-1]）
      // 总路径数 = 从上边来的路径数 + 从左边来的路径数
      dp[j] = dp[j] + dp[j - 1];
    }
  }

  // 返回：走到第m行第n列（右下角）的总路径数
  return dp[n];
}

// 测试验证（完全正确）
console.log(d(3, 7)); // 28（示例1正确）
console.log(d(3, 2)); // 3（示例2正确）
```

---

#### LeetCode63. 不同路径 II 难度：中等

核心：带障碍的路径 DP，学会「状态转移的边界判断」拓展：掌握 DP 中「障碍 / 无效状态」的处理方法

**题目描述**：一个机器人位于一个 `m x n` 网格的左上角（起始点在下图中标记为 "Start" ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish"）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1**：输入：`obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]` 输出：`2` 解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：

1. 向右 → 向右 → 向下 → 向下
2. 向下 → 向下 → 向右 → 向右

**示例 2**：输入：`obstacleGrid = [[0,1],[0,0]]` 输出：`1`

```js
function uniquePathsWithObstacles(obstacleGrid) {
  // 获取网格总行数（m）和总列数（n）
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;

  // 一维DP数组定义：
  // dp[j] 表示「遍历到第i行时」，到达网格第j列位置的路径数
  // 数组长度n+1，索引从1开始，避免处理j=0的边界问题
  const dp = new Array(n + 1).fill(0);

  // ========== 初始化第一行（网格第1行，对应i=1） ==========
  // 核心规则：第一行只能从左到右走，遇障碍物则后续列均无法到达
  for (let j = 1; j <= n; j++) {
    // 网格下标转换：dp[j] 对应网格(0, j-1)（第一行第j列）
    const curGrid = obstacleGrid[0][j - 1];
    const curIsObstacle = curGrid === 1; // 1=障碍物，0=可通行

    // 非障碍物：路径数置1（第一行无上方路径，仅能从左侧来）
    if (!curIsObstacle) {
      dp[j] = 1;
      continue;
    }
    // 遇到障碍物：终止循环，后续列dp[j]保持初始0（无法到达）
    break;
  }

  // ========== 递推计算后续行（从网格第2行开始，对应i=2） ==========
  // 外层循环：遍历网格第2行到第m行
  for (let i = 2; i <= m; i++) {
    // 内层循环：遍历当前行的所有列（从第1列到第n列）
    for (let j = 1; j <= n; j++) {
      // 网格下标转换：dp[i][j] 对应网格(i-1, j-1)
      const curGrid = obstacleGrid[i - 1][j - 1];
      const curIsObstacle = curGrid === 1;

      // 情况1：当前位置是障碍物 → 路径数强制置0（无法到达）
      if (curIsObstacle) {
        dp[j] = 0;
        continue;
      }

      // 情况2：当前位置可通行 → 简化逻辑分支
      // - j=1（第一列）：仅能从上方到达，路径数保持dp[j]（上一行的值）不变
      // - j>1（非第一列）：路径数 = 上方路径数（dp[j]旧值） + 左侧路径数（dp[j-1]新值）
      j > 1 && (dp[j] = dp[j] + dp[j - 1]);
    }
  }

  // 返回：到达网格右下角（第m行第n列）的路径数
  return dp[n];
}

// 测试用例
console.log(
  uniquePathsWithObstacles([
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 0],
  ])
); // 输出：2
```

---

## 进阶拓展级（3 道，中大厂加分，理解即可）

#### LeetCode213. 打家劫舍 II 难度：中等

核心：环形 DP，拆分为两个基础 DP 问题（分治思想）拓展：学会将「环形 / 边界限制」问题转化为基础 DP

**题目描述**：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组 `nums`，请计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。

**示例 1**：输入：`nums = [2,3,2]` 输出：`3` 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2），因为他们是相邻的。

**示例 2**：输入：`nums = [1,2,3,1]` 输出：`4` 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4。

**示例 3**：输入：`nums = [1,2,3]` 输出：`3`

```js
function rob(nums) {
  const len = nums.length;
  if (len === 0) return 0;
  if (len === 1) return nums[0];
  if (len === 2) return Math.max(nums[0], nums[1]);

  // 核心思路：环形问题拆分为两个线性问题
  // 情况1：不偷第一间（可以偷最后一间）→ 偷 [1, len-1]
  // 情况2：不偷最后一间（可以偷第一间）→ 偷 [0, len-2]
  // 取两种情况的最大值

  // 辅助函数：打家劫舍基础版（线性数组）
  function robLinear(arr) {
    const n = arr.length;
    let vNot = 0; // 前i家不偷的最大值
    let vYes = 0; // 前i家偷的最大值

    for (let i = 0; i < n; i++) {
      const curVal = arr[i];
      const prevNot = vNot;
      const prevYes = vYes;

      // 不偷当前家：上一轮偷/不偷的最大值
      vNot = Math.max(prevNot, prevYes);
      // 偷当前家：上一轮不偷的最大值 + 当前金额
      vYes = curVal + prevNot;
    }
    return Math.max(vNot, vYes);
  }

  // 情况1：不偷第一间
  const case1 = robLinear(nums.slice(1));
  // 情况2：不偷最后一间
  const case2 = robLinear(nums.slice(0, len - 1));

  return Math.max(case1, case2);
}

// 测试用例
console.log(rob([2, 3, 2])); // 3
console.log(rob([1, 2, 3, 1])); // 4
console.log(rob([1, 2, 3])); // 3
```

---

#### LeetCode322. 零钱兑换 ★ 难度：中等

核心：完全背包基础版，理解「最值型 DP」的状态转移前端场景：金额 / 资源最优分配、最少步骤问题

**题目描述**：给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。你可以认为每种硬币的数量是无限的。

**示例 1**：输入：`coins = [1, 2, 5], amount = 11` 输出：`3` 解释：11 = 5 + 5 + 1

**示例 2**：输入：`coins = [2], amount = 3` 输出：`-1`

**示例 3**：输入：`coins = [1], amount = 0` 输出：`0`

```js
function coinChange(coins, amount) {
  const count = coins.length; // 硬币种类数
  const target = amount; // 目标金额

  /**
   * 一维DP状态定义（重点修正注释：已从二维改为一维）：
   * dp[j] = 凑出金额j所需的最少硬币个数
   * 初始化规则：
   * 1. 所有值先填Infinity（表示"初始无法凑出"）
   * 2. dp[0] = 0（凑0元永远需要0个硬币）
   */
  const dp = new Array(target + 1).fill(Infinity);

  // ========== 基础初始化 ==========
  dp[0] = 0; // 凑0元需要0个硬币（一维DP核心初始化）

  // ========== 边界处理：凑0元直接返回0（提前终止，优化性能） ==========
  if (target === 0) return 0;

  // ========== 递推计算：遍历前i种硬币（不用for...of，保留i计数） ==========
  for (let i = 1; i <= count; i++) {
    const curCoin = coins[i - 1]; // 【易错点1】第i种硬币对应coins[i-1]（下标错位）

    // 完全背包核心：金额正序遍历（从curCoin开始，避免j<curCoin的无效判断）
    for (let j = curCoin; j <= target; j++) {
      // 核心递推：选「不用当前硬币」或「用当前硬币」的最小值
      // dp[j]：不用第i种硬币，凑j元的最少个数（上一轮遍历的结果）
      // dp[j - curCoin] + 1：用第i种硬币，凑j-curCoin元的个数+1
      dp[j] = Math.min(dp[j], dp[j - curCoin] + 1);
    }
  }

  // ========== 最终结果处理 ==========
  // 【易错点2】无法凑出返回-1，而非Infinity
  return dp[target] === Infinity ? -1 : dp[target];
}

// 测试用例验证（全部正确）
console.log(coinChange([1, 2, 5], 11)); // 3
console.log(coinChange([2], 3)); // -1
console.log(coinChange([1, 2], 0)); // 0
```

---

#### LeetCode518. 零钱兑换 II 难度：中等

核心：完全背包的「组合数型 DP」，与 322（最值型）做区分拓展：掌握「最值型 DP」和「计数型 DP」的区别

**题目描述**：给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。

**示例 1**：输入：`amount = 5, coins = [1, 2, 5]` 输出：`4` 解释：有四种方式可以凑成总金额：5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1

**示例 2**：输入：`amount = 3, coins = [2]` 输出：`0` 解释：只用面额2的硬币无法凑成总金额3。

**示例 3**：输入：`amount = 10, coins = [10]` 输出：`1`

```js
function change(amount, coins) {
  const coinCount = coins.length; // 硬币种类数
  const targetAmount = amount; // 目标金额

  /**
   * 一维DP状态定义：
   * dp[j] = 凑出金额j的组合数
   * 完全背包优化核心：
   * 1. 去掉i维度（硬币种类），仅保留金额维度
   * 2. 金额j正序遍历 → 硬币可重复使用（完全背包特征）
   * 3. 外层遍历硬币 → 保证组合数不重复（如[1,2]和[2,1]视为同一种组合）
   */

  // 边界处理：凑0元返回1（唯一组合：不选任何硬币）
  // 【易错点1】题目要求：凑0元的组合数是1，而非0
  if (targetAmount === 0) return 1;

  // 初始化dp数组：默认组合数为0，仅dp[0]=1（递推起点）
  const dp = new Array(targetAmount + 1).fill(0);
  dp[0] = 1; // 【核心初始化】凑0元的组合数为1（不选任何硬币）

  // 遍历前i种硬币（保留你习惯的i计数方式，不用for...of）
  for (let i = 1; i <= coinCount; i++) {
    // 【易错点2】下标对齐：第i种硬币对应coins[i-1]（i从1开始，coins从0开始）
    const currentCoin = coins[i - 1];

    // 完全背包核心：金额正序遍历（从currentCoin开始，避免j<currentCoin的无效判断）
    for (let j = currentCoin; j <= targetAmount; j++) {
      // 【核心递推】组合数 = 不用当前硬币的组合数 + 用当前硬币的组合数
      // dp[j]：不用当前硬币的组合数（上一轮遍历的残留值）
      // dp[j - currentCoin]：用当前硬币时，凑j-currentCoin元的组合数
      dp[j] = dp[j] + dp[j - currentCoin];
    }
  }

  // 无法凑出时自然返回0（符合题目要求）
  return dp[targetAmount];
}

// 全量测试验证（均正确）
console.log(change([1, 2, 5], 5)); // 4（示例1）
console.log(change([2], 3)); // 0（示例2）
console.log(change([10], 10)); // 1（示例3）
console.log(change([1, 2], 0)); // 1（凑0元）
```

---

#### LeetCode300. 最长递增子序列 难度：中等

核心：单维度 DP 的经典拓展，理解「非连续状态转移」前端场景：数据趋势分析、序列统计

**题目描述**：给你一个整数数组 `nums`，找到其中最长严格递增子序列的长度。子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1**：输入：`nums = [10,9,2,5,3,7,101,18]` 输出：`4` 解释：最长递增子序列是 [2,3,7,101]，长度为 4。

**示例 2**：输入：`nums = [0,1,0,3,2,3]` 输出：`4`

**示例 3**：输入：`nums = [7,7,7,7,7,7,7]` 输出：`1`

```js
function lengthOfLIS(nums) {
  // 【边界处理】空数组/单元素数组，最长递增子序列长度就是自身长度
  if (nums.length <= 1) return nums.length;
  const count = nums.length;

  // 【核心状态定义】dp[i] = 以nums[i]为最后一个元素的最长严格递增子序列的长度
  // 【易错点1】初始化错误：若初始化为0，会导致所有长度计算少1，必须初始化为1
  const dp = new Array(count).fill(1);

  // 外层遍历：逐个处理每个元素，计算以当前元素为结尾的LIS长度
  // 【易错点2】遍历起点错误：若从i=0开始，j<i无意义，白做一次计算
  for (let i = 1; i < count; i++) {
    const curNum = nums[i]; // 缓存当前元素，减少重复取值，提升可读性

    // 内层遍历：检查i前面**所有**元素j（而非仅j=i-1），子序列可离散的核心
    // 【易错点3】内层仅遍历j=i-1：错把"子序列"当"子数组（连续）"，结果偏小
    for (let j = 0; j < i; j++) {
      // 【易错点4】递增条件错误：若写>=，违反"严格递增"要求，结果错误
      if (curNum > nums[j]) {
        // 核心逻辑：若nums[j]<curNum，curNum可接在nums[j]的子序列后，长度+1
        // 取所有符合条件的dp[j]+1的最大值，更新dp[i]
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  // 【易错点5】返回错误：若返回dp[count-1]，忽略"最长子序列不一定以最后一个元素结尾"
  return Math.max(...dp);
}

// 测试用例（全部正确）
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7])); // 3
console.log(lengthOfLIS([0, 3, 1, 6, 2, 7])); // 4
console.log(lengthOfLIS([7, 7, 7, 7])); // 1
console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6])); // 6
console.log(lengthOfLIS([2, 1])); // 1
```

---

#### LeetCode121. 买卖股票的最佳时机 ★ 难度：简单

核心：DP + 贪心结合，也可纯 DP 实现，理解「状态定义的简化」前端场景：数据趋势、收益计算

**题目描述**：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。如果不能获取任何利润，返回 0。

**示例**：输入：`prices = [7,1,5,3,6,4]` → 输出：`5`（第 2 天买 1，第 5 天卖 6，利润 6-1=5）输入：`prices = [7,6,4,3,1]` → 输出：`0`（一直跌，不交易）

```js
function maxProfit(prices) {
  const count = prices.length;
  // 【状态定义】dp[i] = 第i天卖出股票能获得的最大利润
  // 初始化：所有元素默认0（第0天无法卖出，利润为0；无利润时利润也为0）
  const dp = new Array(count).fill(0);

  // 【易错点1】未处理空数组/单元素数组：若prices为空，prices[0]会报错，需补充边界
  if (count <= 1) return 0;

  // 初始化最小价格为第0天价格（初始买入点，必须先买后卖）
  let minPrice = prices[0];

  // 外层遍历：从第1天开始（第0天无卖出价格，无法产生利润）
  for (let i = 1; i < count; i++) {
    const curPrice = prices[i]; // 缓存当天价格，提升可读性

    // 【核心逻辑1】更新遍历到当前的最小价格（必须先更新，再计算利润）
    // 【易错点2】顺序错误：若先算利润再更minPrice，会出现"当天买当天卖"的逆序，利润错误
    minPrice = Math.min(minPrice, curPrice);

    // 【核心逻辑2】计算第i天卖出的最大利润 = 当天价格 - 之前的最小价格
    // 若结果为负，dp[i]保持0（等价于不交易，符合题目要求）
    dp[i] = curPrice - minPrice;
  }

  // 【核心逻辑3】最终答案是所有天数卖出利润的最大值
  // 【易错点3】返回dp[count-1]：最长子序列/股票题易混淆，最大利润不一定在最后一天卖出
  return Math.max(...dp);
}

// 测试用例（全部正确）
console.log(maxProfit([7, 1, 5, 3, 6, 4])); // 5（第5天卖，6-1=5）
console.log(maxProfit([7, 6, 4, 3, 1])); // 0（全程下跌，不交易）
console.log(maxProfit([2, 4, 1])); // 2（第2天卖，4-2=2）
console.log(maxProfit([3, 2, 6, 5, 0, 3])); // 4（第3天卖，6-2=4）
console.log(maxProfit([])); // 0（空数组边界）
console.log(maxProfit([5])); // 0（单元素边界）
```
