<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>前端异常采集测试</title>
  </head>
  <body>
    <button id="triggerJsError">触发JS运行时错误</button>
    <button id="triggerAxiosError">触发Axios接口异常</button>
    <button id="triggerFetchError">触发Fetch接口异常</button>
    <button id="triggerPromiseReject">触发未捕获Promise拒绝</button>

    <!-- 引入Axios（测试接口异常用） -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <script>
      // 异常采集工具类
      class ErrorMonitor {
        constructor() {
          this.init();
        }

        // 初始化所有异常监听
        init() {
          // 1. 监听JS运行时错误（包括资源加载错误）
          this.listenJsError();
          // 2. 监听未捕获的Promise拒绝
          this.listenUnhandledRejection();
          // 3. 重写XHR监听接口异常
          this.rewriteXHR();
          // 4. 重写Fetch监听接口异常
          this.rewriteFetch();
          // 5. 监听Axios接口异常（单独封装）
          this.listenAxiosError();
        }

        // 1. JS运行时错误 + 资源加载异常监听
        listenJsError() {
          window.addEventListener(
            'error',
            event => {
              // 区分资源加载异常和JS代码异常
              const isResourceError = event.target instanceof HTMLElement;
              let errorInfo = {
                type: isResourceError ? 'resource_error' : 'js_error',
                message: event.message || '资源加载失败',
                filename: event.filename || event.target?.src || event.target?.href,
                lineno: event.lineno,
                colno: event.colno,
                time: new Date().toLocaleString(),
                // 资源异常额外信息
                resourceType: isResourceError ? this.getResourceType(event.target) : null,
              };
              this.reportError(errorInfo);
            },
            true
          ); // 捕获阶段监听，确保能拿到所有错误
        }

        // 2. 未捕获的Promise拒绝（如fetch/xhr失败未catch、Promise.reject未处理）
        listenUnhandledRejection() {
          window.addEventListener('unhandledrejection', event => {
            const errorInfo = {
              type: 'unhandled_rejection',
              message: event.reason?.message || event.reason || 'Promise拒绝未处理',
              stack: event.reason?.stack || '无堆栈信息',
              time: new Date().toLocaleString(),
            };
            this.reportError(errorInfo);
            // 阻止默认行为（避免控制台报错）
            event.preventDefault();
          });
        }

        // 3. 重写XMLHttpRequest监听接口异常
        rewriteXHR() {
          const originalOpen = XMLHttpRequest.prototype.open;
          const originalSend = XMLHttpRequest.prototype.send;

          XMLHttpRequest.prototype.open = function (method, url) {
            this._errorMonitor = { method, url, startTime: Date.now() };
            return originalOpen.apply(this, arguments);
          };

          XMLHttpRequest.prototype.send = function () {
            this.addEventListener('load', () => {
              this.checkXHRError();
            });
            this.addEventListener('error', () => {
              this.checkXHRError('network_error');
            });
            this.addEventListener('abort', () => {
              this.checkXHRError('abort');
            });
            return originalSend.apply(this, arguments);
          };

          XMLHttpRequest.prototype.checkXHRError = function (errorType = 'http_error') {
            const { method, url, startTime } = this._errorMonitor || {};
            // HTTP状态码非2xx视为异常
            if (this.status < 200 || this.status >= 300 || errorType !== 'http_error') {
              const errorInfo = {
                type: 'xhr_error',
                method,
                url,
                status: this.status,
                statusText: this.statusText,
                errorType,
                duration: Date.now() - startTime,
                time: new Date().toLocaleString(),
              };
              ErrorMonitor.prototype.reportError(errorInfo);
            }
          };
        }

        // 4. 重写Fetch监听接口异常
        rewriteFetch() {
          const originalFetch = window.fetch;
          window.fetch = async function (url, options = {}) {
            const startTime = Date.now();
            const method = options.method || 'GET';
            try {
              const response = await originalFetch.apply(this, arguments);
              // HTTP状态码非2xx视为异常
              if (!response.ok) {
                const errorInfo = {
                  type: 'fetch_error',
                  method,
                  url,
                  status: response.status,
                  statusText: response.statusText,
                  errorType: 'http_error',
                  duration: Date.now() - startTime,
                  time: new Date().toLocaleString(),
                };
                ErrorMonitor.prototype.reportError(errorInfo);
              }
              return response;
            } catch (err) {
              // 网络错误、跨域等异常
              const errorInfo = {
                type: 'fetch_error',
                method,
                url,
                message: err.message,
                errorType: 'network_error',
                duration: Date.now() - startTime,
                time: new Date().toLocaleString(),
              };
              ErrorMonitor.prototype.reportError(errorInfo);
              throw err; // 抛出错误，不影响业务代码
            }
          };
        }

        // 5. Axios接口异常监听（Axios有专门的拦截器，更简单）
        listenAxiosError() {
          if (window.axios) {
            // 请求拦截器（记录请求信息）
            axios.interceptors.request.use(config => {
              config._errorMonitor = { startTime: Date.now() };
              return config;
            });
            // 响应拦截器（捕获异常）
            axios.interceptors.response.use(
              response => response,
              error => {
                const { config, response, message } = error;
                const { startTime } = config._errorMonitor || {};
                const errorInfo = {
                  type: 'axios_error',
                  method: config.method?.toUpperCase(),
                  url: config.url,
                  status: response?.status || '无状态码',
                  message: message || 'Axios请求异常',
                  errorType: response ? 'http_error' : 'network_error',
                  duration: startTime ? Date.now() - startTime : 0,
                  time: new Date().toLocaleString(),
                };
                this.reportError(errorInfo);
                return Promise.reject(error); // 抛出错误，不影响业务代码
              }
            );
          }
        }

        // 辅助：判断资源类型（img/css/js/font等）
        getResourceType(target) {
          if (target.tagName === 'IMG') return 'image';
          if (target.tagName === 'LINK' && target.rel === 'stylesheet') return 'css';
          if (target.tagName === 'SCRIPT') return 'js';
          if (target.tagName === 'VIDEO' || target.tagName === 'AUDIO') return 'media';
          return 'unknown';
        }

        // 异常上报（这里先打印到控制台，实际项目可改为发接口到后端）
        reportError(errorInfo) {
          console.log('【异常采集】', errorInfo);
          // 实际项目中可替换为：
          // fetch('/api/report-error', {
          //     method: 'POST',
          //     headers: { 'Content-Type': 'application/json' },
          //     body: JSON.stringify(errorInfo)
          // });
        }
      }

      // 初始化异常监听
      new ErrorMonitor();

      // ------------------- 测试用例：触发各类异常 -------------------
      // 1. 触发JS运行时错误
      document.getElementById('triggerJsError').addEventListener('click', () => {
        // 故意制造一个未定义变量错误
        console.log(undefinedVariable);
      });

      // 2. 触发Axios接口异常
      document.getElementById('triggerAxiosError').addEventListener('click', () => {
        // 请求一个不存在的接口
        axios.get('https://jsonplaceholder.typicode.com/xxx/1');
      });

      // 3. 触发Fetch接口异常
      document.getElementById('triggerFetchError').addEventListener('click', () => {
        // 请求一个不存在的接口（不catch，可同时触发unhandledRejection）
        fetch('https://jsonplaceholder.typicode.com/yyy/1');
      });

      // 4. 触发未捕获的Promise拒绝
      document.getElementById('triggerPromiseReject').addEventListener('click', () => {
        Promise.reject(new Error('手动触发Promise拒绝'));
      });

      // 5. 资源加载异常（故意引入不存在的图片）
      const errImg = new Image();
      errImg.src = 'https://example.com/404.png'; // 不存在的图片，会触发resource_error
    </script>
  </body>
</html>
