# 从编译到执行：一文吃透 JavaScript 执行机制与闭包本质

作为前端开发者，JavaScript 的执行机制是绕不开的核心知识点——词法作用域、执行上下文、作用域链、闭包等概念看似零散，实则环环相扣。本文将从**编译阶段**到**执行阶段**，结合 V8 底层实现逻辑与具体代码案例，完整拆解 JavaScript 代码的运行全流程，帮你彻底打通底层逻辑，既方便自我复习，也能让初学者快速理解。

![js_execute.png](https://blog-huahua.oss-cn-beijing.aliyuncs.com/blog/code/js_execute.png)

## 一、先立核心框架：JavaScript 代码运行的两大阶段

所有 JavaScript 代码的执行，都遵循**「编译阶段定规则，执行阶段跑逻辑」**的核心逻辑，两个阶段分工明确、层层递进，共同构成了代码运行的底层骨架：

- **编译阶段**：引擎扫描代码，确定词法作用域，为每个函数生成作用域蓝图（ScopeInfo），只记录「关系」，不存「数据」；

- **执行阶段**：创建执行上下文并压入上下文栈，分**创建阶段**和**执行阶段**完成变量初始化、作用域链构建、this 绑定，最终执行代码逻辑，同时处理上下文的销毁与保留（闭包核心）。

下面我们结合具体代码，逐阶段拆解每一步的底层行为。

## 二、编译阶段：词法作用域的「蓝图绘制」

当 JavaScript 引擎接收到代码时，首先进入**编译阶段**（也叫词法分析/语法分析阶段）。这一阶段的核心任务是**确定词法作用域**，并为每个函数生成专属的 `ScopeInfo`（作用域信息）——相当于给每个函数画一张「作用域蓝图」，记录它能访问哪些父级作用域、包含哪些变量。

### 1. 编译阶段的核心行为

- 引擎扫描代码，解析出所有函数、变量的声明位置，确定**词法作用域**（代码书写位置决定作用域，与调用位置无关，这是 JavaScript 默认的作用域规则）；

- 为每个函数生成 `ScopeInfo`，记录：作用域类型（全局/函数/块级）、自身变量、被内部函数引用的变量（捕获变量）、父级作用域的引用关系；

- 此时仅记录「静态结构」，不创建任何运行时对象，变量也没有实际值，父级作用域仅以「模糊指针」形式存在。

### 2. 代码案例：编译阶段的 ScopeInfo 生成

我们以经典的闭包代码为例，看编译阶段引擎做了什么：

```JavaScript

// 全局作用域
var globalVar = "全局变量";

function outer() {
  // outer 函数作用域
  var outerVar = "外层变量";
  let outerLet = "外层 let 变量";

  function inner() {
    // inner 函数作用域
    console.log(globalVar); // 访问全局变量
    console.log(outerVar);  // 访问外层函数变量（闭包核心）
    console.log(outerLet);   // 访问外层 let 变量
  }

  return inner; // 将 inner 函数返回至全局
}

// 全局代码执行入口
var fn = outer();
fn();
```

编译阶段，引擎会为三个作用域（全局、outer、inner）生成对应的 `ScopeInfo`，结构如下（简化版）：

```Plain Text

// 全局作用域 ScopeInfo
global.ScopeInfo = {
  type: "GLOBAL_SCOPE",
  variables: ["globalVar", "outer", "fn"], // 全局声明的变量/函数
  captured_vars: [],
  parent: null // 全局作用域无父级
}

// outer 函数 ScopeInfo
outer.ScopeInfo = {
  type: "FUNCTION_SCOPE",
  variables: ["outerVar", "inner"], // var 声明的变量/函数
  lexical_vars: ["outerLet"], // let/const 声明的变量（词法环境）
  captured_vars: [],
  parent: global.ScopeInfo // 父级是全局作用域
}

// inner 函数 ScopeInfo
inner.ScopeInfo = {
  type: "FUNCTION_SCOPE",
  variables: [],
  lexical_vars: [],
  captured_vars: ["outerVar", "outerLet"], // 捕获外层变量（闭包标记）
  parent: outer.ScopeInfo // 父级是 outer 函数作用域
}
```

可以看到，编译阶段 `inner` 的 `ScopeInfo` 已经明确记录：「我需要访问 outer 和全局作用域」，但此时 `outer` 还未执行，没有实际的上下文对象，父级仅为「蓝图引用」。

## 三、执行阶段：上下文的「创建 → 执行 → 销毁」

编译完成后，代码进入**执行阶段**。执行阶段是代码真正运行的阶段，它又分为两个明确的子阶段：**创建阶段**与**执行阶段**，二者分工清晰、不可颠倒。

### 1. 执行阶段的核心载体：执行上下文

执行上下文是代码运行的「环境容器」，每个上下文包含三个核心部分：

- **变量环境**：存储 `var` 声明的变量、函数声明、函数参数（对应传统 VO）；

- **词法环境**：存储 `let/const` 声明的变量、块级作用域变量；

- **作用域链**：由「当前上下文 + 父级上下文」组成的链表，用于变量查找；

- **this**：当前代码的执行环境对象，在创建阶段绑定完成。

注：ES5+ 规范中，变量对象（VO）被细化为「变量环境」，词法环境独立拆分，二者共同构成上下文的变量存储体系；V8 底层则用 `Context` 对象承载，通过 `slots` 数组存储变量值，提升访问效率。

### 2. 执行阶段的两个子阶段

#### （1）创建阶段：定死作用域与 this

创建阶段是上下文的初始化阶段，核心是完成三件事，且一旦完成，作用域链和 this 的指向**不再改变**：

1. **初始化变量环境与词法环境**

    - 变量环境：创建 `var` 变量（初始值 `undefined`）、函数声明（直接赋值函数对象）、函数参数（赋值实参）；

    - 词法环境：创建 `let/const` 变量（初始值为「暂时性死区」，不可访问）；

2. **构建作用域链**：将当前上下文作为链头，拼接编译阶段记录的父级 `ScopeInfo` 对应的**实际上下文引用**（模糊指针变为具体引用），形成完整的上下文链表；

3. **绑定 this**：根据调用规则（默认/隐式/显式/new）确定 this 指向，绑定后不再修改。

#### （2）执行阶段：真正运行代码

创建阶段完成后，进入真正的执行阶段：

- 逐行执行代码，为变量赋值（`var` 变量从 `undefined` 变为实际值，`let/const` 变量脱离暂时性死区）；

- 访问变量时，沿着作用域链逐层查找（先当前上下文，再父级，直到全局）；

- 函数调用时，创建新的函数执行上下文，压入上下文栈，重复「创建 → 执行」流程；

- 代码执行完毕后，上下文从栈中弹出，**若无外部引用则销毁，有引用则保留（闭包）**。

### 3. 代码案例：逐行拆解执行全流程

我们继续用上面的闭包代码，逐阶段分析执行行为：

#### 第一步：全局代码执行（进入全局上下文）

1. **创建全局执行上下文**，压入上下文栈（栈底）；

2. **创建阶段**：

    - 变量环境：初始化 `globalVar`（`undefined`）、`outer`（函数对象）、`fn`（`undefined`）；

    - 词法环境：无 `let/const` 变量；

    - 作用域链：`[全局上下文]`（无父级）；

    - this 绑定：指向 `window`（浏览器环境）；

3. **执行阶段**：

    - `globalVar = "全局变量"`：变量环境中 `globalVar` 赋值为字符串；

    - `var fn = outer()`：调用 `outer()`，进入 outer 函数执行上下文。

#### 第二步：outer 函数执行（进入 outer 上下文）

1. **创建 outer 函数执行上下文**，压入上下文栈（栈顶）；

2. **创建阶段**：

    - 变量环境：初始化 `outerVar`（`undefined`）、`inner`（函数对象）；

    - 词法环境：初始化 `outerLet`（暂时性死区）；

    - 作用域链：`[outer 上下文, 全局上下文]`（父级指针从模糊变为具体引用）；

    - this 绑定：指向 `window`（默认调用）；

3. **执行阶段**：

    - `outerVar = "外层变量"`：变量环境中 `outerVar` 赋值；

    - `outerLet = "外层 let 变量"`：词法环境中 `outerLet` 赋值，脱离暂时性死区；

    - `return inner`：将 inner 函数对象返回给全局 `fn`，**此时 inner 函数的 [[Scopes]] 属性捕获了 outer 上下文的引用**；

4. **outer 执行完毕**：上下文从栈中弹出，**但因 inner 引用了 outer 上下文，故不销毁**（闭包形成）。

#### 第三步：fn() 执行（进入 inner 上下文）

1. **创建 inner 函数执行上下文**，压入上下文栈（栈顶）；

2. **创建阶段**：

    - 变量环境/词法环境：无自身变量；

    - 作用域链：`[inner 上下文, outer 上下文, 全局上下文]`（拼接 inner 的 [[Scopes]]）；

    - this 绑定：指向 `window`；

3. **执行阶段**：

    - `console.log(globalVar)`：沿作用域链找到全局上下文的 `globalVar`，输出「全局变量」；

    - `console.log(outerVar)`：沿作用域链找到 outer 上下文的 `outerVar`，输出「外层变量」；

    - `console.log(outerLet)`：沿作用域链找到 outer 上下文的 `outerLet`，输出「外层 let 变量」；

4. **inner 执行完毕**：上下文从栈中弹出，无外部引用，直接销毁。

#### 第四步：全局代码执行完毕

全局上下文从栈中弹出，若无其他引用，全局上下文销毁，程序结束。

## 四、闭包的本质：上下文的「延迟销毁」

通过上面的代码分析，我们能清晰看到闭包的核心逻辑：**父函数执行完毕后，上下文本该销毁，但因内部函数（闭包）的 [[Scopes]] 属性保留了对父上下文的引用，导致父上下文无法被垃圾回收，从而实现「外部访问内部作用域变量」的效果**。

### 1. 闭包的形成条件

- 函数嵌套：内部函数定义在外部函数内部；

- 内部函数引用了外部函数的变量（捕获变量）；

- 内部函数被暴露到外部函数的作用域之外（如 return、赋值给全局变量、作为回调函数）。

### 2. 闭包的内存机制

正常情况下，函数执行完毕后，执行上下文出栈并销毁，变量对象被垃圾回收；但闭包场景下，**内部函数的 [[Scopes]] 是父上下文的强引用**，只要内部函数存在（如全局的 `fn`），父上下文就会一直保留在内存中，直到内部函数被销毁（如 `fn = null`），父上下文才会被垃圾回收。

## 五、V8 底层实现：从规范到工程化

上述流程是 ECMAScript 规范的定义，而 V8 作为主流 JavaScript 引擎，在实现上做了工程化优化，但核心逻辑一致：

1. **编译阶段**：V8 用 `ScopeInfo` 记录作用域结构，存储在函数对象的内部属性中，不创建运行时对象；

2. **执行阶段**：V8 创建 `Context` 对象承载执行上下文，通过 `slots` 数组存储变量（替代对象属性，提升速度），作用域链是 `Scope` 链表，每个 `Scope` 指向一个 `Context`；

3. **闭包实现**：内部函数的 [[Scopes]] 直接引用父 `Context`，V8 的垃圾回收器通过引用计数判断 `Context` 是否可回收，有引用则保留。
<!-- 
## 六、总结：思维导图串起全流程

为了方便你快速回顾和记忆，我将全文核心逻辑整理成了思维导图，一眼看懂 JavaScript 执行全链路：

```mermaid
markmap
## **编译阶段**
- 核心：确定词法作用域，生成ScopeInfo
- 行为：扫描代码、记录作用域关系、标记捕获变量
- 产物：函数的[[Scopes]]蓝图（仅结构，无数据）
## **执行阶段**
- 执行上下文（核心载体）
  - 变量环境：var/函数/arguments
  - 词法环境：let/const/块级作用域
  - 作用域链：上下文引用链表
  - this：执行环境对象
- 创建阶段（初始化）
  - 初始化变量/词法环境
  - 构建作用域链（模糊→具体引用）
  - 绑定this（绑定后不变）
- 执行阶段（运行代码）
  - 逐行执行、变量赋值
  - 沿作用域链查找变量
  - 函数调用：创建新上下文入栈
  - 执行完毕：出栈（销毁/保留）
## **闭包本质**
- 形成条件：嵌套+引用+外部暴露
- 核心：内部函数[[Scopes]]引用父上下文
- 内存机制：父上下文延迟销毁，直到引用消失
## **V8底层实现**
- 编译：ScopeInfo记录作用域结构
- 执行：Context承载上下文，slots存变量
- 作用域链：Scope链表指向Context
- 闭包：[[Scopes]]强引用父Context -->
<!-- ``` -->
<!-- 理解这一整套机制，不仅能搞定面试中的高频考点，更能在实际开发中规避闭包内存泄漏、变量查找错误等问题，是前端开发者进阶的必备底层能力。 -->

