import{_ as e,c as r,o as t,ae as o}from"./chunks/framework.CRdajAWK.js";const p=JSON.parse('{"title":"核心算法思想","description":"","frontmatter":{},"headers":[],"relativePath":"notes/03-algorithms.md","filePath":"notes/03-algorithms.md"}'),i={name:"notes/03-algorithms.md"};function l(n,a,h,s,d,c){return t(),r("div",null,[...a[0]||(a[0]=[o('<h1 id="核心算法思想" tabindex="-1">核心算法思想 <a class="header-anchor" href="#核心算法思想" aria-label="Permalink to &quot;核心算法思想&quot;">​</a></h1><h2 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h2><h3 id="快速排序-quick-sort" tabindex="-1">快速排序（Quick Sort） <a class="header-anchor" href="#快速排序-quick-sort" aria-label="Permalink to &quot;快速排序（Quick Sort）&quot;">​</a></h3><p>时间复杂度：平均 O(nlogn)，最坏 O(n²) 空间复杂度：O(logn)</p><h3 id="归并排序-merge-sort" tabindex="-1">归并排序（Merge Sort） <a class="header-anchor" href="#归并排序-merge-sort" aria-label="Permalink to &quot;归并排序（Merge Sort）&quot;">​</a></h3><p>时间复杂度：O(nlogn) 空间复杂度：O(n)</p><h3 id="堆排序-heap-sort" tabindex="-1">堆排序（Heap Sort） <a class="header-anchor" href="#堆排序-heap-sort" aria-label="Permalink to &quot;堆排序（Heap Sort）&quot;">​</a></h3><p>时间复杂度：O(nlogn) 空间复杂度：O(1)</p><h2 id="搜索算法" tabindex="-1">搜索算法 <a class="header-anchor" href="#搜索算法" aria-label="Permalink to &quot;搜索算法&quot;">​</a></h2><h3 id="二分查找-binary-search" tabindex="-1">二分查找（Binary Search） <a class="header-anchor" href="#二分查找-binary-search" aria-label="Permalink to &quot;二分查找（Binary Search）&quot;">​</a></h3><p>时间复杂度：O(logn) 前提条件：有序数组</p><h3 id="dfs-深度优先搜索" tabindex="-1">DFS（深度优先搜索） <a class="header-anchor" href="#dfs-深度优先搜索" aria-label="Permalink to &quot;DFS（深度优先搜索）&quot;">​</a></h3><h3 id="bfs-广度优先搜索" tabindex="-1">BFS（广度优先搜索） <a class="header-anchor" href="#bfs-广度优先搜索" aria-label="Permalink to &quot;BFS（广度优先搜索）&quot;">​</a></h3><h2 id="动态规划-dp" tabindex="-1">动态规划（DP） <a class="header-anchor" href="#动态规划-dp" aria-label="Permalink to &quot;动态规划（DP）&quot;">​</a></h2><p>动态规划通过将问题分解为子问题来求解。</p><p><strong>核心思想：</strong></p><ul><li>状态定义</li><li>状态转移方程</li><li>边界条件</li></ul><h2 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h2><p>贪心算法在每一步都做出当前最优的选择。</p><p><strong>适用场景：</strong></p><ul><li>活动选择问题</li><li>最小生成树</li><li>最短路径问题</li></ul>',21)])])}const b=e(i,[["render",l]]);export{p as __pageData,b as default};
