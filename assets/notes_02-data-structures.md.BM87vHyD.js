import{_ as s,c as i,o as l,ae as n}from"./chunks/framework.CRdajAWK.js";const u=JSON.parse('{"title":"基础数据结构","description":"","frontmatter":{},"headers":[],"relativePath":"notes/02-data-structures.md","filePath":"notes/02-data-structures.md"}'),e={name:"notes/02-data-structures.md"};function t(r,a,p,h,k,d){return l(),i("div",null,[...a[0]||(a[0]=[n(`<h1 id="基础数据结构" tabindex="-1">基础数据结构 <a class="header-anchor" href="#基础数据结构" aria-label="Permalink to &quot;基础数据结构&quot;">​</a></h1><h2 id="数组-链表" tabindex="-1">数组 &amp; 链表 <a class="header-anchor" href="#数组-链表" aria-label="Permalink to &quot;数组 &amp; 链表&quot;">​</a></h2><h3 id="数组-array" tabindex="-1">数组（Array） <a class="header-anchor" href="#数组-array" aria-label="Permalink to &quot;数组（Array）&quot;">​</a></h3><p>数组是最基础的数据结构，支持随机访问，时间复杂度为 O(1)。</p><p><strong>特点：</strong></p><ul><li>连续的内存空间</li><li>随机访问效率高</li><li>插入和删除需要移动元素，效率较低</li></ul><h3 id="链表-linked-list" tabindex="-1">链表（Linked List） <a class="header-anchor" href="#链表-linked-list" aria-label="Permalink to &quot;链表（Linked List）&quot;">​</a></h3><p>链表通过指针连接节点，支持动态扩容。</p><p><strong>特点：</strong></p><ul><li>非连续的内存空间</li><li>插入和删除效率高</li><li>不支持随机访问</li></ul><p><strong>示例代码：</strong></p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 单向链表实现示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { SinglyLinkedList } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@ds-algo/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SinglyLinkedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list.head?.val); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="栈-队列" tabindex="-1">栈 &amp; 队列 <a class="header-anchor" href="#栈-队列" aria-label="Permalink to &quot;栈 &amp; 队列&quot;">​</a></h2><h3 id="栈-stack" tabindex="-1">栈（Stack） <a class="header-anchor" href="#栈-stack" aria-label="Permalink to &quot;栈（Stack）&quot;">​</a></h3><p>栈是一种后进先出（LIFO）的数据结构。</p><p><strong>应用场景：</strong></p><ul><li>函数调用栈</li><li>表达式求值</li><li>括号匹配</li></ul><h3 id="队列-queue" tabindex="-1">队列（Queue） <a class="header-anchor" href="#队列-queue" aria-label="Permalink to &quot;队列（Queue）&quot;">​</a></h3><p>队列是一种先进先出（FIFO）的数据结构。</p><p><strong>应用场景：</strong></p><ul><li>任务调度</li><li>消息队列</li><li>BFS 算法</li></ul><h2 id="哈希表" tabindex="-1">哈希表 <a class="header-anchor" href="#哈希表" aria-label="Permalink to &quot;哈希表&quot;">​</a></h2><p>哈希表通过哈希函数将键映射到值，实现 O(1) 的平均时间复杂度。</p><p><strong>应用场景：</strong></p><ul><li>快速查找</li><li>去重</li><li>缓存实现（LRU Cache）</li></ul><h2 id="树-堆" tabindex="-1">树 &amp; 堆 <a class="header-anchor" href="#树-堆" aria-label="Permalink to &quot;树 &amp; 堆&quot;">​</a></h2><h3 id="二叉树-binary-tree" tabindex="-1">二叉树（Binary Tree） <a class="header-anchor" href="#二叉树-binary-tree" aria-label="Permalink to &quot;二叉树（Binary Tree）&quot;">​</a></h3><p>二叉树是每个节点最多有两个子节点的树结构。</p><p><strong>常见类型：</strong></p><ul><li>二叉搜索树（BST）</li><li>平衡二叉树（AVL）</li><li>红黑树</li></ul><h3 id="堆-heap" tabindex="-1">堆（Heap） <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆（Heap）&quot;">​</a></h3><p>堆是一种特殊的完全二叉树，常用于实现优先队列。</p><p><strong>类型：</strong></p><ul><li>大顶堆：父节点 &gt;= 子节点</li><li>小顶堆：父节点 &lt;= 子节点</li></ul><p><strong>应用场景：</strong></p><ul><li>优先队列</li><li>Top K 问题</li><li>堆排序</li></ul>`,36)])])}const c=s(e,[["render",t]]);export{u as __pageData,c as default};
